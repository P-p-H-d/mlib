M\*LIB: a Generic type-safe Container Library in C language
==========================================================

Overview
--------

M\*LIB (M star lib) is a C library enabling to use **generic and
type safe container** in pure C language, aka handling generic
[containers](https://en.wikipedia.org/wiki/Container_%28abstract_data_type%29).
The objects within the containers can still have proper constructor, destructor
(and other methods):
this is handled by the library. This makes it possible to construct fully
recursive objects (container-of[...]-container-of-type-T),
without erasing type information (typically using void pointers or resorting
to C macro to access the container).

This is an equivalent of the [C++](https://en.wikipedia.org/wiki/C%2B%2B)
[STL](https://en.wikipedia.org/wiki/Standard_Template_Library) but for standard ISO C99.
There is not a strict mapping as both the STL and M\*LIB have their exclusive containers:
See [here](https://github.com/P-p-H-d/mlib/wiki/STL-to-M*LIB-mapping) for details.

M\*LIB is portable to any systems that support [ISO C99](https://en.wikipedia.org/wiki/C99).
Some optional features need at least [ISO C11](https://en.wikipedia.org/wiki/C11_(C_standard_revision)).

M\*LIB is **only** composed of a set of headers.
There is no C file: you just have to put the header in the search path of your compiler,
and it will work.
There is no dependency (except some other headers of M\*LIB and the LIBC).

One of M\*LIB's design key is to ensure safety. This is done by multiple means:

* in debug mode, defensive programming is extensively used:
the contracts of the function are checked, ensuring
that the data are not corrupted. For example, 
[Buffer overflow](https://en.wikipedia.org/wiki/Buffer_overflow) are checked in this mode
through [bound checking](https://en.wikipedia.org/wiki/Bounds_checking)
or the intrinsic properties of a Red-Black tree are verified.
* very few casts are used within the library. Still the library can be used
with the greatest level of warnings by a C compiler without
any aliasing warning.
* the genericity is not done directly by macro, but indirectly by making them
define inline functions with the proper prototypes: this enables
the user calls to have proper warning checks.

Other key designs are:

* do not rewrite the C library and just wrap around it (for example don't rewrite sort but stable sort),
* do not make users pay the cost of what they don't need.

Due to the [weak](https://en.wikipedia.org/wiki/Strong_and_weak_typing#Pointers)  nature of the C language for pointers,
[type safe](https://en.wikipedia.org/wiki/Type_safety)
means that at least a warning
is generated by the compiler in case of wrong type passed as
container arguments to the functions.

M\*LIB is still be quite-efficient: even if the implementation may not always be state
of the art, there is no overhead in using this library rather than using
direct C low-level access: the compiler is able to **fully** optimize
the library calls
since all the functions are declared as inline.
In [fact](https://github.com/P-p-H-d/mlib/wiki/performance), M\*LIB
is one of the fastest generic C library you can find.

M\*LIB uses internally the 'malloc', 'realloc' and 'free' functions to handle
the memory pool. This behavior can be overridden at different level.
M\*LIB default policy is to abort the 
program if there is a memory error. However, this behavior
can also be customized.

M\*LIB may use a lot of assertions in its implementation to ensure safety: 
it is highly recommended to properly define NDEBUG for released programs. 

M\*LIB is distributed under BSD-2 simplified license.

It is strongly advised not to read the source to know how to use the library
but rather read the examples or the tests.

Components
----------

The available containers that doesn't require the user structure to be modified are:

* [m-array.h](#m-array): header for creating array of generic type and of variable size,
* [m-list.h](#m-list): header for creating singly-linked list of generic type,
* [m-deque.h](#m-deque): header for creating double-ended queue of generic type and of variable size,
* [m-dict.h](#m-dict): header for creating generic dictionary or set of generic type (and of variable kind),
* [m-rbtree.h](#m-rbtree): header for creating binary sorted tree of generic type,
* [m-bptree.h](#m-bptree): header for creating B+TREE of generic type,
* [m-tuple.h](#m-tuple): header for creating arbitrary tuple of generic type,
* [m-variant.h](#m-variant): header for creating arbitrary variant of generic type,
* [m-prioqueue.h](#m-prioqueue): header for creating priority queue of generic type and of variable size,

The available containers of M\*LIB for thread synchronization are:

* [m-buffer.h](#m-buffer): header for creating fixed-size queue (or stack) of generic type (multiple producer / multiple consumer),
* [m-snapshot](#m-snapshot): header for creating 'snapshot' buffer for sharing synchronously big data (thread safe).
* [m-shared.h](#m-shared): header for creating shared pointer of generic type.
* [m-concurrent.h](#m-concurrent): header for transforming a container into a concurrent container.
* [m-c-mempool.h]: WIP header for creating fast concurrent memory allocation.

The following containers are intrusive (You need to modify your structure to add fields needed by the container):

* [m-i-list.h](#m-i-list): header for creating doubly-linked intrusive list of generic type,
* [m-i-shared.h](#m-i-shared): header for creating intrusive shared pointer of generic type (Thread Safe),


Other headers offering other functionality are:

* [m-string.h](#m-string): header for creating dynamic variable-length string,
* [m-bitset.h](#m-bitset): header for creating bit set (or "packed array of bool"),
* [m-algo.h](#m-algo): header for providing various generic algorithms to the previous containers.
* [m-funcobj.h](#m-funcobj): header for creating function object (used by algorithm generation).
* [m-mempool.h](#m-mempool): header for creating specialized & fast memory allocator.
* [m-worker.h](#m-worker): header for providing an easy pool of workers on separated threads to handle work orders, used for parallelism tasks.
* [m-serial-json.h](#m-serial-json): header for importing / exporting the containers in [JSON format](https://en.wikipedia.org/wiki/JSON).
* [m-serial-bin.h](#m-serial-bin): header for importing / exporting the containers in an adhoc fast binary format.
* [m-genint.h]: internal header for generating unique integers in a concurrent context.
* [m-core.h](#m-core): header for meta-programming with the C preprocessor (used by all other headers).

Finally headers for compatibility with non C11 compilers:

* [m-atomic.h](#m-atomic): header for ensuring compatibility between C's stdatomic.h and C++'s atomic header. Provide also an implementation over mutex if none is available.
* [m-mutex.h](#m-mutex): header for providing a very thin layer across multiple implementation of mutex/threads (C11/PTHREAD/WIN32).

Each containers define their iterators.

All containers try to expose the same interface:
if the method name is the same, then it does the same thing
and is used in the same way.
In some rare case, the method has to be adapted to the container.

Each header can be used separately from others: dependency between headers have been kept to the minimum.

![Dependence between headers](https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/depend.png)


Build & Installation
--------------------

M\*LIB is **only** composed of a set of headers, as such there is no build for the library.
The library doesn't depend on any other library than the LIBC.

To run the test suite, run:

       make check

To generate the documentation, run:

       make doc

To install the headers, run:

       make install PREFIX=/my/directory/where/to/install

Other targets exist. Mainly for development purpose.


How to use
----------

To use these data structures, you include the desired header,
instantiate the definition of the structure and its associated methods
by using a macro _DEF for the needed type.
Then you use the defined functions. Let's see a first simple example
that creates a list of unsigned int:

    #include <stdio.h>
    #include "m-list.h"
    
    LIST_DEF(list_uint, unsigned int)      /* Define struct list_uint_t and its methods */
    
    int main(void) {
       list_uint_t list ;             /* list_uint_t has been define above */
       list_uint_init(list);          /* All type needs to be initialized */
       list_uint_push_back(list, 42); /* Push 42 in the list */
       list_uint_push_back(list, 17); /* Push 17 in the list */
       list_uint_it_t it;             /* Define an iterator to scan each one */
       for(list_uint_it(it, list)     /* Start iterator on first element */
           ; !list_uint_end_p(it)     /* Until the end is not reached */
           ; list_uint_next(it)) {    /* Set the iterator to the next element*/
              printf("%d\n",          /* Get a reference to the underlying */
                *list_uint_cref(it)); /* data and print it */
       }
       list_uint_clear(list);         /* Clear all the list */
    }

[ Do not forget to add -std=c99 (or c11) to your compile command to request a C99 compatible build ]

This looks like a typical C program except the line with 'LIST\_DEF'
that doesn't have any semi-colon at the end. And in fact, except
this line, everything is typical C program and even macro free!
The only macro is in fact LIST\_DEF: this macro expands to the
good type for the list of the defined type and to all the necessary
functions needed to handle such type. It is heavily context dependent
and can generate different code depending on it.
You can use it as many times as needed to defined as many lists as you want.
The first argument of the macro is the name to use, e.g. the prefix that
shall be added to all generated functions and types.
The second argument of the macro is the type to embed within the container.
It can be any C type.
The third argument of the macro is optional and is the oplist to use.
See below for more information.


You could replace LIST\_DEF by ARRAY\_DEF to change
the kind of container (an array instead of a linked list)
without changing the code below: the generated interface
of a list or of an array is very similar.
Yet the performance remains the same as hand-written code
for both the list variant and the array variant.

This is equivalent to this C++ program using the STL:

    #include <iostream>
    #include <list>
    
    typedef std::list<unsigned int> list_uint_t;
    typedef std::list<unsigned int>::iterator list_uint_it_t;
    
    int main(void) {
       list_uint_t list ;             /* list_uint_t has been define above */
       list.push_back(42);            /* Push 42 in the list */
       list.push_back(17);            /* Push 17 in the list */
       for(list_uint_it_t it = list.begin()  /* Iterator is first element*/
           ; it != list.end()         /* Until the end is not reached */
           ; ++it) {                  /* Set the iterator to the next element*/
           std::cout << *it << '\n';  /* Print the underlying data */
       }
    }

As you can see, this is rather equivalent with the following remarks:

* M\*LIB requires an explicit definition of the instance of the list,
* M\*LIB code is more verbose in the method name,
* M\*LIB needs explicit construction and destruction (as plain old C requests),
* M\*LIB doesn't return a value to the underlying data but a pointer to this value:
  - this was done for performance (it avoids copying all the data within the stack)
  - and for generality reasons (some structure may not allow copying data).

Note: list\_uint\_t is internally defined as an array of structure of size 1.
This has the following advantages:

* you effectively reserve the data whenever you declare a variable,
* you pass automatically the variable per reference for function calls,
* you can not copy the variable by an affectation (you have to use the API instead).

You can also condense the M\*LIB code by using the M\_EACH & M\_LET macros if you are not afraid of using syntactic macros:

    #include <stdio.h>
    #include "m-list.h"
    
    LIST_DEF(list_uint, unsigned int)   /* Define struct list_uint_t and its methods */
    
    int main(void) {
       M_LET(list, LIST_OPLIST(uint)) { /* Define & init list as list_uint_t */
         list_uint_push_back(list, 42); /* Push 42 in the list */
         list_uint_push_back(list, 17); /* Push 17 in the list */
         for M_EACH(item, list, LIST_OPLIST(uint)) {
           printf("%d\n", *item);       /* Print the item */
         }
       }                                /* Clear of list will be done now */
    }

Here is another example with a complete type (with proper initialization & clear function) by using the [GMP](https://gmplib.org/) library:

    #include <stdio.h>
    #include <gmp.h>
    #include "m-array.h"

    ARRAY_DEF(array_mpz, mpz_t, (INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), CLEAR(mpz_clear)) )

    int main(void) {
       array_mpz_t array ;             /* array_mpz_t has been define above */
       array_mpz_init(array);          /* All type needs to be initialized */
       mpz_t z;                        /* Define a mpz_t type */
       mpz_init(z);                    /* Initialize the z variable */
       mpz_set_ui (z, 42);
       array_mpz_push_back(array, z);  /* Push 42 in the array */
       mpz_set_ui (z, 17);
       array_mpz_push_back(array, z); /* Push 17 in the array */
       array_it_mpz_t it;              /* Define an iterator to scan each one */
       for(array_mpz_it(it, array)     /* Start iterator on first element */
           ; !array_mpz_end_p(it)      /* Until the end is not reached */
           ; array_mpz_next(it)) {     /* Set the iterator to the next element*/
              gmp_printf("%Zd\n",      /* Get a reference to the underlying */
                *array_mpz_cref(it));  /* data and print it */
       }
       mpz_clear(z);                   /* Clear the z variable */
       array_mpz_clear(array);         /* Clear all the array */
    }

As the mpz\_t type needs proper initialization, copy and destroy functions
we need to tell to the container how to handle such a type.
This is done by giving it the oplist associated to the type.
An oplist is an associative array where the operators are associated to methods.
In the example, we tell to the container to use
the mpz\_init function for the INIT operator of the type,
the mpz\_clear function for the CLEAR operator of the type,
the mpz\_set function for the SET operator of the type,
the mpz\_init\_set function for the INIT\_SET operator of the type.
See oplist chapter for more information.

We can also write the same example shorter:

    #include <stdio.h>
    #include <gmp.h>
    #include "m-array.h"
    
    // Register the oplist of a mpz_t. It is a classic oplist.
    #define M_OPL_mpz_t() M_CLASSIC_OPLIST(mpz)
    // Define an instance of an array of mpz_t (both type and function)
    ARRAY_DEF(array_mpz, mpz_t)
    // Register the oplist of the created instance of array of mpz_t
    #define M_OPL_array_mpz_t() ARRAY_OPLIST(array_mpz, M_OPL_mpz_t())
    
    int main(void) {
      // Let's define 'array' as an 'array_mpz_t' & initialize it.
      M_LET(array, array_mpz_t)
        // Let's define 'z1' and 'z2' to be 'mpz_t' & initialize it
        M_LET (z1, z2, mpz_t) {
         mpz_set_ui (z1, 42);
         array_mpz_push_back(array, z1);  /* Push 42 in the array */
         mpz_set_ui (z2, 17);
         array_mpz_push_back(array, z2); /* Push 17 in the array */
         // Let's iterate over all items of the container
         for M_EACH(item, array, array_mpz_t) {
              gmp_printf("%Zd\n", *item);
         }
      } // All variables are cleared with the proper method beyond this point.
      return 0;
    }

Or even shorter when you're comfortable enough with the library:

        #include <stdio.h>
        #include <gmp.h>
        #include "m-array.h"
        
        // Register the oplist of a mpz_t. It is a classic oplist.
        #define M_OPL_mpz_t() M_OPEXTEND(M_CLASSIC_OPLIST(mpz), INIT_WITH(mpz_init_set_ui) )
        // Define an instance of an array of mpz_t (both type and function)
        ARRAY_DEF(array_mpz, mpz_t)
        // Register the oplist of the created instance of array of mpz_t
        #define M_OPL_array_mpz_t() ARRAY_OPLIST(array_mpz, M_OPL_mpz_t())
        
        int main(void) {
          // Let's define & init 'z1=42' and 'z2=17' to be 'mpz_t'
          M_LET ((z1,42), (z2,17), mpz_t)
            // Let's define 'array' as an 'array_mpz_t' with 'z1' and 'z2'
            M_LET((array,z1,z2), array_mpz_t) {
             // Let's iterate over all items of the container
             for M_EACH(item, array, array_mpz_t) {
                  gmp_printf("%Zd\n", *item);
             }
          } // All variables are cleared with the proper method beyond this point.
          return 0;
        }


There are two ways a container can known what is the oplist of a type:

* either the oplist is passed explicitly for each definition of container and for the LET & EACH macros,
* or the oplist is registered globally by defining a new macro starting with the prefix M\_OPL\_ and finishing with the name of type (don't forget the parenthesis). The macros performing the definition of container and the LET & EACH will test if such macro is defined. If it is defined, it will be used. Otherwise default methods are used.

Here we can see that we register the mpz\_t type into the container with
the minimum information of its interface needed.

We can also see in this example so the container ARRAY provides also
a macro to define the oplist of the array itself. This is true for
all containers and this enables to define proper recursive container like in this example
which reads from a text file a definition of sections:

        #include <stdio.h>
        #include "m-array.h"
        #include "m-tuple.h"
        #include "m-dict.h"
        #include "m-string.h"
        
        TUPLE_DEF2(symbol, (offset, long), (value, long))
        #define M_OPL_symbol_t() TUPLE_OPLIST(symbol, M_DEFAULT_OPLIST, M_DEFAULT_OPLIST)
        
        ARRAY_DEF(array_symbol, symbol_t)
        #define M_OPL_array_symbol_t() ARRAY_OPLIST(array_symbol, M_OPL_symbol_t())
        
        DICT_DEF2(sections, string_t, array_symbol_t)
        #define M_OPL_sections_t() DICT_OPLIST(sections, STRING_OPLIST, M_OPL_array_symbol_t())
        
        int main(int argc, const char *argv[])
        {
          if (argc < 2) abort();
          FILE *f = fopen(argv[1], "rt");
          if (!f) abort();
          M_LET(sc, sections_t) {
            sections_in_str(sc, f);
            array_symbol_t *a = sections_get(sc, STRING_CTE(".text"));
            if (a == NULL) {
              printf("There is no .text section.");
            } else {
              printf("Section .text is :");
              array_symbol_out_str(stdout, *a);
              printf("\n");
            }
          }
          return 0;
        }

This example reads the data from a file
and outputs the .text section if it finds it on the terminal.

Other examples are available in the example folder.

Internal fields of the structure are subject to change even for small revision
of the library.

The final goal of the library is to be able to write code like this in pure C while keeping type safety and compile time name resolution:

	let(list, list_uint_t) {
	  push(list, 42);
	  push(list, 17);
	  for each (item, list) {
	    print(item, "\n");
	  }
	}


OPLIST
------

An OPLIST is a fundamental notion of M\*LIB that hasn't be used in any other library.
In order to know how to operate on a type, M\*LIB needs additional information
as the compiler doesn't know how to handle properly any type (contrary to C++).
This is done by giving an operator list (or oplist in short) to any macro that
needs to handle the type. As such, an oplist as only meaning within a macro
expansion. Fundamentally, this is the exposed interface of a type with documented
operators using an associative array implemented with the only C preprocessor
where the operators are the predefined keys and the methods are the values.

An oplist is an associative array of operator over methods in the following format:

(OPERATOR1(method1), OPERATOR2(method2), ...)

The function 'method1' is used to handle 'OPERATOR1'.
The function 'method2' is used to handle 'OPERATOR2'. etc.
The order of the operator in this list is the priority order:
in case the same operator appear multiple times in the list,
the first one is the priority.

It is used to perform the association between the operation on a type
and the function that performs this operation.
Without an oplist, M\*LIB has no way to known how to deal with your type
and will deal with it like a classic C type.

When you define an instance of a new container, you give the type oplist
you want to use as the base of the container. This type oplist performs
the association between the operators and the methods for the type.
In function of the available interface of the oplist, the container definition macro
function generates the interface of the container. You can then use this interface
directly. You can also use the oplist of the container to chain this new interface
with another container, creating container-of-container.
![oplist and definition](https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/oplist.png)

A function name can be followed by the token M\_IPTR in the oplist
(for example: (INIT(init\_func M\_IPTR)) )
to specify that the function accept as its *first* argument a pointer
to the type rather than the type itself
(aka the prototype is init\_func(type `*`) instead of init\_func(type)).
If you use the '[1]' trick (see below), you won't need this.
See also the API\_* transformation call below for further transformation
means of the calls.

An oplist has no real form from a C language point of view. It is just an abstraction
that disappears after the macro expansion step of the preprocessing.

For each object / container, an oplist is needed and the following operators are
usually expected for an object:

* INIT constructor(obj): initialize the object 'obj' into a valid state.
* INIT\_SET constructor(obj, org): initialize the object 'obj' into the same state as the object 'org'.
* SET operator(obj, org): set the initialized object 'obj' into the same state as the initialized object org.
* CLEAR destructor(obj): destroy the initialized object 'obj', releasing any attached memory. This method shall never fail.

INIT, INIT\_SET & SET methods shall only fail due to ***memory errors***.

Not all operators are needed within an oplist to handle a container.
If some operator is missing, the associated default operator of the function is used.
To use C integer or float types, the default constructors are perfectly fine:
you may use M\_DEFAULT\_OPLIST to define the operator list of such types or you
can just omit it.

NOTE: An iterator doesn't have a constructor nor destructor methods.
It shall not allocate any memory. A reference to an object through
an iterator is only valid until another reference is taken from the same
container (potentialy through another iterator),
the iterator is moved, or the container changed.
Some containers may lessen these constraints.

Other documented operators are:

* NAME() --> prefix: Return the base name (prefix) used to construct the container.
* TYPE() --> type: Return the base type associated to this oplist.
* SUBTYPE() --> type: Return the type of the element stored in the container.
* OPLIST() --> oplist: Return the oplist of the type of the elements stored in the container.
* KEY_TYPE() --> key_t: Return the type of key for associative containers.
* VALUE_TYPE() --> value_t: Return the type of value for associative containers.
* KEY_OPLIST() --> oplist: Return the oplist of the key for associative containers.
* VALUE_OPLIST() --> oplist: Return the oplist of the value for associative containers.
* NEW (type) -> type pointer: allocate a new object (with suitable alignment and size) and return a pointer to it. The returned object is **not initialized** (INIT operator shall be called afterward). The default method is M\_MEMORY\_ALLOC (that allocates from the heap). It returns NULL in case of failure.
* DEL (&obj): free the allocated uninitialized object 'obj'. The object is not cleared before being free (CLEAR operator shall be called before). The object shall have been allocated by the associated NEW method. The default method is M\_MEMORY\_DEL (that frees to the heap).
* REALLOC(type, type pointer, number) --> type pointer: realloc the given array referenced by type pointer (either a NULL pointer or a pointer returned by the associated REALLOC method itself) to an array of the number of objects of this type and return a pointer to this new array. Previously objects pointed by the pointer are kept up to the minimum of the new size and old one. New objects are not initialized (INIT operator shall be called afterward). Freed objects are not cleared (CLEAR operator shall be called before). The default is M\_MEMORY\_REALLOC (that allocates from the heap). It returns NULL in case of failure in which case the original array is not modified.
* FREE (&obj) : free the allocated uninitialized array object 'obj'. The objects are not cleared before being free (CLEAR operator has to be called before).  The object shall have been allocated by the associated REALLOC method. The default is M\_MEMORY\_FREE (that frees to the heap).
* INC\_ALLOC(size\_t s) -> size\_t: Define the growing policy of an array (or equivalent structure). It returns a new allocation size based on the old allocation size ('s'). Default policy is to get the max between '2*s' and 16. If the returned value is lower than the old one, it is assumed that the size has overflowed.
* INIT\_MOVE(objd, objc): Initialize 'objd' to the same state than 'objc' by stealing as much resources as possible from 'objc', and then clear 'objc'. It is semantically equivalent to calling INIT\_SET(objd,objc) then CLEAR(objc) but is usually way faster. By default, all objects are assumed to be **trivially movable** (i.e. using memcpy to move an object is safe). Most C objects (even complex structure) are trivially movable. A notable exception are (in general) intrusive objects. If an object is not trivially movable, it shall provide an INIT\_MOVE method or disable the INIT\_MOVE method entirely. An INIT\_MOVE operator cannot fail due to memory failure.
* MOVE(objd, objc): Set 'objd' to the same state than 'objc' by stealing as resources as possible from 'objc' and then clear 'objc'. It is equivalent to calling SET(objd,objc) then CLEAR(objc) or CLEAR(objd) and then INIT\_MOVE(objd, objc). TBC if operator is really needed as calling CLEAR then INIT\_MOVE is what do all known implementation. A MOVE operator cannot fail due to memory failure.
* INIT\_WITH(obj, ...): Initialize the object 'obj' with a variable set of arguments. Arguments can be of different types and is up to the method to decide how to initialize the object based on this set. This is used in the M\_LET macro to initialize objects with the given values.
* SWAP(objd, objc): Swap the states of the object 'objc' and the object 'objd'.
* CLEAN(obj): Empty the container from all its objects. Nearly like CLEAR except that the container 'obj' remains initialized (but empty).
* HASH (obj) --> size_t: return a hash of the object (not a secure hash but one that is usable for a hash table). Default is performing a hash of the memory representation of the object. This default implementation is invalid if the object holds pointer to other objects.
* EQUAL(obj1, obj2) --> bool: Compare the object for equality. return true if both objects are equal, false otherwise. Default is using the C comparison operator. The method may be called with OOR object for the Open Addressing dictionary (in which case it shall return false).
* CMP(obj1, obj2) --> int: Provide a complete order the objects. return a negative integer if obj1 < obj2, 0 if obj1 = obj2, a positive integer otherwise. Default is C comparison operator.
* ADD(obj1, obj2, obj3) : Set obj1 to the sum of obj2 and obj3. Default is '+' C operator.
* SUB(obj1, obj2, obj3) : Set obj1 to the difference of obj2 and obj3. Default is '-' C operator.
* MUL(obj1, obj2, obj3) : Set obj1 to the product of obj2 and obj3. Default is '*' C operator.
* DIV(obj1, obj2, obj3) : Set obj1 to the division of obj2 and obj3. Default is '/' C operator.
* GET\_KEY (container, key) --> &obj: Return a pointer to the object within the container associated to the key 'key' or return NULL if no object is associated to this key. The pointer to the object remains valid until any modification of the container. 
* SET\_KEY (container, key, object): Associate the key 'key' to the object 'object' in the given container. 
* GET\_SET\_KEY (container, key) --> &obj: return a pointer to the object within the container associated to the key 'key' or create a new object in the container, associate it to the key 'key' and return its pointer. The pointer to the object remains valid until any modification of the container. The returned pointer is never NULL.
* ERASE\_KEY (container, key) --> bool: Erase the object associated to the key 'key' within the container. Return true if successful, false if the key is not found.
* GET\_SIZE (container) --> size_t: Return the number of elements in the container.
* PUSH(container, obj) : Push 'object' into 'container'. How & where it is pushed is container dependent.
* POP(&obj, container) : Pop an object from 'container' and save it in '*obj' if obj is not NULL (giving back the ownership to the caller). Which object is popped is container dependent. It is assumed that there is at least one object in the container.
* PUSH_MOVE(container, &obj) : Push and move the object '*obj' into 'container'. How it is pushed is container dependent but '*obj' is cleared afterward.
* POP_MOVE(&obj, container) : Pop an object from 'container' and **init & move** it in '*obj'. Which object is popped is container dependent. '*obj' shall be uninitialized. Undefined behavior is there is no object in the container.
* SPLICE\_BACK(containerDst, containerSrc, it): Move the object referenced by the iterator 'it' from the container 'containerSrc' into 'containerDst'. Where it is moved is container dependent (it is however likely to be just like for the PUSH method). Afterward 'it' references the next item in 'containerSrc'.
* SPLICE\_AT(containerDst, itDst, containerSrc, itSrc): Move the object referenced by the iterator 'itSrc' from the container 'containerSrc' just after the object referenced by the iterator 'itDst' in the container 'containerDst'. If 'itDst' doesn't reference a valid object (end value), it is inserted as the first item of the container (See method 'INSERT'). Afterward 'itSrc' references the next item in the container 'containerSrc'and 'itDst' references the moved item in the container 'containerDst'.
* IT\_TYPE() --> type: Return the type of an iterator object of this container.
* IT\_FIRST(it\_obj, container): Set the object iterator it\_obj to the first sub-element of container. What is the first element is container dependent (it may be front or back, or something else). However, iteraring from FIRST to LAST and finaly END ensures going through all elements of the container.
* IT\_LAST(it\_obj, container): set the object iterator it\_obj to the last sub-element of container.  What is the last element is container dependent (it may be front or back, or something else).
* IT\_END(it\_obj, container): Set the object iterator it\_obj to the end of the container (Can't use PREVIOUS or NEXT afterward). The END means that there is no object referenced by the iterator.
* IT\_SET(it\_obj, it\_obj2): Set the object iterator it\_obj to it\_obj2.
* IT\_END\_P(it\_obj)--> bool: Return true if it\_obj references the end of the container.
* IT\_LAST\_P(it\_obj)--> bool: Return true if the iterator it\_obj has reached the end of the container or if the iterator references the last element (just before the end).
* IT\_EQUAL\_P(it\_obj, it\_obj2) --> bool: Return true if both iterators reference the same element.
* IT\_NEXT(it\_obj): Move the iterator to the next sub-component. The direction of NEXT is container dependent.
* IT\_PREVIOUS(it\_obj): Move the iterator to the previous sub-component. The direction of PREVIOUS is container dependent, but it is assumed to be the reverse of NEXT.
* IT\_CREF(it\_obj) --> &obj: Return a constant pointer to the object referenced by the iterator. This pointer is valid until any modifiing operation on the container, or until another reference is taken from this container (some particular container may reduce theses constaints).
* IT\_REF(it\_obj) --> &obj: Return a pointer to the object referenced by the iterator. This pointer is valid until any modifiing operation on the container, or until another reference is taken from this container (some particular container may reduce theses constaints).
* IT\_REMOVE(container, it\_obj): Remove it\_obj from the container (clearing the associated object) and update it\_obj to point to the next object. All other iterators of the same container become invalidated.
* OUT\_STR(FILE* f, obj): Output 'obj' as a string into the FILE stream 'f'.
* IN\_STR(obj, FILE* f) --> bool: Set 'obj' to the value associated to the string representation of the object in the FILE stream 'f'. Return true in case of success (in that case the stream 'f' has been advanced to the end of the parsing of the object), false otherwise (in that case, the stream 'f' is in an undetermined position but is likely where the parsing fails).
* GET\_STR(string\_t str, obj, bool append): Set 'str' to a string representation of the object 'obj'. Append to the string if 'append' is true, set it otherwise. This requires the module m-string.
* PARSE\_STR(obj, const char *str, const char **endp) --> bool: Set 'obj' to the value associated to the string representation of the object in the char stream 'str'. Return true in case of success (in that case if endp is not NULL, it points to the end of the parsing of the object), false otherwise (in that case, if endp is not NULL, it points to an undetermined position but likely to be where the parsing fails).
* OUT\_SERIAL(m\_serial\_write\_t *serial, obj) --> m\_serial\_return\_code\_t : Output 'obj' into the configurable serialization stream 'serial' (See #[m-serial-json.h](#m-serial-json) for details and example). Return M\_SERIAL\_OK\_DONE in case of success, or M\_SERIAL\_FAIL otherwise .
* IN\_SERIAL(obj, m\_serial\_read\_t *serial) --> m\_serial\_return\_code\_t: Set 'obj' to its representation from the configurable serialization stream 'serial' (See #[m-serial-json.h](#m-serial-json) for details and example). M\_SERIAL\_OK\_DONE in case of success (in that case the stream 'serial' has been advanced up to the complete parsing of the object), or M\_SERIAL\_FAIL otherwise (in that case, the stream 'serial' is in an undetermined position but usually around the next characters after the first failure).
* UPDATE(dest, src): Update the object 'dest' with the object 'src'. What it does exactly is container dependent. It can either SET or ADD to the node the new 'src' (default is SET).
* OOR\_SET(obj, int\_value): Some containers want to store some information within the uninitialized objects (for example Open Addressing Hash Table). This method stores the integer value 'int\_value' into an uninitialized object 'obj'. It shall be able to differentiate between unitialized object and initialized object. The way to store this information is fully object dependent. In general, you use out-of-range value for detecting such values. The object remains uninitialized but sets to of out-of-range value (OOR). int\_value values of 0 or 1 shall at least be supported.
* OOR\_EQUAL(obj, int\_value): This method compares the object 'obj' (initialized or unitialized) to the out-of-range value (OOR) represenation associated to 'int\_value' and returns true if both objects are equal, false otherwise. See OOR\_SET.
* REVERSE(container) : Reverse the order of the items in the container.
* SEPARATOR() --> character: Return the character used to separate items for I/O methods (default is ',')
* EXT\_ALGO(name, container oplist, object oplist): Define additional algorithms functions specialized for the containers (for internal use only by m-algo).

More operators are expected.

Example:

        (INIT(mpz_init),SET(mpz_set),INIT_SET(mpz_init_set),CLEAR(mpz_clear))

If there is two operations with the same name in an oplist, the left one has the priority. This enables partial overriding.

Oplists can be registered globally by defining, for the type 'type', a macro named
M\_OPL\_ ## type () that expands to the oplist of the type.
Only type without space in their name can be registered. A typedef of the type
can be used instead through. This can simplify a lot OPLIST usage.

Example:

        #define M_OPL_mpz_t() M_CLASSIC_OPLIST(mpz)

Within an OPLIST, you can also specify the needed low-level transformation to perform for the method.
This is called API type.
Assuming that the method to call is called 'method' and the first argument of the operator is 'output',
then the following transformation are applied:

* API\_0: method(output, ...)  /* Default API */
* API\_1: method(oplist, output, ...) /* Give oplist to the method */
* API\_2: method(&output, ...) /* Pass by address the first argument (like with M\_IPTR) */
* API\_3: method(oplist, &output, ...) /* Pass by address the first argument (like with M\_IPTR) and give the oplist of the type */
* API\_4 : output = method(...) /* Pass by return value the first argument */
* API\_5:  output = method(oplist, ...) /* Pass by return value the first argument and give the oplist of the type*/
* API\_6 : method(&output, &...) /* Pass by address the two first arguments */
* API\_7:  method(oplist, &output, &...) /* Pass by address the two first argument and give the oplist of the type*/

Example:

        (INIT(API_0(mpz_init)), SET(API_0(mpz_set)), INIT_SET(API_0(mpz_init_set)), CLEAR(API_0(mpz_clear)))



### Which OPLIST to use?

My type is:

* a C boolean: M\_BOOL\_OPLIST (M\_DEFAULT\_OPLIST also works partially)
* a C integer or a C float: M\_DEFAULT\_OPLIST (it can also be ommited),
* a C enumerate: M\_ENUM\_OPLIST
* a pointer to something: M\_PTR\_OPLIST,
* a plain structure that can be init/copy/compare with memset/memcpy/memcmp: M\_POD\_OPLIST,
* a plain structure that is passed by reference using [1] and can be init,copy,compare with memset,memcpy,memcmp: M\_A1\_OPLIST,
* a type that offers name\_init, name\_init\_set, name\_set, name\_clear methods: M\_CLASSIC\_OPLIST,
* a const string (const char *): M\_CSTR\_OPLIST,
* a M\*LIB string\_t: STRING\_OPLIST,
* a M\*LIB container: the OPLIST of the used container,
* other things: you need to provide a custom OPLIST to your type.

Note: The precise exported methods of the oplists depend of the version
of the C language used. Typically, in C11 mode, the M\_DEFAULT\_OPLIST
exports all needed methods to handle generc input/output of int/floats
(using _Generic) whereas it is not possible in C99 mode.
This explains why JSON import/export is only available in C11 mode
(See below chapter).


Memory Allocation
-----------------

Memory Allocation functions can be globally set by overriding the following macros before using the definition _DEF macros:

* M\_MEMORY\_ALLOC (type): return a pointer to a new object of type 'type'.
* M\_MEMORY\_DEL (ptr): free the single object pointed by 'ptr'.
* M\_MEMORY\_REALLOC (type, ptr, number): return a pointer to an array of 'number' objects of type 'type', reusing the old array pointed by 'ptr'. 'ptr' can be NULL, in that case the array will be created.
* M\_MEMORY\_FREE (ptr): free the array of objects pointed by 'ptr'.

ALLOC & DEL operators are supposed to allocate fixed size single element object (no array).
Theses objects are not expected to grow.
REALLOC & FREE operators deal with allocated memory for growing objects.
Do not mix pointers between both: a pointer allocated by ALLOC (resp. REALLOC) is supposed
to be only freed by DEL (resp. FREE). There are separated 'free' operators to enable
specialization in the allocator (a good allocator can take this hint into account).

M\_MEMORY\_ALLOC and  M\_MEMORY\_REALLOC are supposed to return NULL in case of memory allocation failure.
The defaults are 'malloc', 'free', 'realloc' and 'free'.

You can also override the methods NEW, DEL, REALLOC & DEL in the oplist given to a container
so that only the container will use these memory allocation functions.


Out-of-memory error
-------------------

When a memory exhaustion is reached, the global macro "M\_MEMORY\_FULL" is called
and the function returns immediately after.
The object remains in a valid (if previously valid) and unchanged state in this case.

By default, the macro prints an error message and aborts the program:
handling non-trivial memory errors can be hard,
testing them is even harder but still mandatory to avoid security holes.
So the default behavior shall be rather conservative.

Moreover a good program design should handle a process entire failure (using for examples multiple
processes for doing the job) so even if a process stops, it shall be recovered.
See [here](http://joeduffyblog.com/2016/02/07/the-error-model/) for more
information about why abandonment is good software practice.

It can however be overloaded to handle other policy for error handling like:

* throwing an error (in that case, the user is responsible to free memory of the allocated objects - destructor can still be called),
* set a global error and handle it when the function returns,
* other policy.

This function takes the size in bytes of the memory that has been tried to be allocated.

If needed, this macro shall be defined ***prior*** to instantiate the structure.

NOTE: Throwing an error is not fully supported yet. Some help from the library
is needed to avoid losing memory. See issue #15.


ERRORS & COMPILERS
------------------

M\*LIB implements internally some controls to reduce the list of errors/warnings generated by a compiler
when it detects some violation in the use of oplist by use of static assertion.
It can also transform some type warnings into proper errors.
In C99 mode, it will produce illegal code with the name of the error as attribute.
In C11 mode, it will use static assert and produce a detailled error message.

The list of errors it can generate:

* M\_LIB\_NOT\_AN\_OPLIST: something has been given (directly or indirectly) and it doesn't reduce as a proper oplist. You need to give an oplist for this definition.
* M\_LIB\_ERROR(ARGUMENT\_OF\_\*\_OPLIST\_IS\_NOT\_AN\_OPLIST, name, oplist): sub error of the previous error one, identying the root cause. The error is in the oplist construction of the given macro. You need to give an oplist for this oplist construction.
* M\_LIB\_MISSING\_METHOD: a required operator doesn't define any method in the given oplist. You need to complete the oplist with the missing method.
* M\_LIB\_TYPE\_MISTMACH: the given oplist and the type do not match each other. You need to give the right oplist for this type.
* M\_LIB\_NOT\_A\_DEFAULT\_TYPE: The oplist M\_DEFAULT\_OPLIST (directly or indireclty) has been used with the given type, but the given type is not a default type. You need to give the right oplist for this type.

You should focus mainly on the first reported error/warning
even if the link between what the compiler report and what the error is
is not immediate. The error is always in one of the **oplist definition**.
Examples of typical errors:

* lack of inclusion of an header,
* overriding locally operator names by macros (like NEW, DEL, INIT, OPLIST, ...),
* lack of ( ) or double level of ( ) around the oplist,
* an unknown variable (example using DEFAULT\_OPLIST instead of M\_DEFAULT\_OPLIST or M\_STRING\_OPLIST instead of STRING\_OPLIST),
* the name given to the oplist is not the same as the one used to define the methods,
* use of a type instead of an oplist in the OPLIST definition,
* a missing sub oplist in the OPLIST definition.

A good way to avoid theses errors is to register the oplist globally as soon
as you define the container.

In case of difficulties, debugging can be done by generating the preprocessed file
(by usually calling the compiler with the '-E' option instead of '-c')
and check what's wrong in the preprocessed file:

          cc -std=c99 -E test-file.c > test-file.i
          perl -pi -e 's/;/;\n/g' test-file.i
          cc -std=c99 -c -Wall test-file.i

If there is a warning reported by the compiler in the generated code,
then there is definitely an **error** you should fix (except if it reports
shadowed variables).



Benchmarks
----------

All bench codes are available in the bench directory.
The results are available [in a separate page](https://github.com/P-p-H-d/mlib/wiki/performance).


External Reference
------------------

Many other implementation of generic container libraries in C exist.
For example:

* [BKTHOMPS/CONTAINERS](https://github.com/bkthomps/Containers)
* [BSD tree.h](http://fxr.watson.org/fxr/source/sys/tree.h)
* [CDSA](https://github.com/MichaelJWelsh/cdsa)
* [CELLO](http://libcello.org/)
* [C-Macro-Collections](https://github.com/LeoVen/C-Macro-Collections)
* [COLLECTIONS-C](https://github.com/srdja/Collections-C)
* [CONCURRENCY KIT](https://github.com/concurrencykit/ck)
* [CTEMPLATES](https://github.com/farhiongit/Ctemplates)
* [GDB internal library](https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob;f=gdb/common/vec.h;h=41e41b5b22c9f5ec14711aac35ce4ae6bceab1e7;hb=HEAD)
* [GENCCONT: Generic C Containers](https://github.com/pmj/genccont)
* [Generic-Container-Lib](https://github.com/Siapran/Generic-Container-Lib)
* [GLIB](https://wiki.gnome.org/Projects/GLib)
* [KLIB](https://github.com/attractivechaos/klib)
* [LIBCHASTE](https://github.com/mgrosvenor/libchaste)
* [LIBCOLLECTION](https://bitbucket.org/manvscode/libcollections)
* [LIBCONTAINER](http://www.agottem.com/libcontainer)
* [LIBDICT](https://github.com/fmela/libdict)
* [LIBDYNAMIC](https://github.com/fredrikwidlund/libdynamic)
* [LIBLFDS](http://www.liblfds.org/)
* [LIBGENERICS](https://github.com/yudi-matsuzake/libgenerics)
* [LIBNIH](https://github.com/keybuk/libnih)
* [LIBSRT:  Safe Real-Time library for the C programming language](https://github.com/faragon/libsrt)
* [NEDTRIES](https://github.com/ned14/nedtries)
* [OKLIB](https://github.com/brackeen/ok-lib)
* [Open General C Container Collections ](https://github.com/kevin-dong-nai-jia/OpenGC3)
* [QLIBC](http://wolkykim.github.io/qlibc/)
* [RayLanguage](https://github.com/kojiba/RayLanguage)
* [Red-black tree implementation](http://www.canonware.com/rb/)
* [SGLIB](http://sglib.sourceforge.net/)
* [Smart pointer for GNUC](https://github.com/Snaipe/libcsptr)
* [STB stretchy_buffer](https://github.com/nothings/stb)
* [TommyDS](https://github.com/amadvance/tommyds)
* [UTHASH](http://troydhanson.github.io/uthash/index.html)

Each can be classified into one of the following concept:

* Each object is handled through a pointer to void (with potential registered callbacks to handle the contained objects for the specialized methods). From a user point of view, this makes the code harder to use (as you don't have any help from the compiler) and type unsafe with a lot of cast (so no formal proof of the code is possible). This also generally generate slower code (even if using link time optimization, this penalty can be reduced). Properly used, it can yet be the most space efficient for the code, but can consume a lot more for the data due to the obligation of using pointers. This is however the easiest to design & code.
* Macros are used to access structures in a generic way (using known fields of a structure - typically size, number, etc.). From a user point of view, this can create subtitle bug in the use of the library (as everything is done through macro expansion in the user defined code) or hard to understand warnings. This can generates fully efficient code. From a library developer point of view, this can be quite limiting in what you can offer.
* A known structure is put in an intrusive way in the type of all the objects you wan to handle. From a user point of view, he needs to modify its structure and has to perform all the allocation & deallocation code itself (which is good or bad depending on the context). This can generate efficient code (both in speed and size). From a library developer point of view, this is easy to design & code. You need internally a cast to go from a pointer to the known structure to the pointed object (a reverse of offsetof) that is generally type unsafe (except if mixed with the macro generating concept). This is quite limitation in what you can do: you can't move your objects so any container that has to move some objects is out-of-question (which means that you cannot use the most efficient container).
* Header files are included multiple times with different contexts (some different values given to defined macros) in order to generate different code for each type. From a user point of view, this creates a new step before using the container: an instantiating stage that has to be done once per type and per compilation unit (The user is responsible to create only one instance of the container, which can be troublesome if the library doesn't handle proper prefix for its naming convention). The debug of the library is generally easy and can generate fully specialized & efficient code. Incorrectly used, this can generate a lot of code bloat. Properly used, this can even create smaller code than the void pointer variant. The interface used to configure the library can be quite tiresome in case of a lot of specialized methods to configure: it doesn't enable to chain the configuration from a container to another one easily. It also cannot have heavy customization of the code.
* Macros are used to generate context-dependent C code enabling to generate code for different type. This is pretty much like the headers solution but with added flexibility. From a user point of view, this creates a new step before using the container: an instantiating stage that has to be done once per type and per compilation unit (The user is responsible to create only one instance of the container, which can be troublesome if the library doesn't handle proper prefix for its naming convention). This can generate fully specialized & efficient code. Incorrectly used, this can generate a lot of code bloat. Properly used, this can even create smaller code than the void pointer variant. From a library developer point of view, the library is harder to design and to debug: everything being expanded in one line, you can't step in the library (there is however a solution to overcome this limitation by adding another stage to the compilation process). You can however see the generated code by looking at the preprocessed file. You can perform heavy context-dependent customization of the code (transforming the macro preprocessing step into its own language). Properly done, you can also chain the methods from a container to another one easily, enabling expansion of the library. Errors within the macro expansion are generally hard to decipher, but errors in code using containers are easy to read and natural.

M\*LIB's category is mainly the last one.
Some macros are also defined to access structure in a generic way, but they are optional.
There are also intrusive containers.

M\*LIB main added value compared to other libraries is its oplist feature
enabling it to chain the containers and/or use complex types in containers:
list of array of dictionary of C++ objects are perfectly supported by M\*LIB.

For the macro-preprocessing part, other libraries also exist. For example:

* [P99](http://p99.gforge.inria.fr/p99-html/)
* [C99 Lambda](https://github.com/Leushenko/C99-Lambda)
* [MAP MACRO](https://github.com/swansontec/map-macro)
* [C Preprocessor Tricks, Tips and Idioms](https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms)
* [CPP MAGIC](http://jhnet.co.uk/articles/cpp_magic)
* [Zlang](https://github.com/pfultz2/ZLang)
* [Boost preprocessor](http://www.boost.org/doc/libs/1_63_0/libs/preprocessor/doc/index.html)

For the string library, there is for example:

* [The Better String Library](http://bstring.sourceforge.net/) with a page that lists a lot of other string libraries.
* [VSTR](http://www.and.org/vstr/) with a [page](http://www.and.org/vstr/comparison) that lists a lot of other string libraries.
* [SDS](https://github.com/antirez/sds)
* [RAPIDSTRING](https://github.com/boyerjohn/rapidstring)



API Documentation
-----------------

The M*LIB reference card is available [here](http://htmlpreview.github.io/?https://github.com/P-p-H-d/mlib/blob/master/doc/Container.html).


### M-LIST

This header is for creating [singly linked list](https://en.wikipedia.org/wiki/Linked_list).

A linked list is a linear collection of elements,
in which each element points to the next, all representing a sequence.

#### LIST\_DEF(name, type, [, oplist])

Define the singly linked list named 'name##\_t' that contains objects of type 'type' and the associated methods as "static inline" functions.
'name' shall be a C identifier that will be used to identify the list. It will be used to create all the types and functions to handle the container.
This definition shall be done once per name and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

A fundamental property of a list is that the objects created within the list
will remain at their initialized address, and won't moved due to
operations done on the list (except if it is removed).

The type oplist is expected to have at least the following operators (INIT\_SET, SET and CLEAR).
If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used if there is one available.
The created methods use the operators to init, set and clear the contained object.

For this structure, the back is always the first element,
and the front is the last element: the list grows from the back.

Example:

	LIST_DEF(list_uint, unsigned int)

	list_uint_t list_of_integer;

	void fi(unsigned int z) {
		list_uint_push_back (list_of_integer, z);
	}
        
	LIST_DEF(list_mpz, mpz_t,                                               \
		(INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), CLEAR(mpz_clear)))

	list_mpz_t my_list;

	void fz(mpz_t z) {
		list_mpz_push_back (my_list, z);
	}

If the given oplist contain the method MEMPOOL, then LIST\_DEF macro will create
a dedicated mempool that is named with the given value of the method MEMPOOL.
This mempool (see mempool chapter) is optimized for this kind of list:

* it creates a mempool named by the concatenation of "name" and "\_mempool",
* it creates a variable named by the value of the method MEMPOOL with the linkage
defined by the value of the method MEMPOOL\_LINKAGE (can be extern, static or none).
This variable is shared by all lists of the same type.
* it links the memory allocation of the list to use this mempool with this variable.

mempool create heavily efficient list. However it is only worth the
effort in some heavy performance context.
The created mempool has to be explicitly initialized before using any
methods of the created list by calling  mempool\_list\_name\_init(variable)
and cleared by calling mempool\_list\_name\_clear(variable).

Example:

        LIST_DEF(list_uint, unsigned int, (MEMPOOL(list_mpool), MEMPOOL_LINKAGE(static)))

        static void test_list (size_t n)
        {
          list_uint_mempool_init(list_mpool);
          M_LET(a1, LIST_OPLIST(uint)) {
              for(size_t i = 0; i < n; i++)
                  list_uint_push_back(a1, rand_get() );
          }
          list_uint_mempool_clear(list_mpool);
        }


#### LIST\_OPLIST(name [, oplist])

Return the oplist of the list defined by calling LIST\_DEF
& LIST\_DUAL\_PUSH\_DEF with name & oplist. 
If there is no given oplist, the default oplist for standard C type is used.

#### Created methods

In the following methods, name stands for the name given to the macro that is used to identify the type.
The following types are automatically defined by the previous definition macro:

#### name\_t

Type of the list of 'type'.

#### name\_it\_t

Type of an iterator over this list.

The following methods are automatically created by the previous definition macro:

##### void name\_init(name\_t list)

Initialize the list 'list' (aka constructor) to an empty list.

##### void name\_init\_set(name\_t list, const name\_t ref)

Initialize the list 'list' (aka constructor) and set it to a copy of 'ref'.

##### void name\_set(name\_t list, const name\_t ref)

Set the list 'list' to the a copy of 'ref'.

##### void name\_init\_move(name\_t list, name\_t ref)

Initialize the list 'list' (aka constructor) by stealing as many resources
from 'ref' as possible.
After-wise 'ref' is cleared and can no longer be used.

##### void name\_move(name\_t list, name\_t ref)

Set the list 'list' (aka constructor) by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared and can no longer be used.

##### void name\_clear(name\_t list)

Clear the list 'list (aka destructor), calling the CLEAR method of all the
objects of the list and freeing memory.
The list can't be used anymore, except with a constructor.

##### void name\_clean(name\_t list)

Clean the list (the list becomes empty).
It is like CLEAR but the list remains initialized and empty.

##### const type *name\_back(const name\_t list)

Return a constant pointer to the data stored in the back of the list.

##### void name\_push\_back(name\_t list, const type value)

Push a new element within the list 'list' with the value 'value' contained within.

##### type *name\_push\_raw(name\_t list)

Push a new element within the list 'list' without initializing it and returns a pointer to the **non-initialized** data.
The first thing to do after calling this function is to initialize the data
using the proper constructor. This enables using more specialized
constructor than the generic one.
Return a pointer to the **non-initialized** data.

##### type *name\_push\_new(name\_t list)

Push a new element within the list 'list' and initialize it with the default constructor of the type.
Return a pointer to the initialized object.
This method is only defined if the type of the element defines an INIT method.

##### void name\_push\_move(name\_t list, type *value)

Push a new element within the list 'list' with the value '*value' contained within
by stealing as much resources from *value than possible. Afterward *value is
cleared and cannot longer be used.

##### void name\_pop\_back(type *data, name\_t list)

Pop a element from the list 'list', and set *data to this value
if data is not the NULL pointer (otherwise only pop the data).

##### void name\_pop\_move(type *data, name\_t list)

Pop a element from the list 'list', and initialize and set *data to this value
by stealing as much resources from the list as possible.
data cannot be a NULL pointer.

##### bool name\_empty\_p(const name\_t list)

Return true if the list is empty, false otherwise.

##### void name\_swap(name\_t list1, name\_t list2)

Swap the list 'list1' and 'list2'.

##### void name\_it(name\_it\_t it, const name\_t list)

Set the iterator 'it' to the back(=first) element of 'list'.
There is no destructor associated to this initialization.

##### void name\_it\_set(name\_it\_t it, const name\_it\_t ref)

Set the iterator 'it' to the iterator 'ref'.
There is no destructor associated to this initialization.

##### void name\_it\_end(name\_it\_t it, const name\_t list)

Set the iterator 'it' to a non valid element of the list.
There is no destructor associated to this initialization.

##### bool name\_end\_p(const name\_it\_t it)

Return true if the iterator doesn't reference a valid element anymore.

##### bool name\_last\_p(const name\_it\_t it)

Return true if the iterator references the top(=last) element
or if the iterator doesn't reference a valid element anymore.

##### bool name\_it\_equal\_p(const name\_it\_t it1, const name\_it\_t it2)

Return true if the iterator it1 references the same element than it2.

##### void name\_next(name\_it\_t it)

Move the iterator 'it' to the next element of the list,
i.e. from the back (=first) element to the front (=last) element.

##### type *name\_ref(name\_it\_t it)

Return a pointer to the element pointed by the iterator.
This pointer remains valid until the element is destroyed in the list.

##### const type *name\_cref(const name\_it\_t it)

Return a constant pointer to the element pointed by the iterator.
This pointer remains valid until the element is destroyed in the list.

##### type *name\_get(const name\_t list, size\_t i)

Return a pointer to the element i-th of the list (from 0). 
It is assumed than i is within the size of the list.
This function is slow and iterates linearly over the element of the elements
until it reaches the desired element.

##### const type *name\_cget(const name\_t list, size\_t i)

Return a constant pointer to the element i-th of the list (from 0). 
It is assumed than i is within the size of the list.
This function is slow and iterates linearly over the element of the elements
until it reaches the desired element.

##### size\_t name\_size(const name\_t list)

Return the number elements of the list (aka size). Return 0 if there no element.
This function is slow and iterates linearly over all the element
to compute the size.

##### void name\_insert(name\_t list, const name\_it\_t it, const type x)

Insert 'x' after the position pointed by 'it' (which is an iterator of the list 'list') or if 'it' doesn't point anymore to a valid element of the list, it is added as the back (=first) element of the 'list'

##### void name\_remove(name\_t list, name\_it\_t it)

Remove the element 'it' from the list 'list'.
After wise, 'it' points to the next element of the list.

##### void name\_splice\_back(name\_t list1, name\_t list2, name\_it\_t it)

Move the element pointed by 'it' (which is an iterator of 'list2') from the list 'list2' to the back position of 'list1'.
After wise, 'it' points to the next element of 'list2'.

##### void name\_splice\_at(name\_t list1, name\_it\_t it1, name\_t list2, name\_it\_t it2)

Move the element pointed by 'it2' (which is an iterator of 'list2') from the list 'list2' to the position just after 'it1' in the list 'list1'.
After wise, 'it2' points to the next element of 'list2'
and 'it1' points to the inserted element in 'list1'.
If 'it1' is the end position, it inserts it at the back (just like \_insert\_at).

##### void name\_splice(name\_t list1, name\_t list2)

Move all the element of 'list2' into 'list1", moving the last element
of 'list2' after the first element of 'list1'.
After-wise, 'list2' remains initialized but is emptied.

##### void name\_reverse(name\_t list)

Reverse the order of the list.

##### void name\_get\_str(string\_t str, const name\_t list, bool append)

Generate a string representation of the list 'list' and set 'str' to this representation
(if 'append' is false) or append 'str' with this representation (if 'append' is true).
This method is only defined if the type of the element defines a GET\_STR method itself.

##### bool name\_parse\_str(name\_t list, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a list
and set 'list' to this representation.
This method is only defined if the type of the element defines a PARSE\_STR & INIT methods itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void name\_out\_str(FILE *file, const name\_t list)

Generate a string representation of the list 'list' and outputs it into the FILE 'file'.
This method is only defined if the type of the element defines a OUT\_STR method itself.

##### void name\_in\_str(name\_t list, FILE *file)

Read from the file 'file' a string representation of a list and set 'list' to this representation.
This method is only defined if the type of the element defines a IN\_STR & INIT method itself.

##### bool name\_equal\_p(const name\_t list1, const name\_t list2)

Return true if both lists 'list1' and 'list2' are equal.
This method is only defined if the type of the element defines a EQUAL method itself.

##### size\_t name\_hash(const name\_t list)

Return a hash value of 'list'.
This method is only defined if the type of the element defines a HASH method itself.



#### LIST\_DUAL\_PUSH\_DEF(name, type[, oplist])

Define the singly linked list named 'name##\_t' that contains the objects 
of type 'type' and the associated methods as "static inline" functions.
'name' shall be a C identifier that will be used to identify the list. 
It will be used to create all the types and functions to handle the container.
It shall be done once per type and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions too.

The only difference with the list defined by LIST\_DEF is
the support of the method PUSH\_FRONT in addition to PUSH\_BACK 
(therefore the DUAL PUSH name).
There is still only POP method (POP\_BACK). The head of the list is a bit
bigger to be able to handle such methods to work.
This enables this list to be able to represent both stack (PUSH\_BACK + POP\_BACK)
and queue (PUSH\_FRONT + POP\_BACK).

A fundamental property of a list is that the objects created within the list
will remain at their initialized address, and won't moved due to
operations on the list.

The object oplist is expected to have at least the following operators (INIT\_SET, SET and CLEAR).
If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

For this structure, the back is always the first element, and the front is the last element.

Example:

	LIST_DUAL\_PUSH\_DEF(list_mpz, mpz_t,                                   \
		(INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), CLEAR(mpz_clear)))

	list_mpz_t my_list;

	void f(mpz_t z) {
		list_mpz_push_front (my_list, z);
		list_mpz_pop_back (z, my_list);
	}

If the given oplist contain the method MEMPOOL, then macro will create a dedicated mempool
that is named with the given value of the method MEMPOOL, optimized for this kind of list:

* it creates a mempool named by the concatenation of "name" and "\_mempool",
* it creates a variable named by the value of the method MEMPOOL with linkage defined
by the value of the method MEMPOOL\_LINKAGE (can be extern, static or none),
this variable will be shared by all lists of the same type.
* it overwrites memory allocation of the created list to use this mempool with this variable.

mempool creates heavily efficient list but it will be only worth the effort in some
heavy performance context. The created mempool has to be initialized before using any
methods of the created list by calling  mempool\_list\_name\_init(variable)
and cleared by calling mempool\_list\_name\_clear(variable).

The methods follow closely the methods defined by LIST\_DEF.

#### Created methods

In the following methods, name stands for the name given to the macro that is used to identify the type.
The following types are automatically defined by the previous macro:

#### name\_t

Type of the list of 'type'.

#### name\_it\_t

Type of an iterator over this list.

The following methods are automatically and properly created by the previous macro.

##### void name\_init(name\_t list)

Initialize the list 'list' (aka constructor) to an empty list.

##### void name\_init\_set(name\_t list, const name\_t ref)

Initialize the list 'list' (aka constructor) and set it to the value of 'ref'.

##### void name\_set(name\_t list, const name\_t ref)

Set the list 'list' to the value of 'ref'.

##### void name\_init\_move(name\_t list, name\_t ref)

Initialize the list 'list' (aka constructor) by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared and can no longer be used.

##### void name\_move(name\_t list, name\_t ref)

Set the list 'list' (aka constructor) by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared and can no longer be used.

##### void name\_clear(name\_t list)

Clear the list 'list (aka destructor). The list can't be used anymore, except with a constructor.

##### void name\_clean(name\_t list)

Clean the list (the list becomes empty). The list remains initialized but is empty.

##### const type *name\_back(const name\_t list)

Return a constant pointer to the data stored in the back of the list.

##### void name\_push\_back(name\_t list, type value)

Push a new element within the list 'list' with the value 'value'
into the back of the list.

##### type *name\_push\_back\_raw(name\_t list)

Push a new element within the list 'list' without initializing it 
into the back of the list
and returns a pointer to the **non-initialized** data.
The first thing to do after calling this function is to initialize the data using
the proper constructor. This enables to use a more specialized
constructor than the generic one.
Return a pointer to the **non-initialized** data.

##### type *name\_push\_back\_new(name\_t list)

Push a new element within the list 'list' 
into the back of the list
and initialize it with the default constructor of the type.
Return a pointer to the initialized object.
This method is only defined if the type of the element defines an INIT method.

##### void name\_push\_back\_move(name\_t list, type *value)

Push a new element within the list 'list' with the value '*value'
,by stealing as much resources from '*value' as possible,
into the back of the list.
Afterwards, *value is cleared and cannot be used anymore.
value cannot be NULL.

##### const type *name\_front(const name\_t list)

Return a constant pointer to the data stored in the front of the list.

##### void name\_push\_front(name\_t list, type value)

Push a new element within the list 'list' with the value 'value' contained within
into the front of the list.

##### type *name\_push\_front\_raw(name\_t list)

Push a new element within the list 'list' without initializing it 
into the front of the list
and returns a pointer to the **non-initialized** data.
The first thing to do after calling this function is to initialize the data using
the proper constructor. This enables to use a more specialized
constructor than the generic one.
Return a pointer to the **non-initialized** data.

##### type *name\_push\_front\_new(name\_t list)

Push a new element within the list 'list' 
into the front of the list
and initialize it with the default constructor of the type.
Return a pointer to the initialized object.
This method is only defined if the type of the element defines an INIT method.

##### void name\_push\_front\_move(name\_t list, type *value)

Push a new element within the list 'list' with the value '*value'
,by stealing as much resources from '*value' as possible,
into the front of the list.
Afterwards, *value is cleared and cannot be used anymore.
value cannot be NULL.

##### void name\_pop\_back(type *data, name\_t list)

Pop a element from the list 'list' and set *data to this value
if data is not NULL. 

##### void name\_pop\_move(type *data, name\_t list)

Pop a element from the list 'list' and initialize and set *data to this value,
stealing as much resources from the list as possible.

##### bool name\_empty\_p(const name\_t list)

Return true if the list is empty, false otherwise.

##### void name\_swap(name\_t list1, name\_t list2)

Swap the list 'list1' and 'list2'.

##### void name\_it(name\_it\_t it, name\_t list)

Set the iterator 'it' to the back(=first) element of 'list'.
There is no destructor associated to this initialization.

##### void name\_it\_set(name\_it\_t it, const name\_it\_t ref)

Set the iterator 'it' to the iterator 'ref'.
There is no destructor associated to this initialization.

##### void name\_it\_end(name\_it\_t it, const name\_t list)

Set the iterator 'it' to an invalid reference of 'list'.
There is no destructor associated to this initialization.

##### bool name\_end\_p(const name\_it\_t it)

Return true if the iterator doesn't reference a valid element anymore.

##### bool name\_last\_p(const name\_it\_t it)

Return true if the iterator references the top(=last) element or if the iterator doesn't reference a valid element anymore.

##### bool name\_it\_equal\_p(const name\_it\_t it1, const name\_it\_t it2)

Return true if the iterator it1 references the same element than it2.

##### void name\_next(name\_it\_t it)

Move the iterator 'it' to the next element of the list, ie. from the back (=first) element to the front(=last) element.

##### type *name\_ref(name\_it\_t it)

Return a pointer to the element pointed by the iterator.
This pointer remains valid until the object is destroyed.

##### const type *name\_cref(const name\_it\_t it)

Return a constant pointer to the element pointed by the iterator.
This pointer remains valid until the object is destroyed.

##### size\_t name\_size(const name\_t list)

Compute and return the number elements of the list (aka size).
Return 0 if there no element.

##### void name\_insert(name\_t list, const name\_it\_t it, const type x)

Insert 'x' after the position pointed by 'it' (which is an iterator of the list 'list') or if 'it' doesn't point anymore to a valid element of the list, it is added as the back (=first) element of the 'list'

##### void name\_remove(name\_t list, name\_it\_t it)

Remove the element 'it' from the list 'list'.
After wise, 'it' points to the next element of the list.

##### void name\_splice\_back(name\_t list1, name\_t list2, name\_it\_t it)

Move the element pointed by 'it' (which is an iterator of 'list2') from the list 'list2' to the back position of 'list1'.
After wise, 'it' points to the next element of 'list2'.

##### void name\_splice(name\_t list1, name\_t list2)

Move all the element of 'list2' into 'list1", moving the last element
of 'list2' after the first element of 'list1'.
After-wise, 'list2' is emptied.

##### void name\_reverse(name\_t list)

Reverse the order of the list.

##### void name\_get\_str(string\_t str, const name\_t list, bool append)

Generate a string representation of the list 'list' and set 'str' to this representation
(if 'append' is false) or append 'str' with this representation (if 'append' is true).
This method is only defined if the type of the element defines a GET\_STR method itself.

##### bool name\_parse\_str(name\_t list, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a list
and set 'list' to this representation.
This method is only defined if the type of the element defines PARSE\_STR & INIT methods itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void name\_out\_str(FILE *file, const name\_t list)

Generate a string representation of the list 'list' and outputs it into the FILE 'file'.
This method is only defined if the type of the element defines a OUT\_STR method itself.

##### void name\_in\_str(name\_t list, FILE *file)

Read from the file 'file' a string representation of a list and set 'list' to this representation.
This method is only defined if the type of the element defines a IN\_STR & INIT method itself.

##### bool name\_equal\_p(const name\_t list1, const name\_t list2)

Return true if both lists 'list1' and 'list2' are equal.
This method is only defined if the type of the element defines a EQUAL method itself.

##### size\_t name\_hash(const name\_t list)

Return a hash value of 'list'.
This method is only defined if the type of the element defines a HASH method itself.



### M-ARRAY

An [array](https://en.wikipedia.org/wiki/Array_data_structure) is a growable collection of element that are individually indexable.

#### ARRAY\_DEF(name, type [, oplist])

Define the array 'name##\_t' that contains the objects of type 'type' and its associated methods as "static inline" functions.
Compared to C arrays, the created methods handle automatically the size (aka growable array).
'name' shall be a C identifier that will be used to identify the container.

It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

The object oplist is expected to have at least the following operators (CLEAR),
and usually (INIT, INIT\_SET, SET and CLEAR)
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init-and-set, set and clear the contained object.

Example:

	ARRAY_DEF(array_mpfr_t, mpfr,                                                                  \
	   (INIT(mpfr_init), INIT_SET(mpfr_init_set), SET(mpfr_set), CLEAR(mpfr_clear)))

	array_mpfr_t my_array;

	void f(mpfr_t z) {
		array_mpfr_push_back (my_array, z);
	}


#### ARRAY\_OPLIST(name [, oplist])

Return the oplist of the array defined by calling ARRAY\_DEF with name & oplist. 
If there is no given oplist, the default oplist for standard C type is used.

#### Created methods

In the following methods, name stands for the name given to the macro.
This is used to identify the type.
The following types are automatically defined by the previous macro:

#### name\_t

Type of the array of 'type'.

#### name\_it\_t

Type of an iterator over this array.

The following methods are automatically and properly created by the previous macros:

##### void name\_init(name\_t array)

Initialize the array 'array' (aka constructor) to an empty array.

##### void name\_init\_set(name\_t array, const name\_t ref)

Initialize the array 'array' (aka constructor) and set it to the value of 'ref'.
This method is created if the INIT_SET & SET operators are provided.

##### void name\_set(name\_t array, const name\_t ref)

Set the array 'array' to the value of 'ref'.
This method is created if the INIT_SET & SET operators are provided.

##### void name\_init\_move(name\_t array, name\_t ref)

Initialize the array 'array' (aka constructor) by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared.

##### void name\_move(name\_t array, name\_t ref)

Set the array 'array' by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared.

##### void name\_clear(name\_t array)

Clear the array 'array (aka destructor).

##### void name\_clean(name\_t array)

Clean the array (the array becomes empty but remains initialized).

##### type *name\_push\_raw(name\_t array)

Push the needed storage of a new element into the back of the array 'array'
without initializing it and return
a pointer to the non-initialized data.
The first thing to do after calling this function is to initialize the data
using the proper constructor. This enables to use a more specialized
constructor than the generic one.
It is recommended to use other _push function if possible rather than this one
as it is low level and error prone.

##### void name\_push\_back(name\_t array, const type value)

Push a new element into the back of the array 'array' with the value 'value' contained within.
This method is created if the INIT_SET operator is provided.

##### type *name\_push\_new(name\_t array)

Push a new element into the back of the array 'array' and initialize it with the default constructor.
Return a pointer to this created element.
This method is only defined if the type of the element defines an INIT method.

##### void name\_push\_move(name\_t array, type *val)

Push '*val' a new element into the back of the array 'array'
by stealing as much resources as possible from '*val'.
After-wise '*x' is cleared.
This method is created if the INIT\_SET or INIT\_MOVE operator is provided.

##### void name\_push\_at(name\_t array, size\_t key, const type x)

Push a new element into the position 'key' of the array 'array' with the value 'value' contained within.
'key' shall be a valid position of the array: from 0 to the size of array (included).
This method is created if the INIT_SET operator is provided.

##### void name\_pop\_back(type *data, name\_t array)

Pop a element from the back of the array 'array' and set *data to this value
if data is not NULL (if data is NULL, the popped data is cleared).
This method is created if the SET or INIT\_MOVE operator is provided.

##### void name\_pop\_move(type *data, name\_t array)

Pop a element from the back of the array 'array' and initialize
*data with this value by stealing as much from the array as possible.
This method is created if the INIT\_SET or INIT\_MOVE operator is provided.

##### void name\_pop\_until(name\_t array, array\_it\_t position)

Pop all elements of the array 'array' from 'position' to the back of the array,
clearing them.
This method is only defined if the type of the element defines an INIT method.

##### void name\_pop\_at(type *dest, name\_t array, size\_t key)

Set *dest to the value the element 'key' if dest is not NULL,
then remove the element 'key' from the array.
'key' shall be within the size of the array.
This method is created if the SET or INIT\_MOVE operator is provided.

##### const type *name\_front(const name\_t array)

Return a constant pointer to the first element of the array.

##### const type *name\_back(const name\_t array)

Return a constant pointer to the last element of the array.

##### void name\_set\_at(name\_t array, size\_t i, type value)

Set the element 'i' of array 'array' to 'value'.
'i' shall be within 0 to the size of the array (excluded).
This method is created if the INIT\_SET operator is provided.

##### type *name\_get(name\_t array, size\_t i)

Return a pointer to the element 'i' of the array.
'i' shall be within 0 to the size of the array (excluded).
The returned pointer cannot be NULL.
This pointer remains valid until the array is modified by another method.

##### const type *name\_cget(const name\_t it, size\_t i)

Return a constant pointer to the element 'i' of the array.
'i' shall be within 0 to the size of the array (excluded).
The returned pointer cannot be NULL.
This pointer remains valid until the array is modified by another method.

##### type *name\_get\_at(name\_t array, size\_t i)

Return a pointer to the element 'i' of array 'array',
by increasing the size of the array if needed (creating new elements with INIT).
The returned pointer cannot be NULL.
This method is only defined if the type of the element defines an INIT method.
This pointer remains valid until the array is modified by another method.

##### bool name\_empty\_p(const name\_t array)

Return true if the array is empty, false otherwise.

##### size\_t name\_size(const name\_t array)

Return the size of the array.

##### size\_t name\_capacity(const name\_t array)

Return the capacity of the array.

##### void name\_resize(name\_t array, size\_t size)

Resize the array 'array' to the size 'size' (initializing or clearing elements).
This method is only defined if the type of the element defines an INIT method.

##### void name\_reserve(name\_t array, size\_t capacity)

Extend or reduce the capacity of the 'array' to a rounded value based on 'capacity'.
If the given capacity is below the current size of the array, the capacity is set to the size of the array.

##### void name\_remove(name\_t array, name\_it\_t it)

Remove the element pointed by the iterator 'it' from the array 'array'.
'it' shall be a valid iterator. Afterward 'it' points to the next element, or points to the end.
This method is created if the SET or INIT\_MOVE operator is provided.

##### void name\_remove\_v(name\_t array, size\_t i, size\_t j)

Remove the element 'i' (included) to the element 'j' (excluded)
from the array.
'i' and 'j' shall be within the size of the array, and i < j.

##### void name\_insert(name\_t array, name\_it\_t it, const type x)

Insert the object 'x' at the position 'it' of the array.
'it' shall be a valid iterator of the array.
This method is created if the INIT\_SET operator is provided.

##### void name\_insert\_v(name\_t array, size\_t i, size\_t j)

Insert from the element 'i' (included) to the element 'j' (excluded)
new empty elements to the array.
'i' and 'j' shall be within the size of the array, and i < j.
This method is only defined if the type of the element defines an INIT method.

##### void name\_swap(name\_t array1, name\_t array2)

Swap the array 'array1' and 'array2'.

##### void name\_swap\_at(name\_t array, size\_t i, size\_t j)

Swap the elements 'i' and 'j' of the array 'array'.
'i' and 'j' shall reference valid elements of the array.
This method is created if the INIT\_SET or INIT\_MOVE operator is provided.

##### void name\_it(name\_it\_t it, name\_t array)

Set the iterator 'it' to the first element of 'array'.

##### void name\_it\_last(name\_it\_t it, name\_t array)

Set the iterator 'it' to the last element of 'array'.

##### void name\_it\_end(name\_it\_t it, name\_t array)

Set the iterator 'it' to the end of 'array'.

##### void name\_it\_set(name\_it\_t it1, name\_it\_t it2)

Set the iterator 'it1' to 'it2'.

##### bool name\_end\_p(name\_it\_t it)

Return true if the iterator doesn't reference a valid element anymore.

##### bool name\_last\_p(name\_it\_t it)

Return true if the iterator references the last element of the array,
or doesn't reference a valid element.

##### bool name\_it\_equal\_p(const name\_it\_t it1, const name\_it\_t it2)

Return true if both iterators reference the same element.

##### void name\_next(name\_it\_t it)

Move the iterator 'it' to the next element of the array.

##### void name\_previous(name\_it\_t it)

Move the iterator 'it' to the previous element of the array.

##### type *name\_ref(name\_it\_t it)

Return a pointer to the element pointed by the iterator.
This pointer remains valid until the array is modified by another method.

##### const type *name\_cref(const name\_it\_t it)

Return a constant pointer to the element pointed by the iterator.
This pointer remains valid until the array is modified by another method.

##### void name\_special\_sort(name_t array)

Sort the array 'array'.
This method is defined if the type of the element defines CMP method.
This method uses the qsort function of the C library.

##### void name\_special\_stable\_sort(name_t array)

Sort the array 'array' using a stable sort.
This method is defined if the type of the element defines CMP and SWAP and SET methods.
This method provides an ad-hoc implementation of the stable sort.
In practice, it is faster than the \_sort method for small types and fast
comparisons.

##### void name\_get\_str(string\_t str, const name\_t array, bool append)

Generate a string representation of the array 'array' and set 'str' to this representation
(if 'append' is false) or append 'str' with this representation (if 'append' is true).
This method is only defined if the type of the element defines a GET\_STR method itself.

##### bool name\_parse\_str(name\_t array, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of an array
and set 'array' to this representation.
This method is only defined if the type of the element defines both PARSE\_STR & INIT methods itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void name\_out\_str(FILE *file, const name\_t array)

Generate a string representation of the array 'array' and outputs it into the FILE 'file'.
This method is only defined if the type of the element defines a OUT\_STR method itself.

##### void name\_in\_str(name\_t array, FILE *file)

Read from the file 'file' a string representation of an array and set 'array' to this representation.
This method is only defined if the type of the element defines both IN\_STR & INIT methods itself.

##### bool name\_equal\_p(const name\_t array1, const name\_t array2)

Return true if both arrays 'array1' and 'array2' are equal.
This method is only defined if the type of the element defines a EQUAL method itself.

##### size\_t name\_hash(const name\_t array)

Return an hash value of 'array'.
This method is only defined if the type of the element defines a HASH method itself.

##### void name\_splice(name\_t array1, name\_t array2)

Merge the elements of 'array2' in 'array1' at its end.
Afterwards, 'array2' is empty.


### M-DEQUE

This header is for creating [double-ended queue](https://en.wikipedia.org/wiki/Double-ended_queue) (or deque). 
A deque is an abstract data type that generalizes a queue, 
for that elements can be added to or removed from either the front (head) or back (tail)

#### DEQUE\_DEF(name, type, [, opdeque])

Define the deque 'name##\_t' that contains the objects of type 'type' and its associated methods as "static inline" functions.
'name' shall be a C identifier that will be used to identify the deque. It will be used to create all the types and functions to handle the container.
It shall be done once per type and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET and CLEAR),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

Example:

	DEQUE_DEF(deque_mpz, mpz_t,                                               \
		(INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), CLEAR(mpz_clear)))

	deque_mpz_t my_deque;

	void f(mpz_t z) {
		deque_mpz_push_back (my_deque, z);
	}


#### DEQUE\_OPLIST(name [, oplist])

Return the oplist of the deque defined by calling DEQUE\_DEF with name & oplist. 

#### Created methods

In the following methods, name stands for the name given to the macro that is used to identify the type.
The following types are automatically defined by the previous macro:

#### name\_t

Type of the deque of 'type'.

#### name\_it\_t

Type of an iterator over this deque.

The following methods are automatically and properly created by the previous macro.

##### void name\_init(name\_t deque)

Initialize the deque 'deque' (aka constructor) to an empty deque.

##### void name\_init\_set(name\_t deque, const name\_t ref)

Initialize the deque 'deque' (aka constructor) and set it to the value of 'ref'.

##### void name\_set(name\_t deque, const name\_t ref)

Set the deque 'deque' to the value of 'ref'.

##### void name\_init\_move(name\_t deque, name\_t ref)

Initialize the deque 'deque' (aka constructor) by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared and can no longer be used.

##### void name\_move(name\_t deque, name\_t ref)

Set the deque 'deque' (aka constructor) by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared and can no longer be used.

##### void name\_clear(name\_t deque)

Clear the deque 'deque (aka destructor). The deque can't be used anymore, except with a constructor.

##### void name\_clean(name\_t deque)

Clean the deque (the deque becomes empty). The deque remains initialized but is empty.

##### const type *name\_back(const name\_t deque)

Return a constant pointer to the data stored in the back of the deque.

##### void name\_push\_back(name\_t deque, type value)

Push a new element within the deque 'deque' with the value 'value' at the back of the deque.

##### type *name\_push\_back÷\_raw(name\_t deque)

Push at the back a new element within the deque 'deque' without initializing it and returns a pointer to the **non-initialized** data.
The first thing to do after calling this function is to initialize the data using the proper constructor. This enables to use a more specialized
constructor than the generic one.
Return a pointer to the **non-initialized** data.

##### type *name\_push\_back\_new(name\_t deque)

Push at the back a new element within the deque 'deque' and initialize it with the default constructor of the type.
Return a pointer to the initialized object.

##### void name\_pop\_back(type *data, name\_t deque)

Pop a element from the deque 'deque' and set *data to this value.
If data pointer is NULL, then the popped value is discarded.

##### const type *name\_front(const name\_t deque)

Return a constant pointer to the data stored in the front of the deque.

##### void name\_push\_front(name\_t deque, type value)

Push at the front a new element within the deque 'deque' with the value 'value'.

##### type *name\_push\_front\_raw(name\_t deque)

Push at the front a new element within the deque 'deque' without initializing it and returns a pointer to the **non-initialized** data.
The first thing to do after calling this function is to initialize the data using the proper constructor. This enables to use a more specialized
constructor than the generic one.
Return a pointer to the **non-initialized** data.

##### type *name\_push\_front\_new(name\_t deque)

Push at the front a new element within the deque 'deque' and initialize it with the default constructor of the type.
Return a pointer to the initialized object.

##### void name\_pop\_front(type *data, name\_t deque)

Pop a element from the deque 'deque' and set *data to this value.
If data pointer is NULL, then the pop-ed value is discarded.

##### bool name\_empty\_p(const name\_t deque)

Return true if the deque is empty, false otherwise.

##### void name\_swap(name\_t deque1, name\_t deque2)

Swap the deque 'deque1' and 'deque2'.

##### void name\_it(name\_it\_t it, name\_t deque)

Set the iterator 'it' to the first element of 'deque' (aka the front).
There is no destructor associated to this initialization.

##### void name\_it\_set(name\_it\_t it, const name\_it\_t ref)

Set the iterator 'it' to the iterator 'ref'.
There is no destructor associated to this initialization.

##### bool name\_end\_p(const name\_it\_t it)

Return true if the iterator doesn't reference a valid element anymore.

##### bool name\_last\_p(const name\_it\_t it)

Return true if the iterator references the last element or if the iterator doesn't reference a valid element anymore.

##### bool name\_it\_equal\_p(const name\_it\_t it1, const name\_it\_t it2)

Return true if the iterator it1 references the same element than it2.

##### void name\_next(name\_it\_t it)

Move the iterator 'it' to the next element of the deque, ie. from the front element to the back element.

##### void name\_previous(name\_it\_t it)

Move the iterator 'it' to the previous element of the deque, ie. from the back element to the front element.

##### type *name\_ref(name\_it\_t it)

Return a pointer to the element pointed by the iterator.
This pointer remains valid until the deque is modified by another method.

##### const type *name\_cref(const name\_it\_t it)

Return a constant pointer to the element pointed by the iterator.
This pointer remains valid until the deque is modified by another method.

##### type *name\_get(const name\_t deque, size\_t i)

Return a pointer to the element i-th of the deque (from 0). 
It is assumed than i is within the size of the deque.
The algorithm complexity is in O(ln(n))

##### const type *name\_cget(const name\_t deque, size\_t i)

Return a constant pointer to the element i-th of the deque (from 0). 
It is assumed than i is within the size of the deque.
The algorithm complexity is in O(ln(n))

##### size\_t name\_size(const name\_t deque)

Return the number elements of the deque (aka size). Return 0 if there no element.

##### void name\_get\_str(string\_t str, const name\_t deque, bool append)

Generate a string representation of the deque 'deque' and set 'str' to this representation
(if 'append' is false) or append 'str' with this representation (if 'append' is true).
This method is only defined if the type of the element defines a GET\_STR method itself.

##### bool name\_parse\_str(name\_t deque, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a deque
and set 'deque' to this representation.
This method is only defined if the type of the element defines PARSE\_STR & INIT methods itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void name\_out\_str(FILE *file, const name\_t deque)

Generate a string representation of the deque 'deque' and outputs it into the FILE 'file'.
This method is only defined if the type of the element defines a OUT\_STR method itself.

##### void name\_in\_str(name\_t deque, FILE *file)

Read from the file 'file' a string representation of a deque and set 'deque' to this representation.
This method is only defined if the type of the element defines a IN\_STR method itself.

##### bool name\_equal\_p(const name\_t deque1, const name\_t deque2)

Return true if both deque 'deque1' and 'deque2' are equal.
This method is only defined if the type of the element defines a EQUAL method itself.

##### size\_t name\_hash(const name\_t deque)

Return a hash value of 'deque'.
This method is only defined if the type of the element defines a HASH method itself.

##### void name\_swap\_at(name\_t deque, size\_t i, size\_t j)

Swap the values within the deque pointed by 'i' and by 'j'.
'i' & 'j' shall be valid index within the deque.
This method is only defined if the type of the element defines a SWAP method itself.





### M-DICT

A [dictionary](https://en.wikipedia.org/wiki/Associative_array) (or associative array, map, symbol table) is an abstract data type
composed of a collection of (key, value) pairs,
such that each possible key appears at most once in the collection.

Several dictionnaries are proposed. The "best" to use depends on the data type
and in particular:

* the size of the data,
* the inner cost of copying the object,
* the inner cost of computing the hash of the object,
* the inner cost of comparing the objects,
* the load factor.

For small, fast types (integer, or floats, or pair of such types),
DICT\_OA\_DEF2 may be the best to use.
For medium type, DICT\_DEF2 with mempool activated may be better.
For even larger object, DICT\_STOREHASH\_DEF2 may be better.


#### DICT\_DEF2(name, key\_type[, key\_oplist], value\_type[, value\_oplist])

Define the dictionary 'name##\_t' and its associated methods as "static inline" functions.
'name' shall be a C identifier that will be used to identify the container.
Current implementation uses chained Hash-Table and as such, elements in the dictionary are **unordered**.

It shall be done once per type and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET and CLEAR),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

The key_oplist shall also define the additional operators (HASH and EQUAL).

Example:

	DICT_DEF2(dict_str, string_t, STRING_OPLIST, string_t, STRING_OPLIST)
	dict_str_t my_dict;
	void f(string_t key, string_t value) {
		dict_str_set_at (my_dict, key, value);
	}


#### DICT\_STOREHASH\_DEF2(name, key\_type[, key\_oplist], value\_type[, value\_oplist])

Define the dictionary 'name##\_t' and its associated methods as "static inline" functions
just like DICT\_DEF2.

The only difference is that it stores the hash of each key alongside the key in the dictionary.
This enable the container to avoid recomputing it in some occasions resulting in faster
dictionary if the hash is costly to compute, or slower otherwise.


#### DICT\_OA\_DEF2(name, key\_type[, key\_oplist], value\_type[, value\_oplist])

Define the dictionary 'name##\_t' and its associated methods
as "static inline" functions much like DICT\_DEF2.
The difference is that it uses an Open Addressing Hash-Table as 
container.

It shall be done once per type and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET and CLEAR),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

The key_oplist shall also define the additional operators :
HASH and EQUAL and **OOR\_EQUAL** and **OOR\_SET**

This implementation is in general faster for small types of keys
(like integer) but slower for larger types.

Example:

	static inline bool oor_equal_p(int k, unsigned char n) {
	  return k == (int)-n-1;
	}
	static inline void oor_set(int *k, unsigned char n) {
	  *k = (int)-n-1;
	}

	DICT_OA_DEF2(dict_int, int, M_OPEXTEND(M_DEFAULT_OPLIST, OOR_EQUAL(oor_equal_p), OOR_SET(oor_set M_IPTR)), int64_t, M_DEFAULT_OPLIST)

	dict_int_t my_dict;
	void f(int key, int64_t value) {
		dict_int_set_at (my_dict, key, value);
	}


#### DICT\_OPLIST(name[, key\_oplist, value\_oplist])

Return the oplist of the dictionary defined by calling DICT\_DEF2 with name & key\_oplist & value\_oplist. 


#### DICT\_SET\_DEF(name, key\_type[, key\_oplist])

Define the set 'name##\_t' and its associated methods as "static inline" functions.
A set is a specialized version of a dictionary with no value.

It shall be done once per type and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET, CLEAR, HASH and EQUAL),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

Example:

	DICT_SET_DEF(dict_strSet, string_t)
	dict_strSet_t set;
	void f(string_t key) {
		dict_strSet_set_at (set, key);
	}

#### DICT\_OASET\_DEF(name, key\_type[, key\_oplist])

Define the set 'name##\_t' and its associated methods as "static inline" functions.
A set is a specialized version of a dictionary with no value.
The difference is that it uses an Open Addressing Hash-Table as 
container.

It shall be done once per type and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

The key_oplist shall therefore define the additional operators :
HASH and EQUAL and **OOR\_EQUAL** and **OOR\_SET**

This implementation is in general faster for small types of keys
(like integer) but slower for larger types.


#### DICT\_SET\_OPLIST(name[, key\_oplist])

Return the oplist of the set defined by calling DICT\_SET\_DEF (or DICT\_OASET\_DEF) with name & key\_oplist.

#### Created methods

In the following methods, name stands for the name given to the macro that is used to identify the type.
The following types are automatically defined by the previous macro:

##### name\_t

Type of the dictionary of 'key_type' --> 'value_type'.

##### name\_it\_t

Type of an iterator over this dictionary.

The following methods are automatically and properly created by the previous macro:

##### void name\_init(name\_t dict)

Initialize the dictionary 'dict' to be empty.

##### void name\_clear(name\_t dict)

Clear the dictionary 'dict'.

##### void name\_init\_set(name\_t dict, const name\_t ref)

Initialize the dictionary 'dict' to be the same as 'ref'.

##### void name\_set(name\_t dict, const name\_t ref)

Set the dictionary 'dict' to be the same as 'ref'.

##### void name\_init\_move(name\_t dict, name\_t ref)

Initialize the dictionary 'dict' by stealing as resource as possible
from 'ref' and clear 'ref'.

##### void name\_move(name\_t dict, name\_t ref)

Set the dictionary 'dict'  by stealing as resource as possible
from 'ref' and clear 'ref'.

##### void name\_clean(name\_t dict)

Clean the dictionary 'dict'. 'dict' remains initialized.

##### size\_t name\_size(const name\_t dict)

Return the number of elements of the dictionary.

##### value\_type \*name\_get(const name\_t dict, const key\_type key)

Return a pointer to the value associated to the key 'key' in dictionary
'dict' or NULL if the key is not found.

##### void name\_set\_at(name\_t dict, const key\_type key, const value\_type value)

Set the value referenced by key 'key' in the dictionary 'dict' to 'value'.
This method is only defined for associative containers (no SET).

##### void name\_push(name\_t dict, const key\_type key)

Push the value referenced by key 'key' into the dictionary 'dict'.
This method is only defined for SET.

##### void name\_erase(name\_t dict, const key\_type key)

Remove the element referenced by key 'key' in the dictionary 'dict'.
Do nothing if 'key' is no present in the dictionary.

##### void name\_it(name\_it\_t it, name\_t dict)

Set the iterator 'it' to the first element of 'dict'.

##### void name\_it\_set(name\_it\_t it, const name\_it\_t ref)

Set the iterator 'it' to the same element than 'ref'.

##### bool name\_end\_p(const name\_it\_t it)

Return true if 'it' references no longer a valid element.

##### bool name\_last\_p(const name\_it\_t it)

Return true if 'it' references the last element or is no longer valid.

##### void name\_next(name\_it\_t it)

Update the iterator 'it' to the next element.

##### struct name\_pair\_s *name\_ref(name\_it\_t it)

Return a pointer to the pair composed by the key ('key' field) and its value ('value' field).
'key' element can not be modified.
This pointer remains valid until the dictionary is modified by another method.

##### const struct name\_pair\_s *name\_ref(name\_it\_t it)

Return a constant pointer to the pair composed by the key('key' field)  and its value ('value' field).
This pointer remains valid until the dictionary is modified by another method.

##### void name\_get\_str(string\_t str, const name\_t dict, bool append)

Generate a string representation of the dict 'dict' and set 'str' to this representation
(if 'append' is false) or append 'str' with this representation (if 'append' is true).
This method is only defined if the type of the element defines a GET\_STR method itself.

##### bool name\_parse\_str(name\_t dict, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a dict
and set 'dict' to this representation.
This method is only defined if all types of the element defines PARSE\_STR methods itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void name\_out\_str(FILE *file, const name\_t dict)

Generate a string representation of the dict 'dict' and outputs it into the FILE 'file'.
This method is only defined if the type of the element defines a OUT\_STR method itself.

##### void name\_in\_str(name\_t dict, FILE *file)

Read from the file 'file' a string representation of a dict and set 'dict' to this representation.
This method is only defined if the type of the element defines a IN\_STR method itself.

##### bool name\_equal\_p(const name\_t dict1, const name\_t dict2)

Return true if both dict 'dict1' and 'dict2' are equal.
This method is only defined if the type of the element defines a EQUAL method itself.



### M-TUPLE

A [tuple](https://en.wikipedia.org/wiki/Tuple) is a finite ordered list of elements of different types. 

#### TUPLE\_DEF2(name, (element1, type1[, oplist1]) [, ...])

Define the tuple 'name##\_t' and its associated methods as "static inline" functions.
Each parameter of the macro is expected to be an element of the tuple.
Each element is defined by three parameters within parenthesis: 
the element name, the element type and the element oplist.
'name' and 'element' shall be a C identifier that will be used to identify the container.

This is more or less like a C structure. The main added value compared to using a struct
is that it generates also all the basic methods to handle it.
In fact, it generates a C struct with the given type and element.

It shall be done once per type and per compilation unit.

The object oplist is expected to have at least the following operators (INIT\_SET, SET and CLEAR),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.


Example:

	TUPLE_DEF2(pair, (key, string_t, STRING_OPLIST),
			 (value, mpz_t, (INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), CLEAR(mpz_clear) )))
	void f(void) {
		pair_t p1;
		pair_init (p1);
		string_set_str(p1->key, "HELLO");
		mpz_set_str(p1->value, "1742", 10);
		pair_clear(p1);
	}

#### TUPLE\_OPLIST(name, oplist1[, ...] )

Return the oplist of the tuple defined by calling TUPLE\_DEF2 with the given name & the oplists.

#### Created methods

In the following methods, name stands for the name given to the macro that is used to identify the type.
The following types are automatically defined by the previous macro:

#### name\_t

Type of the defined tuple.

The following methods are automatically and properly created by the previous macros:

##### void name\_init(name\_t tuple)

Initialize the tuple 'tuple' (aka constructor) to an empty tuple.
This method is defined if all methods define an INIT method.

##### void name\_init\_set(name\_t tuple, const name\_t ref)

Initialize the tuple 'tuple' (aka constructor) and set it to the value of 'ref'.

##### void name\_init\_set2(name\_t tuple, const type1 element1[, ...])

Initialize the tuple 'tuple' (aka constructor) and set it to the value of the tuple ('element1'[, ...]).

##### void name\_set(name\_t tuple, const name\_t ref)

Set the tuple 'tuple' to the value of 'ref'.

##### void name\_init\_move(name\_t tuple, name\_t ref)

Initialize the tuple 'tuple' (aka constructor) by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared.
This method is created only if all oplists of the tuple define INIT\_MOVE method.

##### void name\_move(name\_t tuple, name\_t ref)

Set the tuple 'tuple' by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared.
This method is created only if all oplists of the tuple define MOVE method.

##### void name\_clear(name\_t tuple)

Clear the tuple 'tuple (aka destructor).

##### const type1 *name\_cget\_at\_element1(const name\_t tuple)

Return a constant pointer to the element 'element1' of the tuple.
There is as many methods as there are elements.

##### type1 *name\_get\_at\_element1(const name\_t tuple)

Return a pointer to the element 'element1' of the tuple.
There is as many methods as there are elements.

##### void name\_set\_element1(name\_t tuple, type1 element1)

Set the element of the tuple to 'element1'
There is as many methods as there are elements.

##### int name\_cmp(const name\_t tuple1, const name\_t tuple2)

Compare 'tuple1' to 'tuple2' using lexicographic order.
This method is created only if all oplists of the tuple define CMP method.

##### int name\_cmp\_order(const name\_t tuple1, const name\_t tuple2, const int order[])

Compare 'tuple1' to 'tuple2' using the given order.
'order' is a null terminated array of int that defines the order of comparison:
an order of {1,4,2,0} indicates to compare first the first field,
if it is equal, to compare the fourth and so on. The third field is not
compared. A negative value indicates to revert the comparison.
This method is created only if all oplists of the tuple define CMP method.

##### int name\_cmp\_element1(const name\_t tuple1, const name\_t tuple2)

Compare 'tuple1' to 'tuple2' using only the element element1 as reference.
This method is created only if the oplist of element1 defines the CMP method.

##### int name\_equal\_p(const name\_t tuple1, const name\_t tuple2)

Return true if 'tuple1' and 'tuple2' are identical.
This method is created only if all oplists of the tuple define EQUAL method.

##### void name\_get\_str(string\_t str, const name\_t tuple, bool append)

Generate a string representation of the tuple 'tuple' and set 'str' to this representation
(if 'append' is false) or append 'str' with this representation (if 'append' is true).
This method is only defined if all oplists define a GET\_STR method.

##### bool name\_parse\_str(name\_t tuple, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a tuple
and set 'tuple' to this representation.
This method is only defined if all types of the element defines PARSE\_STR & INIT methods itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void name\_out\_str(FILE *file, const name\_t tuple)

Generate a string representation of the tuple 'tuple' and outputs it into the FILE 'file'.
This method is only defined if all oplists define a OUT\_STR method.

##### void name\_in\_str(name\_t tuple, FILE *file)

Read from the file 'file' a string representation of a tuple and set 'tuple' to this representation.
This method is only defined if all oplists define a IN\_STR method.


### M-VARIANT

A [variant](https://en.wikipedia.org/wiki/Variant_type) is a finite exclusive list of elements of different types :
the variant can be only equal to one element at a time. 

#### VARIANT\_DEF2(name, (element1, type1[, oplist1]) [, ...])

Define the variant 'name##\_t' and its associated methods as "static inline" functions.
Each parameter of the macro is expected to be an element of the variant.
Each element is defined by three parameters within parenthesis: 
the element name, the element type and the element oplist.
'name' and 'element' shall be a C identifier that will be used to identify the container.

This is like a C union. The main added value compared to using a union
is that it generates all the basic methods to handle it and it dynamically
identifies which element is stored within.

It shall be done once per type and per compilation unit.

The object oplist is expected to have at least the following operators (INIT\_SET, SET and CLEAR),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

Example:

	VARIANT_DEF2(either, (key, string_t, STRING_OPLIST),
			 (value, mpz_t, (INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), CLEAR(mpz_clear) )))
	void f(sting_t s) {
		either_t p1;
		either_init (p1);
		either_set_key(p1, s);
		either_clear(p1);
	}

#### VARIANT\_OPLIST(name, oplist1[, ...] )

Return the oplist of the variant defined by calling VARIANT\_DEF2 with the given name & the oplists.

#### Created methods

In the following methods, name stands for the name given to the macro that is used to identify the type.
The following types are automatically defined by the previous macro:

#### name\_t

Type of the defined variant.

The following methods are automatically and properly created by the previous macros:

##### void name\_init(name\_t variant)

Initialize the variant 'variant' (aka constructor) to be empty.

##### void name\_init\_set(name\_t variant, const name\_t ref)

Initialize the variant 'variant' (aka constructor) and set it to the value of 'ref'.

##### void name\_set(name\_t variant, const name\_t ref)

Set the variant 'variant' to the value of 'ref'.

##### void name\_init\_move(name\_t variant, name\_t ref)

Initialize the variant 'variant' (aka constructor) by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared.
This method is created only if all oplists of the variant define INIT\_MOVE method.

##### void name\_move(name\_t variant, name\_t ref)
##### void name\_move\_elementN(name\_t variant, typeN ref)

Set the variant 'variant' by stealing as many resources from 'ref' as possible.
After-wise 'ref' is cleared.
This method is created only if all oplists of the variant define MOVE method.

##### void name\_clear(name\_t variant)

Clear the variant 'variant (aka destructor).

##### void name\_clean(name\_t variant)

Clean the variant 'variant and make it empty.

##### void name\_init_elementN(name\_t variant)

Initialize the variant 'variant' to the type of 'element1'
This method is defined if all methods define an INIT method.

##### void name\_init\_set_elementN(name\_t variant, const typeN elementN)

Initialize and set the variant 'variant' to the type and value of 'elementN'.

##### void name\_set_elementN(name\_t variant, const typeN elementN)

Set the variant 'variant' to the type and value of 'elementN'.

##### const typeN * name\_cget\_at\_elementN(name\_t variant)

Return a pointer to the 'variant' viewed as of type 'typeN'.
If the variant isn't an object of such type, it returns NULL.

##### typeN * name\_get\_at\_elementN(name\_t variant)

Return a pointer to the 'variant' viewed as of type 'typeN'.
If the variant isn't an object of such type, it returns NULL.

##### bool name\_empty\_p(const name\_t variant)

Return true if the variant is empty, false otherwise.

##### bool name\_elementN\_p(const name\_t variant)

Return true if the variant is of the type of 'elementN'.

##### size_t name\_hash(const name\_t variant)

Return a hash associated to the variant.
All types associated to the variant shall have a hash function
for this function to be defined.

##### bool name\_equal\_p(const name\_t variant1, const name\_t varian2)

Return true if both objects are equal, false otherwise.
All types associated to the variant shall have a equal\_p function
for this function to be defined.

##### void name\_swap(name\_t variant1, name\_t varian2)

Swap both objects.

##### void name\_get\_str(string\_t str, name\_t variant, bool append)

Convert the variant into a string, appending it into 'str' or not.
All types associated to the variant shall have a GET\_STR method
for this function to be defined.

##### bool name\_parse\_str(name\_t variant, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a variant
and set 'variant' to this representation.
This method is only defined if all types of the element defines PARSE\_STR & INIT methods itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void name\_out\_str(FILE *file, name\_t variant)

Convert the variant into a string and send it to the stream 'file'.
All types associated to the variant shall have a out\_str function
for this function to be defined.

##### void name\_in\_str(name\_t variant, FILE *file)

Read a string representation of the variant from the stream 'file'
and update the object variant with it.
All types associated to the variant shall have a in\_str function
for this function to be defined.
This method is defined if all methods define an INIT method.


### M-RBTREE

#### RBTREE\_DEF(name, type[, oplist])

Define the binary ordered tree 'name##\_t' and its associated methods as "static inline" functions.
A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.
In this kind of tree, all elements of the tree are totally ordered.
The current implementation is [RED-BLACK TREE](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree).
It shall not be confused with a [B-TREE](https://en.wikipedia.org/wiki/B-tree).
'name' shall be a C identifier that will be used to identify the container.

The CMP operator is used to perform the total ordering of the elements.

The UPDATE operator is used to update an element if the 
pushed item already exist in the container. The default behavior
will overwrite the recorded value with the new one.
 
It shall be done once per type and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET, CLEAR and CMP),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

Example:

	RBTREE_DEF(rbtree_uint, unsigned int)
	void f(unsigned int num) {
		rbtree_uint_t tree;
		rbtree_uint_init(tree);
		for(unsigned int i = 0; i < num; i++)
			rbtree_uint_push(tree, i);
		rbtree_uint_clear(tree);                              
	}

#### RBTREE\_OPLIST(name [, oplist])

Return the oplist of the Red-Black defined by calling RBTREE\_DEF with name & oplist.
If there is no given oplist, the default oplist for standard C type is used.

#### Created methods

The following methods are automatically and properly created by the previous macros. 
In the following methods, name stands for the name given to the macro that is used to identify the type.

##### name\_t

Type of the Red Black Tree of 'type'.

##### name\_it_\_t

Type of an iterator over this Red Black Tree.

##### void name\_init(name\_t rbtree)

Initialize the Red Black Tree 'rbtree' to be empty.

##### void name\_clear(name\_t rbtree)

Clear the Red Black Tree 'rbtree'.

##### void name\_init\_set(name\_t rbtree, const name\_t ref)

Initialize the Red Black Tree 'rbtree' to be the same as 'ref'.

##### void name\_set(name\_t rbtree, const name\_t ref)

Set the Red Black Tree 'rbtree' to be the same as 'ref'.

##### void name\_init\_move(name\_t rbtree, name\_t ref)

Initialize the Red Black Tree 'rbtree' by stealing as resource as possible
from 'ref' and clear 'ref'.

##### void name\_move(name\_t rbtree, name\_t ref)

Set the Red Black Tree 'rbtree' by stealing as resource as possible
from 'ref' and clear 'ref'.

##### void name\_clean(name\_t rbtree)

Clean the Red Black Tree 'rbtree'. 'rbtree' remains initialized but empty.

##### size\_t name\_size(const name\_t rbtree)

Return the number of elements of the Red Black Tree.

##### void name\_push(name\_t rbtree, const type data)

Push 'data' into the Red Black Tree 'rbtree' at its ordered place
while keeping the tree balanced.
If the UPDATE operator is defined and there exists a node that equals (CMP) 'data'
it will be used to update the data of the node on push (It can be used to increment value).
Otherwise the value is overwritten.

##### void name\_pop(type *dest, name\_t rbtree, const type data)

Pop 'data' from the Red Black Tree 'rbtree'
and save the popped value into 'dest' if the pointer is not null
while keeping the tree balanced.
Do nothing if 'data' is no present in the Red Black Tree.

##### type * name\_min(const name\_t rbtree)
##### const type * name\_cmin(const name\_t rbtree)

Return a pointer to the minimum element of the tree
or NULL if there is no element.

##### type * name\_max(const name\_t rbtree)
##### const type * name\_cmax(const name\_t rbtree)

Return a pointer to the maximum element of the tree
or NULL if there is no element.

##### type * name\_get(const name\_t rbtree, const type *data)
##### const type * name\_cget(const name\_t rbtree, const type *data)

Return a pointer to the element of the tree 'rbtree' that is equal to 'data',
or NULL if there is no match.

##### void name\_swap(name\_t rbtree1, name\_t rbtree2)

Swap both trees.

##### bool name\_empty\_p(const name\_t rbtree)

Return true if the tree is empty, false otherwise.

##### void name\_it(name\it_\_t it, name\_t rbtree)

Set the iterator 'it' to the first element of 'rbtree'.

##### void name\_it\_set(name\it_\_t it, const name\it_\_t ref)

Set the iterator 'it' to the same element than 'ref'.

##### void name\_it\_last(name\it_\_t it, name\_t rbtree)

Set the iterator 'it' to the last element of 'rbtree'.

##### void name\_it\_end(name\it_\_t it, name\_t rbtree)

Set the iterator 'it' to no element of 'rbtree'.

##### void name\_it\_from(name\it_\_t it, const name\_t rbtree, const type data)

Set the iterator 'it' to the greatest element of 'rbtree'
lower of equal than 'data' or the first element is there is none.

##### bool name\_end\_p(const name\it_\_t it)

Return true if 'it' references no longer a valid element.

##### bool name\_last\_p(const name\it_\_t it)

Return true if 'it' references the last element or is no longer valid.

##### bool name\_it\_until\_p(const name\it_\_t it, const type data)

Return true if 'it' references an element that is greater or equal than 'data'.

##### bool name\_it\_while\_p(const name\it_\_t it, const type data)

Return true if 'it' references an element that is lower or equal than 'data'.

##### void name\_next(name\it_\_t it)

Update the iterator 'it' to the next element.

##### void name\_previous(name\it_\_t it)

Update the iterator 'it' to the previous element.

##### type *name\_ref(name\it_\_t it)
##### const type *name\_ref(name\it_\_t it)

Return a pointer to the element pointer by the iterator 'it'.
This pointer remains valid until the Red Black Tree is modified by another method.

##### void name\_get\_str(string\_t str, const name\_t rbtree, bool append)

Generate a string representation of the rbtree 'rbtree' and set 'str' to this representation
(if 'append' is false) or append 'str' with this representation (if 'append' is true).
This method is only defined if the type of the element defines a GET\_STR method itself.

##### bool name\_parse\_str(name\_t tree, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a RBTREE
and set 'tree' to this representation.
This method is only defined if all types of the element defines PARSE\_STR & INIT methods itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void name\_out\_str(FILE *file, const name\_t rbtree)

Generate a string representation of the rbtree 'rbtree' and outputs it into the FILE 'file'.
This method is only defined if the type of the element defines a OUT\_STR method itself.

##### void name\_in\_str(name\_t rbtree, FILE *file)

Read from the file 'file' a string representation of a rbtree and set 'rbtree' to this representation.
This method is only defined if the type of the element defines a IN\_STR method itself.

##### bool name\_equal\_p(const name\_t rbtree1, const name\_t rbtree2)

Return true if both rbtree 'rbtree1' and 'rbtree2' are equal.
This method is only defined if the type of the element defines a EQUAL method itself.

##### size\_t name\_hash\_p(const name\_t rbtree)

Return the hash of the tree.
This method is only defined if the type of the element defines a HASH method itself.

### M-BPTREE

A [B+TREE](https://en.wikipedia.org/wiki/B%2B_tree) is a variant of
[BTREE](https://en.wikipedia.org/wiki/B-tree) that itself is
a generalization of [Binary Tree](https://en.wikipedia.org/wiki/Binary_tree).

A B+TREE is an N-ary tree with a variable but often large number of children per node.
It is mostly used for handling slow media by file system and database.

It provides a fully sorted container enabling fast access to individual item
or range of items, and as such is concurrent to Red-Black Tree.
On modern architecture, a B+TREE is typically faster than a red-black tree due to being
more cache friendly (The RAM itself can be considered as a slow media nowadays!)

When defining a B+TREE it is necessary to give the type of the item within, but also
the maximum number of child per node. The best maximum number of child per node
depends on the type itself (its size, its compare cost) and the cache of the
processor. 

#### BPTREE\_DEF2(name, N, key_type, key_oplist, value, value_oplist)

Define the B+TREE tree of rank N 'name##\_t' and its associated methods as
"static inline" functions. This B+TREE will be created as an associative
array of the key_type to the value_type.

The CMP operator is used to perform the total ordering of the key elements.

It shall be done once per type and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET, CLEAR and CMP),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

Example:

	BPTREE_DEF2(tree_uint, unsigned int, (), float, ())
	void f(unsigned int num) {
		tree_uint_t tree;
		tree_uint_init(tree);
		for(unsigned int i = 0; i < num; i++)
			tree_uint_set_at(tree, i, (float) i);
		tree_uint_clear(tree);
	}

#### BPTREE\_OPLIST2(name, key_oplist, value_oplist)

Return the oplist of the BPTREE defined by calling BPTREE\_DEF2 with name, key_oplist
and value_oplist.

#### BPTREE\_DEF(name, N, key_type[, key_oplist])

Define the B+TREE tree of rank N 'name##\_t' and its associated methods as
"static inline" functions. This B+TREE will be created as an ordered set
of key_type.

The CMP operator is used to perform the total ordering of the key elements.

It shall be done once per type and per compilation unit.
It also define the iterator name##\_it\_t and its associated methods as "static inline" functions.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET, CLEAR and CMP),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

In the following specification, in this case, value\_type will be defined as the same
as key\_type.

Example:

	BPTREE_DEF(tree_uint, unsigned int)
	void f(unsigned int num) {
		tree_uint_t tree;
		tree_uint_init(tree);
		for(unsigned int i = 0; i < num; i++)
			tree_uint_push(tree, i);
		tree_uint_clear(tree);
	}

#### BPTREE\_OPLIST(name[, key_oplist])

Return the oplist of the BPTREE defined by calling BPTREE\_DEF with name, key_oplist.
If there is no given oplist, the default oplist for standard C type is used.


#### BPTREE\_MULTI\_DEF2(name, N, key_type, key_oplist, value, value_oplist)

Define the B+TREE tree of rank N 'name##\_t' and its associated methods as
"static inline" functions. This B+TREE will be created as an associative
array of the 'key_type' to the 'value_type' and allows multiple instance of
the same key in the tree (aka it is a multimap: re-adding the same key in
the tree will add a new instance of the key in the tree rather than update
the value associated to the key).

See BPTREE\_DEF2 for additional details and example.


#### BPTREE\_MULTI\_DEF(name, N, key_type[, key_oplist])

Define the B+TREE tree of rank N 'name##\_t' and its associated methods as
"static inline" functions. This B+TREE will be created as an ordered set
of key_type and allows multiple instance of
the same key in the tree (aka it is a multiset: re-adding the same key in
the tree will add a new instance of the key in the tree rather than update
the key value).

See BPTREE\_DEF for additional details and example.


#### Created methods

The following methods are automatically and properly created by the previous macros. 
In the following methods, name stands for the name given to the macro that is used to identify the type.

##### name\_t

Type of the B+Tree of 'type'.

##### name\_it_\_t

Type of an iterator over this B+Tree.

##### void name\_init(name\_t tree)

Initialize the B+Tree 'tree' and set it to empty.

##### void name\_clear(name\_t tree)

Clear the B+Tree 'tree'.

##### void name\_init\_set(name\_t tree, const name\_t ref)

Initialize the B+Tree 'tree' to be the same as 'ref'.

##### void name\_set(name\_t tree, const name\_t ref)

Set the B+Tree 'tree' to be the same as 'ref'.

##### void name\_init\_move(name\_t tree, name\_t ref)

Initialize the B+Tree 'tree' by stealing as resource as possible
from 'ref' and clear 'ref'.

##### void name\_move(name\_t tree, name\_t ref)

Set the B+Tree 'tree' by stealing as resource as possible
from 'ref' and clear 'ref'.

##### void name\_clean(name\_t tree)

Clean the B+Tree 'tree'. 'tree' remains initialized but empty.

##### size\_t name\_size(const name\_t tree)

Return the number of elements of the B+Tree.

##### void name\_push(name\_t tree, const key\_type data)

Push 'data' into the B+Tree 'tree' at the right order
while keeping the tree balanced.
This function is defined only if the tree is not defined as an associative array.

##### void name\_set\_at(name\_t tree, const key\_type data, const value\_type val)

Associate the value 'val' to the key 'data' in the B+Tree 'tree'
while keeping the tree balanced.
This function is defined only if the tree is defined as an associative array.

##### void name\_pop(value\_type *dest, name\_t tree, const key\_type data)

Pop 'data' from the B+Tree 'tree'
and save the popped value into 'dest' if the pointer is not null
while keeping the tree balanced.
Do nothing if 'data' is no present in the B+Tree.

##### bool name\_erase(name\_t tree, const key\_type data)

Remove 'data' from the B+Tree 'tree'
while keeping the tree balanced.
Return true if the data is removed, false if nothing is done (data is not present).

##### value\_type * name\_min(const name\_t tree)
##### const value\_type * name\_cmin(const name\_t tree)

Return a pointer to the minimum element of the tree
or NULL if there is no element.

##### value\_type * name\_max(const name\_t tree)
##### const value\_type * name\_cmax(const name\_t tree)

Return a pointer to the maximum element of the tree
or NULL if there is no element.

##### value\_type * name\_get(const name\_t tree, const key\_type *data)
##### const value\_type * name\_cget(const name\_t tree, const key\_type *data)

Return a pointer to the value of the tree 'tree' that is associated to 'data',
or NULL if there is no match.

##### void name\_swap(name\_t tree1, name\_t tree2)

Swap both trees.

##### bool name\_empty\_p(const name\_t tree)

Return true if the tree is empty, false otherwise.

##### void name\_it(name\_it_\_t it, name\_t tree)

Set the iterator 'it' to the first element of 'tree'.

##### void name\_it\_set(name\_it_\_t it, const name\_it_\_t ref)

Set the iterator 'it' to the same element than 'ref'.

##### void name\_it\_end(name\_it_\_t it, name\_t tree)

Set the iterator 'it' to no element of 'tree'.

##### void name\_it\_from(name\_it_\_t it, const name\_t tree, const type data)

Set the iterator 'it' to the greatest element of 'tree'
lower of equal than 'data' or the first element is there is none.

##### bool name\_end\_p(const name\_it_\_t it)

Return true if 'it' references no longer a valid element.

##### bool name\_it\_until\_p(const name\_it_\_t it, const type data)

Return true if 'it' references an element that is greater or equal than 'data'.

##### bool name\_it\_while\_p(const name\_it_\_t it, const type data)

Return true if 'it' references an element that is lower or equal than 'data'.

##### bool name\_it\_equal\_p(const name\_it_\_t it1, const name\_it_\_t it1)

Return true if both iterators reference the same object.

##### void name\_next(name\_it_\_t it)

Update the iterator 'it' to the next element.

##### type *name\_ref(name\_it_\_t it)
##### const type *name\_ref(name\_it_\_t it)

Return a pointer to the element pointer by the iterator 'it'.
This pointer remains valid until the B+Tree is modified by another method.

##### void name\_get\_str(string\_t str, const name\_t tree, bool append)

Generate a string representation of the tree 'tree' and set 'str' to this representation
(if 'append' is false) or append 'str' with this representation (if 'append' is true).
This method is only defined if the type of the element defines a GET\_STR method itself.

##### bool name\_parse\_str(name\_t tree, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a tree
and set 'tree' to this representation.
This method is only defined if the type of the element defines a PARSE\_STR method itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void name\_out\_str(FILE *file, const name\_t tree)

Generate a string representation of the tree 'tree' and outputs it into the FILE 'file'.
This method is only defined if the type of the element defines a OUT\_STR method itself.

##### void name\_in\_str(name\_t tree, FILE *file)

Read from the file 'file' a string representation of a tree and set 'tree' to this representation.
This method is only defined if the type of the element defines a IN\_STR method itself.

##### bool name\_equal\_p(const name\_t tree1, const name\_t tree2)

Return true if both trees 'tree1' and 'tree2' are equal.
This method is only defined if the type of the element defines a EQUAL method itself.

##### size\_t name\_hash\_p(const name\_t tree)

Return the hash of the tree.
This method is only defined if the type of the element defines a HASH method itself.



### M-PRIOQUEUE

A [priority queue](https://en.wikipedia.org/wiki/Priority_queue) is a queue  where each element has a "priority" associated with it: an element with high priority is served before an element with low priority. It is currently implemented as a [heap](https://en.wikipedia.org/wiki/Heap_(data_structure)).


#### PRIOQUEUE\_DEF(name, type [, oplist])

Define the priority queue 'name##\_t' and its associated methods
as "static inline" functions.
The queue will be composed of object of type 'type'.

'name' shall be a C identifier that will be used to identify the container.

The CMP operator is used to sort the queue so that it always returns the minimum of the queue.
The EQUAL operator is used to identify an item on UPDATE or REMOVE operations.
It is uncorrelated with the CMP operator from the point of view of this operator.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET, CLEAR, CMP and EQUAL),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.

#### PRIOQUEUE\_OPLIST(name, [, oplist])

Define the oplist of the prioqueue defined with 'name' and potentially 'oplist'.
If there is no given oplist, the default oplist for standard C type is used.

#### Created methods

The following methods are automatically and properly created by the previous
macros. In the following methods, name stands for the name given to the macro
that is used to identify the type.

##### name\_t

Type of the priority queue of 'type'.

##### name\_it_\_t

Type of an iterator over this priority queue.

##### void name\_init(name\_t queue)

Initialize the priority queue 'queue' and set it to empty.

##### void name\_clear(name\_t queue)

Clear the priority queue 'tree'.

##### void name\_init\_set(name\_t queue, const name\_t ref)

Initialize the Priority Queue 'queue' to be the same as 'ref'.

##### void name\_set(name\_t queue, const name\_t ref)

Set the Priority Queue 'queue' to be the same as 'ref'.

##### void name\_init\_move(name\_t queue, name\_t ref)

Initialize the Priority Queue 'queue' by stealing as resource as possible
from 'ref' and clear 'ref'.

##### void name\_move(name\_t queue, name\_t ref)

Set the Priority Queue 'queue' by stealing as resource as possible
from 'ref' and clear 'ref'.

##### void name\_clean(name\_t queue)

Clean the Priority Queue 'queue'. 'queue' remains initialized but empty.

##### size\_t name\_size(const name\_t queue)

Return the number of elements of the Priority Queue.

##### bool name\_empty\_p(const name\_t queue)

Return true if the queue is empty, false otherwise.

##### void name\_swap(name\_t queue1, name\_t queue2)

Swap both queues.

##### void name\_push(name\_t queue, const type x)

Push 'x' into the Priority Queue 'queue' (somewhere in the queue).

##### const type *name\_front(name\_t queue)

Return a constant pointer to the item having the
minimum value of all elements in the queue
'queue'.

##### void name\_pop(type *dest, name\_t queue)

Pop the minimum value from the priority Queue 'queue'
and save the popped value into 'dest' if the pointer is not null.

##### void name\_it(name\_it_\_t it, name\_t queue)

Set the iterator 'it' to the first element of 'queue'.
It won't iterate from minimum to maximum but in an implementation
define way that ensures that all items are accessed.

##### void name\_it\_last(name\_it_\_t it, name\_t queue)

Set the iterator 'it' to the last element of 'queue'.

##### void name\_it\_set(name\_it_\_t it, const name\_it_\_t ref)

Set the iterator 'it' to the same element than 'ref'.

##### void name\_it\_end(name\_it_\_t it, name\_t queue)

Set the iterator 'it' to no element of 'queue'.

##### bool name\_end\_p(const name\_it_\_t it)

Return true if 'it' references no longer a valid element.

##### bool name\_last\_p(const name\_it_\_t it)

Return true if 'it' references the last element, or there is no
longer any valid element.

##### bool name\_it\_equal\_p(const name\_it_\_t it1, const name\_it_\_t it2)

Return true if both iterators reference the same entries.

##### void name\_next(name\_it_\_t it)

Update the iterator 'it' to the next element.

##### void name\_previous(name\_it_\_t it)

Update the iterator 'it' to the previous element.

##### const type *name\_cref(name\_it_\_t it)

Return a constant pointer to the referenced item.



### M-BUFFER

This header implements different kind of fixed circular buffer.

A [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) 
(or ring buffer) is a data structure using a single, bounded buffer
as if its head was connected to its tail.

#### BUFFER\_DEF(name, type, size, policy[, oplist])

Define the buffer 'name##\_t' and its associated methods as "static inline" functions.
A buffer is a fixed circular queue implementing a queue (or stack) interface.
It can be used to transfer message from multiple producer threads to multiple consumer threads.
This is done internally using a mutex and conditional waits
(if it is built with the BUFFER\_THREAD\_SAFE option -- default)

'name' shall be a C identifier that will be used to identify the container.

The size parameter defined the fixed size of the queue.
It can be 0. In this case, the fixed size is defined at initialization time only
and the needed objects to handle the buffer are allocated at initialization time too.
Otherwise the needed objects are embedded within the structure, preventing
any other allocations.

Multiple additional policy can be applied to the buffer by performing a logical or of the following properties:

* BUFFER\_QUEUE : define a FIFO queue (default),
* BUFFER\_STACK : define a stack (exclusive with BUFFER\_QUEUE),

* BUFFER\_THREAD\_SAFE : define thread safe functions (default),
* BUFFER\_THREAD\_UNSAFE : define thread unsafe functions (exclusive with BUFFER\_THREAD\_SAFE),

* BUFFER\_PUSH\_INIT\_POP\_MOVE : change the behavior of PUSH to push a new initialized object, and POP as moving this new object into the new emplacement (this is mostly used for performance reasons or to handle properly a shared_ptr semantic). In practice, it works as if POP performs the initialization of the object. 
* BUFFER\_PUSH\_OVERWRITE : PUSH overwrites the last entry if the queue is full instead of blocking,
* BUFFER\_DEFERRED\_POP : do not consider the object to be fully popped from the buffer by calling the pop method until the call to pop_deferred ; this enables to handle object that are in-progress of being consumed by the thread.

This container is designed to be used for easy synchronization inter-threads 
(and the variable shall be a global shared one).

It shall be done once per type and per compilation unit.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET and CLEAR),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.
It supports also INIT\_MOVE if available.

Example:

	BUFFER_DEF(buffer_uint, unsigned int, 10, BUFFER_QUEUE|BUFFER_BLOCKING)

	buffer_uint_t g_buff;

	void f(unsigned int i) {
		buffer_uint_init(g_buff, 10);
		buffer_uint_push(g_buff, i);
		buffer_uint_pop(&i, g_buff);
		buffer_uint_clear(g_buff);
	}


#### Created methods

The following methods are automatically and properly created by the previous macros. In the following methods, name stands for the name given to the macro that is used to identify the type.

##### void name\_init(buffer\_t buffer, size\_t size)

Initialize the buffer 'buffer' for 'size' elements.
The 'size' argument shall be the same as the one used to create the buffer
or the one used to create the buffer was '0'.
This function is not thread safe.

##### void name\_clear(buffer\_t buffer)

Clear the buffer and destroy all its allocation.
This function is not thread safe and doesn't perform any synchronization:
all threads shall have stopped using the buffer.

##### void name\_clean(buffer\_t buffer)

Clean the buffer making it empty but remain initialized.
This function is thread safe if the buffer was built thread safe.

##### bool name\_empty\_p(const buffer\_t buffer)

Return true if the buffer is empty, false otherwise.
This function is thread safe if the buffer was built thread safe. 

##### bool name\_full\_p(const buffer\_t buffer)

Return true if the buffer is full, false otherwise.
This function is thread safe if the buffer was built thread safe. 

##### size\_t name\_size(const buffer\_t buffer)

Return the number of elements in the buffer that can be en-queued.
This function is thread safe if the buffer was built thread safe. 

##### size\_t name\_capacity(const buffer\_t buffer)

Return the capacity of the buffer.

##### size\_t name\_overwrite(const buffer\_t buffer)

If the buffer is built with the BUFFER\_PUSH\_OVERWRITE option,
this function returns the number of elements that have been overwritten
and thus discarded.
If the buffer was not built with the BUFFER\_PUSH\_OVERWRITE option,
it returns 0.

##### bool name\_push\_blocking(buffer\_t buffer, const type data, bool blocking)

Push the object 'data' in the buffer 'buffer',
waiting for an empty room if 'blocking' is true.
Returns true if the data was pushed, false otherwise.
Always return true if the buffer is blocking.
This function is thread safe if the buffer was built thread safe. 

##### bool name\_pop\_blocking(type *data, buffer\_t buffer, bool blocking)

Pop from the buffer 'buffer' into the object '*data',
waiting for a data if 'blocking' is true.

If the buffer is built with the BUFFER\_PUSH\_INIT\_POP\_MOVE option,
the object pointed by 'data' shall be ***uninitialized***
as the pop function will perform a quick initialization of the object
(using an INIT_MOVE operator)
, otherwise it shall be an initialized object (the pop function will 
perform a SET operator).

If the buffer is built with the BUFFER\_DEFERRED\_POP option,
the object is still considered being present in the queue until
a call to name\_pop\_release.

Returns true if a data was popped, false otherwise.
Always return true if the buffer is blocking.
This function is thread safe if the buffer was built thread safe. 

##### bool name\_push(buffer\_t buffer, const type data)

Same as name\_push\_blocking with blocking equals to true.

##### bool name\_pop(type *data, buffer\_t buffer)

Same as name\_pop\_blocking with blocking equals to true.

##### bool name\_pop\_release(buffer\_t buffer)

If the buffer is built with the BUFFER\_DEFERRED\_POP option,
the object being popped is considered fully release (freeing a
space in the queue).
Otherwise it does nothing.


#### QUEUE\_MPMC\_DEF(name, type, policy[, oplist])

Define the MPMC queue 'name##\_t' and its associated methods as "static inline" functions.
A MPMC queue is a fixed circular queue implementing a queue (or stack) interface.
It can be used to transfer message from Multiple Producer threads to Multiple Consumer threads.
This queue is not stricly lock free but [has](https://stackoverflow.com/questions/45907210/lock-free-progress-guarantees)
a lot of the properties of such algorithms.

The size is specified only at run-time and shall be a power of 2.

'name' shall be a C identifier that will be used to identify the container.

An additional policy can be applied to the buffer by performing a logical or of the following properties:

* BUFFER\_QUEUE : define a FIFO queue (default),
* BUFFER\_PUSH\_INIT\_POP\_MOVE : change the behavior of PUSH to push a new initialized object, and POP as moving this new object into the new emplacement (this is mostly used for performance reasons or to handle properly a shared_ptr semantic). In practice, it works as if POP performs the initialization of the object. 

This container is designed to be used for easy synchronization inter-threads
in a context of very fast communication (the variable shall be a global shared one).
There should not have more threads using this queue than they are available hardware cores 
due to the only partial protection on Context-switch Immunity of this structure.

It shall be done once per type and per compilation unit.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET and CLEAR),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.
It supports also INIT\_MOVE if available.

#### Created methods

The following methods are automatically and properly created by the previous macros.
In the following methods, name stands for the name given to the macro that is used to identify the type (prefix).

##### void name\_init(buffer\_t buffer, size\_t size)

Initialize the buffer 'buffer' with 'size' elements.
The 'size' argument shall be a power of two greater than 0, and less than UINT_MAX.
This function is not thread safe.

##### void name\_clear(buffer\_t buffer)

Clear the buffer and destroy all its allocation.
This function is not thread safe and doesn't perform any synchronization:
all threads shall have stopped using the buffer.

##### bool name\_empty\_p(const buffer\_t buffer)

Return true if the buffer is empty, false otherwise.
This function is thread safe.

##### bool name\_full\_p(const buffer\_t buffer)

Return true if the buffer is full, false otherwise.
This function is thread safe.

##### size\_t name\_size(const buffer\_t buffer)

Return the number of elements in the buffer that can be en-queued.
This function is thread safe but may return a size greater than
the size of the queue in some race condition.

##### size\_t name\_capacity(const buffer\_t buffer)

Return the capacity of the buffer.

##### bool name\_push(buffer\_t buffer, const type data)

Push the object 'data' in the buffer 'buffer' if possible.
Returns true if the data was pushed, false otherwise
(buffer full or unlikely data race).
This function is thread safe. 

##### bool name\_pop(type *data, buffer\_t buffer)

Pop from the buffer 'buffer' into the object '*data' if possible.

If the buffer is built with the BUFFER\_PUSH\_INIT\_POP\_MOVE option,
the object pointed by 'data' shall be ***uninitialized***
as the pop function will perform a quick initialization of the object
(using an INIT_MOVE operator)
, otherwise it shall be an initialized object (the pop function will 
perform a SET operator).

Returns true if a data was popped, false otherwise (buffer empty or unlikely data race).
This function is thread safe. 



#### QUEUE\_SPSC\_DEF(name, type, policy[, oplist])

Define the SPSC queue 'name##\_t' and its associated methods as "static inline" functions.
A SPSC queue is a fixed circular queue implementing a queue (or stack) interface.
It can be used to transfer message from a Single Producer thread to a Single Consumer thread.
This is done internally using lock-free objects.
It is more specialized than QUEUE\_MPMC\_DEF and as such, is faster.

The size is specified only at run-time and shall be a power of 2.

'name' shall be a C identifier that will be used to identify the container.

An additional policy can be applied to the buffer by performing a logical or of the following properties:

* BUFFER\_QUEUE : define a FIFO queue (default),
* BUFFER\_PUSH\_INIT\_POP\_MOVE : change the behavior of PUSH to push a new initialized object, and POP as moving this new object into the new emplacement (this is mostly used for performance reasons or to handle properly a shared_ptr semantic). In practice, it works as if POP performs the initialization of the object. 

This container is designed to be used for easy synchronization inter-threads
in a context of very fast communication (the variable shall be a global shared one).

It shall be done once per type and per compilation unit.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET and CLEAR),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.
It supports also INIT\_MOVE if available.

#### Created methods

The following methods are automatically and properly created by the previous macros.
In the following methods, name stands for the name given to the macro that is used to identify the type (prefix).

##### void name\_init(buffer\_t buffer, size\_t size)

Initialize the buffer 'buffer' with 'size' elements.
The 'size' argument shall be a power of two greater than 0, and less than UINT_MAX.
This function is not thread safe.

##### void name\_clear(buffer\_t buffer)

Clear the buffer and destroy all its allocation.
This function is not thread safe and doesn't perform any synchronization:
all threads shall have stopped using the buffer.

##### bool name\_empty\_p(const buffer\_t buffer)

Return true if the buffer is empty, false otherwise.
This function is thread safe.

##### bool name\_full\_p(const buffer\_t buffer)

Return true if the buffer is full, false otherwise.
This function is thread safe.

##### size\_t name\_size(const buffer\_t buffer)

Return the number of elements in the buffer that can be en-queued.
This function is thread safe but may return a size greater than
the size of the queue in some race condition.

##### size\_t name\_capacity(const buffer\_t buffer)

Return the capacity of the buffer.

##### bool name\_push(buffer\_t buffer, const type data)

Push the object 'data' in the buffer 'buffer' if possible.
Returns true if the data was pushed, false otherwise (buffer full).
This function is thread safe. 

##### bool name\_push\_move(buffer\_t buffer, type data)

Push & move the object 'data' in the buffer 'buffer' if possible.
Returns true if the data was pushed, false otherwise (buffer full).
Afterwards 'data' is cleared if true is returned.
This function is thread safe. 

##### bool name\_push\_force(buffer\_t buffer, const type data)

Push the object 'data' in the buffer 'buffer'
discarding the oldest data if needed.
This function is thread safe. 

##### bool name\_push\_bulk(buffer\_t buffer, unsigned n, const type data[])

Push as much objects from the array 'data' in the buffer 'buffer' as possible,
starting from the object at index 0 to the object at index 'n-1'.
Returns the number of objects pushed.
This function is thread safe. 

##### bool name\_pop(type *data, buffer\_t buffer)

Pop from the buffer 'buffer' into the object '*data' if possible.

If the buffer is built with the BUFFER\_PUSH\_INIT\_POP\_MOVE option,
the object pointed by 'data' shall be ***uninitialized***
as the pop function will perform a quick initialization of the object
(using an INIT_MOVE operator)
, otherwise it shall be an initialized object (the pop function will 
perform a SET operator).

Returns true if a data was popped, false otherwise (buffer empty or unlikely data race).
This function is thread safe. 

##### unsigned name\_pop\_bulk(unsigned n, type tab[n], buffer\_t buffer)

Pop from the buffer 'buffer' as many objects as possible to fill in 'tab'
and at most 'n'.

If the buffer is built with the BUFFER\_PUSH\_INIT\_POP\_MOVE option,
the object pointed by 'data' shall be ***uninitialized***
as the pop function will perform a quick initialization of the object
(using an INIT_MOVE operator)
, otherwise it shall be an initialized object (the pop function will 
perform a SET operator).

It returns the number of objects popped.
This function is thread safe. 



### M-SNAPSHOT

This header is for created snapshots.

A snapshot is a mechanism enabling a reader thread and a writer thread,
 **working at different speeds**, to exchange messages in a fast, reliable and thread safe way
(the message is always passed automatically from a thread point of view) without waiting
for synchronization.
The consumer thread has only access to the latest published data of 
the producer thread.
This is implemented in a fast way as the writer directly writes the message in the buffer
that will be passed to the reader (avoiding copy of the buffer) and a simple exchange
of index is sufficient to handle the switch.

This container is designed to be used for easy synchronization inter-threads 
(and the variable shall be a global shared one).

This is linked to [shared atomic register](https://en.wikipedia.org/wiki/Shared_register) in the literature 
and [snapshot](https://en.wikipedia.org/wiki/Shared_snapshot_objects) names vector of such registers
where each element of the vector can be updated separately. They can be classified according to the
number of producers/consumers:
SPSC (Single Producer, Single Consumer),
MPSC (Multiple Producer, Single Consumer),
SPMC (Single Producer, Multiple Consumer),
MPMC (Multiple Producer, Multiple Consumer),

The provided containers by the library are designed to handle huge
structure efficiently and as such deal with the memory reclamation needed to handle them.
If the data you are sharing are supported by the atomic header (like bool or integer), 
using atomic_load and atomic_store is a much more efficient and simple way to do
even in the case of MPMC.


#### SNAPSHOT\_SPSC\_DEF(name, type[, oplist])

Define the snapshot 'name##\_t' and its associated methods as "static inline" functions.
Only a single reader thread and a single writer thread are supported.
It is a SPSC atomic shared register.
In practice, it is implemented using a triple buffer (lock-free).

It shall be done once per type and per compilation unit. Not all functions are thread safe.

The object oplist is expected to have at least the following operators (INIT, INIT\_SET, SET and CLEAR),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to init, set and clear the contained object.
It supports also INIT\_MOVE if available.

Example:

	SNAPSHOT_DEF(snapshot_uint, unsigned int)
	snapshot_uint_t message;
	void f(unsigned int i) {
		unsigned *p = snapshot_uint_get_write_buffer(message);
		*p = i;
                snapshot_uint_write(message);
	}
	unsigned int g(void) {
		unsigned *p = snapshot_uint_read(message);
		return *p;
	}


#### Created methods

The following methods are automatically and properly created by the previous macros. In the following methods, name stands for the name given to the macro that is used to identify the type.

##### void name\_init(snapshot\_t snapshot)

Initialize the snapshot 'snapshot'.
This function is not thread safe.

##### void name\_clear(snapshot\_t snapshot)

Clear the snapshot and destroy all its allocations.
This function is not thread safe.

##### void name\_init\_set(snapshot\_t snapshot, const snapshot\_t org)

Initialize the snapshot 'snapshot' from the state of 'org'.
This function is not thread safe.

##### void name\_set(snapshot\_t snapshot, const snapshot\_t org)

Set the snapshot 'snapshot' from the state of 'org'.
This function is not thread safe.

##### void name\_init\_move(snapshot\_t snapshot, snapshot\_t org)

Move the contain of the snapshot 'org' to the uninitialized 'snapshot',
clearing 'org' in the process.
This function is not thread safe.
This function is defined only if the underlying type has defined the
INIT\_MOVE operator.

##### void name\_move(snapshot\_t snapshot, snapshot\_t org)

Move the contain of the snapshot 'org' to the initialized 'snapshot',
clearing 'org' in the process.
This function is not thread safe.
This function is defined only if the underlying type has defined the
MOVE operator.

##### type *name\_write(snapshot\_t snap)

Publish the 'in-progress' data of the snapshot 'snap so that the read
thread can have access to the data.
It returns the pointer to the new 'in-progress' data buffer 
of the snapshot (which is not yet published but will be published 
for the next call of name\_write).
This function is thread-safe and performs atomic operation on the snapshot.

##### type *name\_read(snapshot\_t snap)

Get access to the last published data of the snapshot 'snap'.
It returns the pointer to the data.
If a publication has been performed since the last call to name\_read
a new pointer to the data is returned. 
Otherwise the previous pointer is returned.
This function is thread-safe and performs atomic operation on the snapshot.

##### bool name\_updated\_p(snapshot\_t snap)

Return true if the buffer has updated data compared to the last time
it was read.
This function is thread-safe and performs atomic operation on the snapshot.

##### type *name\_get\_write\_buffer(snapshot\_t snap)

Return a pointer to the active 'in-progress' data of the snapshot 'snap'.
It is the same as the last return from name\_write.
This function is thread-safe and performs atomic operation on the snapshot.

##### type *name\_get\_read\_buffer(snapshot\_t snap)

Return a pointer to the active published data of the snapshot 'snap'.
It is the same as the last return from name\_read.
It doesn't perform any switch of the data that has to be read.
This function is thread-safe and performs atomic operation on the snapshot.

TODO: Document SPMC & MPMC snapshots


### M-SHARED

This header is for creating shared pointer.
A [shared pointer](https://en.wikipedia.org/wiki/Smart_pointer)
 is a smart pointer that retains shared ownership of an object.
Several shared pointers may own the same object, sharing ownership of an object. 


#### SHARED\_PTR\_DEF(name, type[, oplist])

Define the shared pointer 'name##\_t' and its associated methods as "static inline" functions.
A shared pointer is a mechanism to keep tracks of all users of an object
and performs an automatic destruction of the object whenever all users release
their need on this object.

The tracking of ownership is atomic and the destruction of the object is thread safe.

The object oplist is expected to have at least the following operators (CLEAR to clear the object and DEL to free the allocated memory),
otherwise default operators are used. If there is no given oplist, the default oplist for standard C type is used
or a globally registered oplist is used.
The created methods will use the operators to initialize, set and clear the contained object.
It supports also the INIT\_MOVE operator of the object if available.


There are designed to work with buffers with policy BUFFER\_PUSH\_INIT\_POP\_MOVE
to send a shared pointer across multiple threads.

Example:

	SHARED_PTR_DEF(shared_mpz, mpz_t, (CLEAR(mpz_clear)))
	void f(void) {
		shared_mpz_t p;
		mpz_t z;
		mpz_init(z);
		shared_mpz_init2 (p, z);
		buffer_uint_push(g_buff1, p);
		buffer_uint_push(g_buff2, p);
		shared_mpz_clear(p);
	}


#### Created methods

The following methods are automatically and properly created by the previous macros. In the following methods, name stands for the name given to the macro that is used to identify the type.

##### void name\_init(shared\_t shared)

Initialize the shared pointer 'shared' to represent NULL
(no object is therefore referenced).

##### void name\_init2(shared\_t shared, type *data)

Initialize the shared pointer 'shared' to reference '*data'.
User code shall not use '*data' (or any pointer to it) anymore
as the shared pointer gets the exclusive ownership of the object.

##### void name\_init\_new(shared\_t shared)

Initialize the shared pointer 'shared' to a new object of type 'type'.
The default constructor of type is used to initialize the object.

##### void name\_init\_set(shared\_t shared, const shared\_t src)

Initialize the shared pointer 'shared' to the same object than the one
pointed by 'src' (sharing ownership).
This function is thread safe from 'src' point of view.

##### bool name\_NULL\_p(const shared\_t shared)

Return true if shared doesn't reference any object.

##### void name\_clear(shared\_t shared)

Clear the shared pointer:
the shared pointer loses its ownership of the object and
it destroys it if no longer any other shared pointers own the object.
This function is thread safe.

##### void name\_clean(shared\_t shared)

'shared' loses ownership of its object and destroy it
if no longer any other shared pointers own it.
Then it makes the shared pointer 'shared' references NULL
(it doesn't reference its object any-longer and loses its ownership of it).
This function is thread safe.

##### void name\_set(shared\_t shared, const shared\_t src)

'shared' loses ownership of its object and destroy it
if no longer any other shared pointers own it.
Then it sets the shared pointer 'shared' to the same object 
than the one pointed by 'src' (sharing ownership).
This function is thread safe.

##### void name\_init\_move(shared\_t shared, shared\_t src)

Move the shared pointer from the initialized 'src' to 'shared'.

##### void name\_move(shared\_t shared, shared\_t src)

'shared' loses ownership of its object and destroy it
if no longer any other shared pointers own it.
Then it moves the shared pointer from the initialized 'src' to 'shared'.

##### void name\_swap(shared\_t shared1, shared\_t shared2)

Swap the references of the objects owned by the shared pointers 'shared1' and 'shared2'.

##### bool name\_equal\_p(const shared\_t shared1, const shared\_t shared2)

Return true if both shared pointers own the same object.

##### const type *name\_cref(const shared\_t shared)

Return a constant pointer to the shared object owned by the shared pointer.
The pointer shall be kept only until another use of shared pointer method.
Keeping the pointer otherwise is undefined behavior.

##### type *name\_ref(const shared\_t shared)

Return a pointer to the shared object pointed by the shared pointer.
The pointer shall be kept only until another use of shared pointer method.
Keeping the pointer otherwise is undefined behavior.

TODO: Document shared resource



### M-I-SHARED

This header is for creating intrusive shared pointer.

#### ISHARED\_INTERFACE(name, type)

Extend the definition of the structure of an object of type 'type' by adding the
necessary interface to handle it as a shared pointer named 'name'.
It shall be put within the structure definition of the object (See example).

#### ISHARED\_PTR\_DEF(name, type[, oplist])

Define the associated methods to handle the shared pointer named 'name'
as "static inline" functions.
A shared pointer is a mechanism to keep tracks of all users of an object
and performs an automatic destruction of the object whenever all users release
their need on this object.

The destruction of the object is thread safe and to occur when all users
of the object release it. The last user that releases it is the one that
performs the destruction of the object. The destruction of the object implies:

* calling the CLEAR operator to clear the object,
* calling the DEL operator to release the memory used by the object 
(if the method has not been disabled).

The object oplist is expected to have the following operators (CLEAR and DEL),
otherwise default operators are used. If there is no given oplist, the default
operators are also used. The created methods will use the operators to init, set
and clear the contained object.

There are designed to work with buffers with policy BUFFER\_PUSH\_INIT\_POP\_MOVE
to send a shared pointer across multiple threads.

It is recommended to use the intrusive shared pointer over the standard one if
possible (They are faster & cleaner).

Example:

        typedef struct mystruct_s {
                ISHARED_PTR_INTERFACE(ishared_mystruct, struct mystruct_s);
                char *message;
        } mystruct_t;

        static inline void mystruct_clear(mystruct_t *p) { free(p->message); }

        ISHARED_PTR_DEF(ishared_mystruct, mystruct_t, (CLEAR(mystruct_clear M_IPTR)))

        void f(void) {
                mystruct_t *p = ishared_mystruct_new();
                p->message = strdup ("Hello");
                buffer_mystruct_push(g_buff1, p);
                buffer_mystruct_push(g_buff2, p);
                ishared_mystruct_clear(p);
        }


#### Created methods

The following methods are automatically and properly created by the previous macros. In the following methods, name stands for the name given to the macro that is used to identify the type.

##### typedef type *name_t

It will define name_t as a pointer to shared counted object.
This is a synonymous to a pointer to the object.

##### name_t name\_init(type *object)

Return a shared pointer to 'object' which owns 'object'.
The shared pointer part of 'object' shall not have been initialized,
whereas other part of the object shall be initialized.

##### name_t name\_init\_set(name_t shared)

Return a new shared pointer to the same object than the one pointed by 'shared',
incrementing the ownership of the object.
This function is thread safe.

##### void name\_init\_set2(name_t *ptr, name_t shared)

Set '*ptr' to a new shared pointer to 'shared', 
incrementing the ownership of the object referenced by 'shared'.
This function is thread safe (providing the ptr address is local to a thread).

##### name_t name\_init\_new(void)

Allocate a new object, initialize it and return an initialized shared pointer to it.

The used allocation function is the ALLOC operator.
In this case, it is assumed that the DEL operator has not been disabled.

This function is created only if the INIT method is defined in the oplist
and if the NEW method has not been disabled in the oplist.

##### void name\_clear(name_t shared)

Clear the shared pointer, releasing ownership of the object
and destroying the shared object if no longer
any other shared pointers own it.
This function is thread safe.

##### void name\_set(name_t *shared1, name_t shared2)

Update the shared pointer '*shared1' to point to the same object than
the shared pointer 'shared2'.
Destroy the shared object pointed by '*shared1' if no longer any other shared
pointers own it, set the shared pointer 'shared' to the same object 
than the one pointed by 'src'.
This function is thread safe.



### M-I-LIST

This header is for creating intrusive doubly-linked list.

#### ILIST\_INTERFACE(name, type)

Extend an object by adding the necessary interface to handle it within 
an intrusive doubly-linked list.
This is the intrusive part.
It shall be put within the structure of the object to link, at the top
level of the structure.
See example of ILIST\_DEF.

#### ILIST\_DEF(name, type[, oplist])

Define the intrusive doubly-linked list 
and define the associated methods to handle it as "static inline" functions.
'name' shall be a C identifier that will be used to identify the list. It will be used to create all the types and functions to handle the container.
It shall be done once per type and per compilation unit.

An object is expected to be part of only one list of a kind in the entire program at a time.
An intrusive list enables to move from an object to the next object without needing to go through the entire list,
or to remove an object from a list in O(1).
It may, or may not, be better than standard list. It depends on the context.

The object oplist is expected to have the default operators. If there is no given oplist, the methods for a standard C type are used, or if there is a global defined oplist, it is used.
The created methods will use the operators to init, set and clear the contained object.

The given interface won't allocate anything to handle the objects as
all allocations and initialization are let to the user.

However the objects within the list can be automatically be cleared
(by calling the CLEAR method to destruct the object) on list destruction.
The memory allocation, performed by the called, can also be reclaimed
by defining a DEL operator to free the used memory in the object oplist.
If there is no DEL operator, it is up to the user to free the used memory.

Example:

	typedef struct test_s {
	  int n;
	  ILIST_INTERFACE (ilist_tname, struct test_s);
	} test_t;

	ILIST_DEF(ilist_tname, test_t)

	void f(void) {
		test_t x1, x2, x3;
		ilist_tname_t list;

		x1.n = 1;
		x2.n = 2;
		x3.n = 3;

		ilist_tname_init(list);
		ilist_tname_push_back (list, &x3);
		ilist_tname_push_front (list, &x1);
		ilist_tname_push_after (&x1, &x2);

		int n = 1;
		for M_EACH(item, list, ILIST_OPLIST(ilist_tname)) {
			assert (n == item->n);
			n++;
		}
		ilist_tname_clear(list);
	}


#### Created methods

The following methods are automatically and properly created by the previous macros. In the following methods, name stands for the name given to the macro that is used to identify the type.

#### name\_t

Type of the list of 'type'.

#### name\_it\_t

Type of an iterator over this list.

The following methods are automatically and properly created by the previous macro.

##### void name\_init(name\_t list)

Initialize the list 'list' (aka constructor) to an empty list.

##### void name\_init\_field(type *obj)

Initialize the additional fields of the object '*obj'.

##### void name\_clear(name\_t list)

Clear the list 'list (aka destructor). The list can't be used anymore, except with a constructor.
If the DEL operator is available in the oplist of the type,
the cleared object will also be deleted.

##### void name\_clean(name\_t list)

Clean the list (the list becomes empty). The list remains initialized but is empty.
If the DEL operator is available in the oplist of the type,
the cleared object will also be deleted.

##### type *name\_back(const name\_t list)

Return a constant pointer to the data stored in the back of the list.

##### type *name\_front(const name\_t list)

Return a constant pointer to the data stored in the front of the list.

##### void name\_push\_back(name\_t list, type *obj)

Push the object '*obj' itself at the back of the list 'list'.

##### void name\_push\_front(name\_t list, type *obj)

Push the object '*obj' itself at the front of the list 'list'.

##### void name\_push\_after(type *position, type *obj)

Push the object '*obj' after the object '*position'.

##### type *name\_pop\_back(name\_t list)

Pop the object from the back of the list 'list'
and return a pointer to the popped object.

##### type *name\_pop\_front(name\_t list)

Pop the object from the front of the list 'list'
and return a pointer to the popped object.

##### bool name\_empty\_p(const name\_t list)

Return true if the list is empty, false otherwise.

##### void name\_swap(name\_t list1, name\_t list2)

Swap the list 'list1' and 'list2'.

##### void name\_unlink(type *obj)

Remove the object '*obj' from the list.

##### type *name\_next\_obj(const name\_t list, const type *obj)

Return the object that is after the object '*obj' in the list
or NULL if there is no more object.

##### type *name\_previous\_obj(const name\_t list, const type *obj)

Return the object that is before the object '*obj' in the list
or NULL if there is no more object.

##### void name\_it(name\_it\_t it, name\_t list)

Set the iterator 'it' to the back(=first) element of 'list'.
There is no destructor associated to this initialization.

##### void name\_it\_set(name\_it\_t it, const name\_it\_t ref)

Set the iterator 'it' to the iterator 'ref'.
There is no destructor associated to this initialization.

##### void name\_it\_last(name\_it\_t it, name\_t list)

Set the iterator 'it' to the last element of the list.
There is no destructor associated to this initialization.

##### void name\_it\_end(name\_it\_t it, name\_t list)

Set the iterator 'it' to the end of the list (i.e. not a valid element).
There is no destructor associated to this initialization.

##### bool name\_end\_p(const name\_it\_t it)

Return true if the iterator doesn't reference a valid element anymore.

##### bool name\_last\_p(const name\_it\_t it)

Return true if the iterator references the last element or if the iterator doesn't reference a valid element anymore.

##### bool name\_it\_equal\_p(const name\_it\_t it1, const name\_it\_t it2)

Return true if the iterator it1 references the same element than it2.

##### void name\_next(name\_it\_t it)

Move the iterator 'it' to the next element of the list.

##### void name\_previous(name\_it\_t it)

Move the iterator 'it' to the previous element of the list.

##### type *name\_ref(name\_it\_t it)

Return a pointer to the element pointed by the iterator.
This pointer remains valid until the list is modified by another method.

##### const type *name\_cref(const name\_it\_t it)

Return a constant pointer to the element pointed by the iterator.
This pointer remains valid until the list is modified by another method.

##### size\_t name\_size(const name\_t list)

Return the number elements of the list (aka size). Return 0 if there no element.

##### void name\_insert(name\_t list, name\_it\_t it, type x)

Insert a copy of 'x' after the position pointed by 'it' 
(which is an iterator of the list 'list') or if 'it' doesn't point anymore to a valid element of the list, it is added as the back (=first) element of the 'list'
This service is available only if a NEW operator is available for the type.

##### void name\_remove(name\_t list, name\_it\_t it)

Remove the element 'it' from the list 'list'.
After wise, 'it' points to the next element of the list.

##### void name\_splice\_back(name\_t list1, name\_t list2, name\_it\_t it)

Move the element pointed by 'it' (which is an iterator of 'list2') from the list 'list2' to the back position of 'list1'.
After wise, 'it' points to the next element of 'list2'.

##### void name\_splice(name\_t list1, name\_t list2)

Move all the element of 'list2' into 'list1", moving the last element
of 'list2' after the first element of 'list1'.
After-wise, 'list2' is emptied.


### M-CONCURRENT

This header is for transforming a standard container (LIST, ARRAY, DICT, DEQUE, ...)
into an equivalent container but compatible with concurrent access by different threads. 
In practice, it puts a lock to access the container.

As such it is quite generic. However it is less efficient than containers
specially tuned for multiple threads.
There is also no iterators.

#### methods

#### CONCURRENT\_DEF(name, type[, oplist])

Define the concurrent container 'name' based on container 'type' of oplist 'oplist',
and define the associated methods to handle it as "static inline" functions.
'name' shall be a C identifier that will be used to identify the list. 
It will be used to create all the types and functions to handle the container.
It shall be done once per type and per compilation unit.

It scans the 'oplist' of the type to create equivalent function,
so it needs it (either explictly or implictly).

Example:

        /* Define a stack container (STACK)*/
        ARRAY_DEF(array1, int)
        CONCURRENT_DEF(parray1, array1_t, ARRAY_OPLIST(array1))

        /* Define a queue container (FIFO) */
        DEQUE_DEF(deque_uint, unsigned int)
        CONCURRENT_DEF(cdeque_uint, deque_uint_t, M_OPEXTEND(DEQUE_OPLIST(deque_uint, M_DEFAULT_OPLIST), PUSH(deque_uint_push_front)))

	extern parray1_t x1;
	extern cdeque_uint_t x2;

	void f(void) {
	     parray1_push (x1, 17);
	     cdeque_uint_push (x2, 17);
	}


#### Created methods

The following methods are automatically and properly created by the previous macros. 
In the following methods, name stands for the name given to the macro that is used to identify the type.

##### name\_t

Type of the concurrent container of 'type'.

##### void name\_init(name\_t concurrent)

Initialize the concurrent container.
This method is only defined if the base container exports the INIT operator.

##### void name\_init\_set(name\_t concurrent, const name\_t src)

Initialize the concurrent container and set it with a copy of 'src'.
This method is only defined if the base container exports the INIT\_SET operator.

##### void name\_init\_move(name\_t concurrent, name\_t src)

Initialize the concurrent container by stealing as much resources from 'src' as possible.
Afterwards 'src' is cleared.
This method is only defined if the base container exports the INIT\_MOVE operator.

##### void name\_set(name\_t concurrent, const name\_t src)

Set the container with a copy of 'src'.
This method is only defined if the base container exports the SET operator.

##### void name\_move(name\_t concurrent, name\_t src)

Set the container with the value of 'src' by stealing as much resources from 'src' as possible.
Afterwards 'src' is cleared.
This method is only defined if the base container exports the MOVE operator.

##### void name\_clean(name\_t concurrent)

Clean the concurrent container.
Afterwards the container is empty, but remains initialized.
This method is only defined if the base container exports the CLEAN operator.

##### void name\_clear(name\_t concurrent)

Clear the concurrent container and destroy any resource.
This method shall only be called in context when no other threads can use the resource.
This method is only defined if the base container exports the CLEAR operator.

##### void name\_clear(name\_t concurrent)

Clear the concurrent container and destroy any resource.
This method shall only be called in context when no other threads can use the resource.
This method is only defined if the base container exports the CLEAR operator.

##### void name\_swap(name\_t concurrent1, name\_t concurrent2)

Swap both containers.
This method is only defined if the base container exports the SWAP operator.

##### bool name\_empty\_p(const name\_t concurrent)

Return true if the container is empty, false otherwise.
This method is only defined if the base container exports the TEST\_EMPTY operator.

##### void name\_set\_at(name\_t concurrent, key\_t key, value\_t value)

Associate to the key 'key' the value 'value' in the container.
This method is only defined if the base container exports the SET\_KEY operator.

##### bool name\_get\_copy(value_t *value, name\_t concurrent, key\_t key)

Read the value associated to the key 'key'. 
If it exists, it sets '*value' to it and returns true.
Otherwise it returns false.
This method is only defined if the base container exports the GET\_KEY operator.

##### void name\_get\_at\_copy(value_t *value, name\_t concurrent, key\_t key)

Read the value associated to the key 'key'. 
If it exists, it sets '*value' to it.
Otherwise it creates a new value and sets '*value' to it.
This method is only defined if the base container exports the GET\_SET\_KEY operator.

##### bool name\_erase(name\_t concurrent, const key\_t key)

Erase the association for the key 'key'.
Returns true in case of success, false otherwise.
This method is only defined if the base container exports the ERASE\_KEY operator.

##### void name\_push(name\_t concurrent, const subtype\_t data)

Push data in the container.
This method is only defined if the base container exports the PUSH operator.

##### void name\_pop(subtype\_t *data, name\_t concurrent)

Pop data from the container and set it in '*data'.
There shall be at least one data to pop, otherwise it is undefined behavior.
Testing with TEST_EMPTY before calling this function is not enough 
as there can be some concurrent scenario where another thread pop the last value.
It is highly recommending to use name\_pop\_blocking instead which is safer.
This method is only defined if the base container exports the POP operator.

##### void name\_push\_move(name\_t concurrent, subtype\_t data)

Push data in the container by stealing as much resources from data as possible.
Afterwards, data is cleared.
This method is only defined if the base container exports the PUSH\_MOVE operator.

##### void name\_pop\_move(subtype\_t *data, name\_t concurrent)

Pop data from the container and initialize '*data' with it.
It is highly recommending to use name\_pop\_move\_blocking instead which is safer.
This method is only defined if the base container exports the POP\_MOVE operator.

##### void name\_get\_str(string\_t str, name\_t concurrent, bool append)

Convert the container into a string representation of it and put it in 'str'
This method is only defined if the base container exports the GET\_STR operator.

##### void name\_out\_str(FILE *file, name\_t concurrent)

Convert the container into a string and put it in 'file'.
This method is only defined if the base container exports the OUT\_STR operator.

##### bool name\_parse\_str(name\_t concurrent, const char str[], const char **end)

Convert the string representing the container and set it 'concurrent' to it.
Return true in case of success, false otherwise.
This method is only defined if the base container exports the PARSE\_STR operator.

##### bool name\_in\_str(name\_t concurrent, FILE *file)

Read the file and convert the string representing the container and set it 'concurrent' to it.
Return true in case of success, false otherwise.
This method is only defined if the base container exports the IN_\STR operator.

##### bool name\_equal\_p(name\_t concurrent1, name\_t concurrent2)

Return true if both containers are equal, false otherwise.
This method is only defined if the base container exports the EQUAL operator.

##### bool name\_get\_blocking(value_t *value, name\_t concurrent, key\_t key, bool blocking)

Read the value associated to the key 'key'. 
If it exists, it sets '*value' to it and returns true.
Otherwise if blocking is true, it waits for the data to be filled. 
After the wait, it sets '*value' to it and returns true.
Otherwise if blocking is false, it returns false.
This method is only defined if the base container exports the GET\_KEY operator.

##### bool name\_pop\_blocking(type_t *data, name\_t concurrent, bool blocking)

Pop a value from the container and set '*data' with it.
If the container is not empty, it sets '*data' and return true.
Otherwise if blocking is true, it waits for the data to be pushed. 
After the wait, it sets '*data' to it and returns true.
Otherwise if blocking is false, it returns false.
This method is only defined if the base container exports the POP and TEST\_EMPTY operators.

##### bool name\_pop\_move\_blocking(type_t *data, name\_t concurrent, bool blocking)

Pop a value from the container and initialize & set '*data' with it.
If the container is not empty, it initializes & sets '*data' and return true.
Otherwise if blocking is true, it waits for the data to be pushed. 
After the wait, it initializes & sets '*data' to it and returns true.
Otherwise if blocking is false, it returns false (*data remains uninitialized!).
This method is only defined if the base container exports the POP\_MOVE and TEST\_EMPTY operators.

##### size\_t name\_hash(name\_t concurrent)

Return a value suitable for being a hash of the container.
This method is only defined if the base container exports the HASH operator.



### M-BITSET

This header is for using bitset.

A [bitset](https://en.wikipedia.org/wiki/Bit_array) can be seen 
as a specialized version of an array of bool, where each item takes only 1 bit.
It enables for compact representation of such array.

Example:

	void f(void) {
		bitset_t set;
		bitset_init(set);
		for(int i = 0; i < 100; i ++)
			bitset_push_back(set, i%2);
		bitset_clear(set);
	}


#### methods

The methods are mostly the same than for an array. The following methods are available:

##### bitset\_t

This type defines a dynamic array of bit and is the primary type of the module.

##### bitset\_it\_t

This type defines an iterator over the bitset.

##### void bitset\_init(bitset\_t array)

Initialize the bitset 'array' (aka constructor) to an empty array.

##### void bitset\_init\_set(bitset\_t array, const bitset\_t ref)

Initialize the bitset 'array' (aka constructor) and set it to the value of 'ref'.

##### void bitset\_set(bitset\_t array, const bitset\_t ref)

Set the bitset 'array' to the value of 'ref'.

##### void bitset\_init\_move(bitset\_t array, bitset\_t ref)

Initialize the bitset 'array' (aka constructor) by stealing as many 
resources from 'ref' as possible. Afterwards 'ref' is cleared.

##### void bitset\_move(bitset\_t array, bitset\_t ref)

Set the bitset 'array' by stealing as many resources from 'ref' as possible.
Afterwards 'ref' is cleared.

##### void bitset\_clear(bitset\_t array)

Clear the bitset 'array (aka destructor).

##### void bitset\_clean(bitset\_t array)

Clean the bitset (the bitset becomes empty but remains initialized).

##### void bitset\_push\_back(bitset\_t array, const bool value)

Push a new element into the back of the bitset 'array' 
with the value 'value'.

##### void bitset\_push\_at(bitset\_t array, size\_t key, const bool x)

Push a new element into the position 'key' of the bitset 'array' 
with the value 'value' contained within.
'key' shall be a valid position of the array: 
from 0 to the size of array (included).

##### void bitset\_pop\_back(bool *data, bitset\_t array)

Pop a element from the back of the bitset 'array' and set *data to this value
if data is not NULL (if data is NULL, the popped data is cleared).

##### void bitset\_pop\_at(bool *dest, bitset\_t array, size\_t key)

Set *dest to the value the element 'key' if dest is not NULL,
then remove the element 'key' from the bitset.
'key' shall be within the size of the bitset.

##### bool bitset\_front(const bitset\_t array)

Return the first element of the bitset.
The bitset shall have at least one element.

##### bool bitset\_back(const bitset\_t array)

Return the last element of the bitset.
The bitset shall have at least one element.

##### void bitset\_set\_at(bitset\_t array, size\_t i, bool value)

Set the element 'i' of bitset 'array' to 'value'.
'i' shall be within 0 to the size of the array (excluded).

##### void bitset\_flip\_at(bitset\_t array, size\_t i)

Flip the element 'i' of bitset 'array''.
'i' shall be within 0 to the size of the array (excluded).

##### bool bitset\_get(bitset\_t array, size\_t i)

Return the element 'i' of the bitset.
'i' shall be within 0 to the size of the array (excluded).

##### bool bitset\_empty\_p(const bitset\_t array)

Return true if the bitset is empty, false otherwise.

##### size\_t bitset\_size(const bitset\_t array)

Return the size of the bitset.

##### size\_t bitset\_capacity(const bitset\_t array)

Return the capacity of the bitset.

##### void bitset\_resize(bitset\_t array, size\_t size)

Resize the bitset 'array' to the size 'size' (initializing or clearing elements).

##### void bitset\_reserve(bitset\_t array, size\_t capacity)

Extend or reduce the capacity of the 'array' to a rounded value based on 'capacity'.
If the given capacity is below the current size of the bitset, 
the capacity is set to the size of the bitset.

##### void bitset\_swap(bitset\_t array1, bitset\_t array2)

Swap the bitsets 'array1' and 'array2'.

##### void bitset\_swap\_at(bitset\_t array, size\_t i, size\_t j)

Swap the elements 'i' and 'j' of the bitset 'array'.
'i' and 'j' shall reference valid elements of the array.

##### void bitset\_it(bitset\_it\_t it, bitset\_t array)

Set the iterator 'it' to the first element of 'array'.

##### void bitset\_it\_last(bitset\_it\_t it, bitset\_t array)

Set the iterator 'it' to the last element of 'array'.

##### void bitset\_it\_end(bitset\_it\_t it, bitset\_t array)

Set the iterator 'it' to the end of 'array'.

##### void bitset\_it\_set(bitset\_it\_t it1, bitset\_it\_t it2)

Set the iterator 'it1' to 'it2'.

##### bool bitset\_end\_p(bitset\_it\_t it)

Return true if the iterator doesn't reference a valid element anymore.

##### bool bitset\_last\_p(bitset\_it\_t it)

Return true if the iterator references the last element of the array,
or doesn't reference a valid element.

##### bool bitset\_it\_equal\_p(const bitset\_it\_t it1, const bitset\_it\_t it2)

Return true if both iterators reference the same element.

##### void bitset\_next(bitset\_it\_t it)

Move the iterator 'it' to the next element of the array.

##### void bitset\_previous(bitset\_it\_t it)

Move the iterator 'it' to the previous element of the array.

##### const bool *bitset\_cref(const bitset\_it\_t it)

Return a constant pointer to the element pointed by the iterator.
This pointer remains valid until the array or the iterator
is modified by another method.

##### void bitset\_get\_str(string\_t str, const bitset\_t array, bool append)

Generate a string representation of the bitset 'array' and set 'str' to this
representation (if 'append' is false) or append 'str' with this representation 
(if 'append' is true).
This method is only defined if the header 'm-string.h' was included before
including 'm-bitset.h'

##### bool bitset\_parse\_str(bitset\_t array, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a bitset
and set 'array' to this representation.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void bitset\_out\_str(FILE *file, const bitset\_t array)

Generate a string representation of the bitset 'array' 
and outputs it into the FILE 'file'.

##### void bitset\_in\_str(bitset\_t array, FILE *file)

Read from the file 'file' a string representation of a bitset
and set 'array' to this representation.

##### bool bitset\_equal\_p(const bitset\_t array1, const bitset\_t array2)

Return true if both bitsets 'array1' and 'array2' are equal.

##### size\_t bitset\_hash(const bitset\_t array)

Return an hash value of 'array'.




### M-STRING

This header is for using dynamic [string](https://en.wikipedia.org/wiki/String_(computer_science)).
The size of the string is automatically updated in function of the needs.

Example:

	void f(void) {
		string_t s1;
		string_init (s1);
		string_set_str (s1, "Hello, world!");
		string_clear(s1);
	}

#### methods

The following methods are available:

##### string\_t

This type defines a dynamic string and is the primary type of the module.
The provided methods are just handy wrappers to the C library,
providing few algorithms on its own.

##### STRING_FAILURE

Constant Macro defined as the index value returned in case of error.
(equal as -1U).

##### string\_fgets\_t

This type defines the different enumerate value for the string\_fgets function:

* STRING\_READ\_LINE: read a full line until the EOL character (included),
* STRING\_READ\_PURE\_LINE: read a full line until the EOL character (excluded),
* STRING\_READ\_FILE: read the full file.

##### void string\_init(string\_t str)

Init the string 'str' to an empty string.

##### void string\_clear(string\_t str)

Clear the string 'str' and frees any allocated memory.

##### char *string\_clear\_get\_str(string\_t v)

Clear the string 'str' and returns the allocated array of char,
representing a C string, giving back ownership of this array to the caller.
This array will have to be freed. It can return NULL if no array
was allocated by the string.

##### void string\_clean(string\_t str)

Set the string 'str' to an empty string.

##### size\_t string\_size(const string\_t str)

Return the size in bytes of the string.
It can be also the number of characters of the string
if the encoding type is one character per byte.
If the characters are encoded as UTF8, the function string\_length\_u is preferred.

##### size\_t string\_capacity(const string\_t str)

Return the capacity in bytes of the string.
The capacity is the number of bytes the string accept before a
reallocation of the underlying array of char has to be performed.

##### char string\_get\_char(const string\_t v, size\_t index)

Return the byte 'index' of the string 'v'.
'index' shall be within the allowed range of bytes of the string.

##### bool string\_empty\_p(const string\_t v)

Return true if the string is empty, false otherwise.

##### void string\_reserve(string\_t v, size\_t alloc)

Update the capacity of the string to be able to receive at least
'alloc' bytes.
Calling with 'alloc' lower or equal than the size of the string
enables the function to perform a shrink
of the string to its exact needs. If the string is
empty, it will free the memory.

##### void string\_set\_str(string\_t v, const char str[])

Set the string to the array of char 'str'. 
'str' is supposed to be 0 terminated as any C string.

##### void string\_set\_strn(string\_t v, const char str[], size\_t n)

Set the string to the array of char 'str' by copying at most 'n'
char from the array. 
'str' is supposed to be 0 terminated as any C string.

##### const char* string\_get\_cstr(const string\_t v)

Return a constant pointer to the underlying array of char of the string.
This array of char is terminated by 0, enabling the pointer to be passed
to standard C function.
The pointer remains valid until the string itself remains valid 
and the next call to a function that updates the string.

##### void string\_set (string\_t v1, const string\_t v2)

Set the string 'v1' to the value of the string 'v2'.

##### void string\_set\_n(string\_t v, const string\_t ref, size\_t offset, size\_t length)

Set the string to the value of the string 'ref' by skipping the first 'offset'
char of the array of char of 'ref' and copying at most 'length' char
in the remaining array of characters of 'ref'.
'offset' shall be within the range of index of the string 'ref'.
'ref' and 'v' cannot be the same string.

##### void string\_init\_set(string\_t v1, const string\_t v2)

Initialize 'v1' to the value of the string 'v2'.

##### void string\_init\_set\_str(string\_t v1, const char str[])

Initialize 'v1' to the value of the array of char 'str'.
The array of char shall be terminated with 0.

##### void string\_init\_move(string\_t v1, string\_t v2)

Initialize 'v1' by stealing as most resource from 'v2' as possible
and clear 'v2' afterward.

##### void string\_move(string\_t v1, string\_t v2)

Set 'v1' by stealing as most resource from 'v2' as possible
and clear 'v2' afterward.

##### void string\_swap(string\_t v1, string\_t v2)

Swap the content of both strings.

##### void string\_push\_back (string\_t v, char c)

Append the string with the character 'c'

##### void string\_cat\_str(string\_t v, const char str[])

Append the string 'v' with the array of char 'str'.
The array of char shall be terminated with 0.

##### void string\_cat(string\_t v, const string\_t v2)

Append the string 'v' with the string 'v2'.

##### int string\_cmp\_str(const string\_t v1, const char str[])
##### int string\_cmp(const string\_t v1, const string\_t str)

Perform a byte comparison of both string
by using the strcmp function and return the result of this comparison.

##### bool string\_equal\_str\_p(const string\_t v1, const char str[])

Return true if the string is equal to the array of char, false otherwise.

##### bool string\_equal\_p(const string\_t v1, const string\_t v2)

Return true if both strings are equal, false otherwise.

##### int string\_cmpi\_str(const string\_t v, const char str[])
##### int string\_cmpi(const string\_t v, const string\_t str)

This function compares both strings by ignoring the difference due to the case.
This function doesn't work with UTF-8 strings.
It returns a negative integer if the string is before the array,
0 if there are equal,
a positive integer if the string is after the array.

##### size\_t string\_search\_char (const string\_t v, char c [, size\_t start])

Search for the character 'c' in the string from the offset 'start'.
'start' shall be within the valid ranges of offset of the string.
'start' is an optional argument. If it is not present, the default
value 0 is used instead.
This doesn't work if the function is used as function pointer.
Return the offset of the string where the character is first found,
or STRING_FAILURE otherwise.

##### size\_t string\_search\_rchar (const string\_t v, char c [, size\_t start])

Search backwards for the character 'c' in the string from the offset 'start'.
'start' shall be within the valid ranges of offset of the string.
'start' is an optional argument. If it is not present, the default
value 0 is used instead.
This doesn't work if the function is used as function pointer.
Return the offset of the string where the character is last found,
or STRING_FAILURE otherwise.

##### size\_t string\_search\_str (const string\_t v, char str[] [, size\_t start])
##### size\_t string\_search (const string\_t v, string\_t str [, size\_t start])

Search for the string 'str' in the string from the offset 'start'.
'start' shall be within the valid ranges of offset of the string.
'start' is an optional argument. If it is not present, the default
value 0 is used instead.
This doesn't work if the function is used as function pointer.
Return the offset of the string where 'str' is first found,
or STRING_FAILURE otherwise.

##### size\_t string\_pbrk(const string_t v, const char first\_of[] [, size_t start])

Search for the first occurrence in the string 'v' from the offset 'start' of
any of the bytes in the string 'first\_of'.
'start' shall be within the valid ranges of offset of the string.
'start' is an optional argument. If it is not present, the default
value 0 is used instead.
This doesn't work if the function is used as function pointer.
Return the offset of the string where 'str' is first found,
or STRING_FAILURE otherwise.

##### int string\_strcoll\_str(const string\_t str1, const char str2[])
##### int string\_strcoll(const string\_t str1, const string\_t str2[])

Compare the two strings str1 and str2.
It returns an integer less than, equal to, or greater than zero if 's1' is found,
respectively,  to  be  less than, to match, or be greater than s2. The
comparison is based on strings interpreted as appropriate for the program's
current locale.

##### size\_t string\_spn(const string\_t v1, const char accept[])

Calculate the length (in bytes) of the initial
segment of the string that consists entirely of bytes in accept.
       
##### size\_t string\_cspn(const string\_t v1, const char reject[])

Calculate the length (in bytes) of the initial
segment of the string that consists entirely of bytes not in reject.
       
##### void string\_left(string\_t v, size\_t index)

Keep at most the 'index' left bytes of the string,
terminating the string at the given index.
index can be out of range.

##### void string\_right(string\_t v, size\_t index)

Keep the right part of the string, after the index 'index'.

##### void string\_mid (string\_t v, size\_t index, size\_t size)

Extract the medium string from offset 'index' and up to 'size' bytes.

##### size\_t string\_replace\_str (string\_t v, const char str1[], const char str2[] [, size_t start])
##### size\_t string\_replace (string\_t v, const string\_t str1, const string\_t str2 [ , size_t start])

Replace in the string 'v' from the offset 'start'
the string 'str1' by the string 'str2' once.
Returns the offset of the replacement or STRING_FAILURE if no replacement
was performed.

##### void string\_replace\_at (string\_t v, size\_t pos, size\_t len, const char str2[])

Replace in the string 'v' the sub-string defined as starting from 'pos' and
of size 'len' by the string str2.
It assumes that pos+len is before the end of the string of 'v'.

##### int string\_printf (string\_t v, const char format[], ...)

Set the string 'v' to the formatted string 'format'.
'format' is like the printf function family.

##### int string\_cat\_printf (string\_t v, const char format[], ...)

Appends to the string 'v' the formatted string 'format'.
'format' is like the printf function family.

##### bool string\_fgets(string\_t v, FILE \*f, string\_fgets\_t arg)

Read from the opened file 'f' a stream of characters and set 'v'
with this stream.
It stops after the character end of line
if arg is STRING\_READ\_PURE\_LINE or STRING\_READ\_LINE,
and until the end of the file if arg is STRING\_READ\_FILE.
If arg is STRING\_READ\_PURE\_LINE, the character end of line
is removed from the string.
Return true if something has been read, false otherwise.

##### bool string\_fget\_word (string\_t v, const char separator[], FILE \*f)

Read a word from the file 'f' and set 'v' with this word.
A word is separated from another by the list of characters in the array 'separator'.
(Example: "^ \t.\n").
It is highly recommended for separator to be a constant string.
'separator' shall be at most composed of 100 characters (as bytes).

##### void string\_fputs(FILE \*f, const string\_t v)

Put the string in the file.

##### bool string\_start\_with\_str\_p(const string\_t v, const char str[])
##### bool string\_start\_with\_string\_p(const string_t v, const string_t str)

Return true if the string starts with the same characters than 'str',
false otherwise.

##### bool string\_end\_with\_str\_p(const string\_t v, const char str[])
##### bool string\_end\_with\_string\_p(const string_t v, const string_t str)

Return true if the string ends with the same characters than 'str',
false otherwise.

##### size\_t string\_hash(const string\_t v)

Return a hash of the string.

##### void string\_strim(string\_t v [, const char charTab[]])

Remove from the string any leading or trailing space-like characters
(space or tabulation or end of line).
If 'charTab' is given, it get the list of characters to remove from
this argument.

##### bool string\_oor\_equal\_p(const string\_t v, unsigned char n)

Provide the OOR_EQUAL_P operator of a string.

##### void string\_oor\_set(string\_t v, unsigned char n)

Provide the OOR_SET operator of a string.

##### void string\_get\_str(string\_t v, const string\_t v2, bool append)

Convert a string into a string usable for I/O:
Outputs the input string with quote around,
replacing any \" by \\\" within the string
into the output string.

##### bool string\_parse\_str(string\_t v, const char str[], const char **endp)

Parse the string 'str' that is assumed to be a string representation of a string
and set 'v' to this representation.
This method is only defined if the type of the element defines a PARSE\_STR method itself.
It returns true if success, false otherwise.
If endp is not NULL, it sets '*endp' to the pointer of the first character not
decoded by the function.

##### void string\_out\_str(FILE *f, const string\_t v)

Write a string into a FILE:
Outputs the input string while quoting around,
replacing any \" by \\\" within the string.

##### bool string\_in\_str(string\_t v, FILE *f)

Read a string from a FILE. The string shall have be written
by string\_out\_str.
It returns true if it has successfully parsed the string,
false otherwise. In this case, the position within the FILE
is undefined.

##### string\_unicode\_t

Define a type suitable to store a unicode character.

##### string\_it\_t

Define an iterator over the string, enabling to
iterate the string over UTF8 encoded character.

##### void string\_it(string\_it\_t it, const string\_t str)

Initialize the iterator 'it' to iterate over the string 'str'
over UTF8 encoded character.

##### bool string\_end\_p (string\_it\_t it)

Return true if the iterator has reached the end of the string,
false otherwise.

##### void string\_next (string\_it\_t it)

Move the iterator to the next UTF8 encoded character.
It is assumed that string\_end\_p has been called at least once
per UTF8 character before.

##### string\_unicode\_t string\_get_cref (const string\_it\_t it)

Return the unicode character associated to the UTF8 encoded character
pointer by the iterator.
It is assumed that string\_end\_p has been called at least once
per UTF8 character before.
It returns -1 in case of error in decoding the UTF8 string.

##### void string\_push\_u (string\_t str, string\_unicode\_t u)

Push the unicode character 'u' into the string 'str'
encoding it as a UTF8 encoded characters.

##### size\_t string\_length\_u(string\_t str)

Return the number of UTF8 encoded characters in the string.

##### bool string\_utf8\_p(string\_t str)

Return true if the string is a valid UTF8,
false otherwise.
It doesn't check for unique canonical form for UTF8 string,
so it may report 'true' whereas the string is not strictly conforming.

##### STRING\_CTE(string)

Macro to convert a constant array string into a temporary string\_t variable
suitable only for being called within a function.

##### STRING_OPLIST

The oplist of a string\_t

##### BOUNDED_STRING_DEF(name, size)

aka char[N+1]
TODO: Document the API.


### M-CORE

This header is the internal core of M\*LIB, providing a lot of functionality 
by extending a lot the preprocessing capability.
Working with these macros is not easy and the developer needs to know
how the macro preprocessing works.
It also adds the needed macro for handling the oplist.
As a consequence, it is needed by all other header files.

Some macros are using recursivity to work.
This is not an easy feat to do as it needs some tricks to work (see
reference).
This still work well with only one major limitation: it can not be chained.
For example, if MACRO is a macro implementing recursivity, then
MACRO(MACRO()) won't work.


Example:

	M_MAP(f, 1, 2, 3, 4)
	M_REDUCE(f, g, 1, 2, 3, 4)
	M_SEQ(1, 20, f)
	
#### Compiler Macros

The following compiler macros are available:

##### M\_ASSUME(cond)

M\_ASSUME is equivalent to assert, but gives hints to compiler
about how to optimize the code if NDEBUG is defined.

##### M\_LIKELY(cond) / M\_UNLIKELY(cond)

M\_LIKELY / M\_UNLIKELY gives hints on the compiler of the likelihood
of the given condition.

#### Preprocessing macro extension

##### M\_MAX\_NB\_ARGUMENT

Maximum number of argument that can be handled by this header.

##### M\_C(a,b), M\_C3(a,b,c), M\_C4(a,b,c,d)

Return a symbol corresponding to the concatenation of the input arguments.

##### M\_INC(number)

Increment the number given as argument (from [0..52]) and return 
a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).
If number is not within the range, the behavior is undefined.

##### M\_DEC(number)

Decrement the number given as argument (from [0..52]) and return 
a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).
If number is not within the range, the behavior is undefined.

##### M\_ADD(x, y)

Return x+y (resolution is performed at preprocessing time).
x and y shall be within [0..52].

##### M\_SUB(x, y)

Return x-y (resolution is performed at preprocessing time).
x and y shall be within [0..52] and x >= y.

##### M\_RET\_ARG1(arglist,...) / M\_RET\_ARGN(...)

Return the argument 1 of the given arglist (respectively 2 and N, with which
is within [2..53]).
The argument shall exist in the arglist.

##### M\_SKIP\_ARGS(N,...)

Skip the Nth first arguments of the argument list.
N can be within [0..52].

##### M\_KEEP\_ARGS(N,...)

Keep the Nth first arguments of the argument list.
N can be within [0..52].

##### M\_MID\_ARGS(first, len,...)

Keep the medium arguments of the argument list,
starting from the 'first'-th one and up to 'len' arguments.
first and len can be within [0..52].


##### M\_GET\_AT(array, index)

Return the index 'index' of the "array" 'array'.
array in this context is a list of arguments encapsulated with parenthesis,
and is not a true C array.
Return the pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

Example:

        M_GET_AT((f_0,f_1,f_2),1)


##### M\_BOOL(cond)

Convert an integer or a symbol into 0 (if 0) or 1 (if not 0 or symbol unknown).
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

##### M\_INV(cond)

Inverse 0 into 1 and 1 into 0. It is undefined if cond is not 0 or 1
(use M\_BOOL to convert). 
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

##### M\_AND(cond1, cond2)

Perform a logical 'and' between cond1 and cond2. 
cond1 and cond2 shall be 0 or 1 otherwise it is undefined
(You shall use M\_bool otherwise).
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

##### M\_OR(cond1, cond2)

Perform a logical 'or' between cond1 and cond2. 
cond1 and cond2 shall be 0 or 1 otherwise it is undefined.
(You shall use M\_bool otherwise).
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

##### M\_IF(cond)(action\_if\_true, action\_if\_false)

Return the pre-processing token 'action_if_true' if 'cond' is true, action\_if\_false otherwise (meaning it is evaluated
at macro processing stage, not at compiler stage).
cond shall be 0 or 1 otherwise it is undefined.

##### M\_COMMA\_P(arglist)

Return 1 if there is a comma inside the argument list, 0 otherwise.
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

##### M\_AS\_STR(expression)

Return the string representation of the evaluated expression.
NOTE: Need to be used with M\_APPLY to defer the evaluation.

##### M\_EMPTY\_P(expression)

Return 1 if the argument 'expression' is 'empty', 0 otherwise.
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

##### M\_DEFERRED\_COMMA

Return a comma ',' at a later phase of the macro processing steps.

##### M\_IF\_EMPTY(cond)(action\_if\_true, action\_if\_false)

Return the pre-processing token 'action_if_true' if 'cond' is empty, action\_if\_false otherwise (meaning it is evaluated
at macro processing stage, not at compiler stage).
cond shall be 0 or 1 otherwise it is undefined.

##### M\_PARENTHESIS\_P(expression)

Return 1 if the argument 'expression' starts a parenthesis and ends it
(like '(...)'), 0 otherwise.
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

##### M\_DELAY1(expr) / M\_DELAY2(expr) / M\_DELAY3(expr) / M\_DELAY4(expr) / M\_ID

Delay the evaluation by 1, 2, 3 or 4 steps.
This is necessary to write macros that are recursive.
The argument is a macro-function that has to be deferred.
M\_ID is an equivalent of M\_DELAY1.

##### M\_EVAL(expr)

Perform a complete stage evaluation of the given expression,
removing recursive expression within it.
Only ONE M\_EVAL expression is expected in the evaluation chain.
Can not be chained.

##### M\_APPLY(func, args...)

Apply 'func' to '(args...) ensuring
that a() isn't evaluated until all 'args' have been also evaluated.
It is used to delay evaluation.

##### M\_MAP(func, args...)

Apply 'func' to each argument of the 'args...' list of argument.

##### M\_MAP\_C(func, args...)

Apply 'func' to each argument of the 'args...' list of argument,
putting a comma between each expanded 'func(argc)'

##### M\_MAP2(func, data, args...)

Apply 'func' to each couple '(data, argument)' 
with argument an element of the 'args...' list.

##### M\_MAP2\_c(func, data, args...)

Apply 'func' to each couple '(data, argument)' 
with argument an element of the 'args...' list,
putting a comma between each expanded 'func(argc)'

##### M\_MAP\_PAIR(func, args...)

Map a macro to all given pair of arguments (Using recursivity).
Can not be chained.

##### M\_REDUCE(funcMap, funcReduce, args...)

Map the macro funcMap to all given arguments 'args'
and reduce all theses computation with the macro 'funcReduce'.
Example: M_REDUCE(f, g, a, b, c) ==> g( f(a), g( f(b), f(c))

##### M\_REDUCE2(funcMap, funcReduce, data, args...)

Map the macro funcMap to all pair (data, arg) of the given argument list 'args' 
and reduce all theses computation with the macro 'funcReduce'.
Do not use recursivity.

##### M\_SEQ(init, end, macro, data)

Generate a sequence of number from 'init' to 'end'
and apply to the macro the pair '(data, num)' for each number 'num'.

##### M\_EAT(...)

Clobber the input, whatever it is.

##### M\_NARGS(args...)

Return the number of argument of the given list.
Doesn't work for empty argument.

##### M\_IF\_NARGS\_EQ1(argslist)(action\_if\_one\_arg, action\_otherwise)

Return the pre-processing token 'action\_if\_one\_arg' if 'argslist' has only one argument, action\_otherwise otherwise
(meaning it is evaluated at macro processing stage, not at compiler stage).

##### M\_IF\_NARGS\_EQ2(argslist)(action\_if\_two\_arg, action\_otherwise)

Return the pre-processing token 'action\_if\_two\_arg' if 'argslist' has two arguments, action\_otherwise otherwise
(meaning it is evaluated at macro processing stage, not at compiler stage).

##### M\_IF\_DEBUG(action)

Return the pre-processing token 'action' if the build is compiled in debug mode (i.e. NDEBUG is undefined).

##### M\_IF\_DEFAULT1(default_value, argumentlist)

Helper macro to redefine a function with a default value.
If there is only one variable as the argument list, print
the variable of the argument list then ', value',
instead only print the argument list (and so two arguments).
Example:
    int f(int a, int b);
    #define f(...) M_APPLY(f, M_IF_DEFAULT1(0, __VA_ARGS__))
This need to be called within a M_APPLY macro.
   
##### M\_DEFAULT\_ARGS(nbExpectedArg, (defaultArgumentlist), argumentList )

Helper macro to redefine a function with one or more default values.
defaultArgumentlist is a list of the default value to complete the
list argumentList to reach the number nbExpectedArg arguments.
Example:
    int f(int a, int b, long p, void *q);
    #define f(...) f(M_DEFAULT_ARGS(4, (0, 1, NULL), __VA_ARGS__))
The last 3 arguments have their default value as 0 (for b),
1 (for p) and NULL (for q).

##### M\_NOTEQUAL(x, y)

Return 1 if x != y, 0 otherwise (resolution is performed at preprocessing time).
x and y shall be within the maximum argument value.

##### M\_EQUAL(x, y)

Return 1 if x == y, 0 otherwise (resolution is performed at preprocessing time).
x and y shall be within the maximum argument value.

##### M\_INVERT(args...)

Reverse the argument list. For example, if args was a,b,c, it return c,b,a.

### C11 Macro

Theses macros are only valid if the program is built in C11 mode:

##### M\_PRINTF\_FORMAT(x)

Return the printf format associated to the type of 'x'.
'x' shall be printable with printf.

##### M\_PRINT\_ARG(x)

Print using printf the variable 'x'. The format of 'x' is deduced provided that it is a standard numerical C type.

##### M\_FPRINT\_ARG(file, x)

Print into a file 'file' using fprintf the variable 'x'. The format of 'x' is deduced provided that it is a standard numerical C type.

##### M\_GET\_STRING\_ARG(string,x,append)

Print into the string\_t 'string' the variable 'x'. 
The format of 'x' is deduced provided that it is a standard numerical C type.
It needs the header 'm-string.h' for working (this macro is only a 
wrapper around it).

##### M\_PRINT(args...)

Print using printf all the variable in 'args'. 
The format of the arguments are deduced provided that it is a standard numerical C type.

##### M\_FPRINT(file, args...)

Print into a file 'file' using fprintf all the variables in 'args'. 
The format of the arguments are deduced provided that it is a standard numerical C type.

##### M\_AS\_TYPE(type, x)

Within a C11 \_Generic statement, all expressions shall be valid C
expression even if the case if always false, and is not executed.
This can seriously limit the _Generic statement.
This macro overcomes this limitation by returning :

* either the input 'x' if it is of type 'type',
* or the value 0 view as a type 'type'.

So the returned value is **always** of type 'type' and is safe in a \_Generic statement.


### C Macro

Theses macros expand their code at compilation level:

##### M\_MIN(x, y)
 
Return the minimum of 'x' and 'y'. x and y shall not have any side effect.

##### M\_MAX(x, y)
 
Return the maximum of 'x' and 'y'. x and y shall not have any side effect.

##### M\_POWEROF2\_P(n)
 
Return true if 'n' is a power of 2. n shall not have any side effect.

##### M\_SWAP(type, a, b)
 
Swap the values of 'a' and 'b'. 'a' and 'b' are of type 'type'. a and b shall not have any side effect.

##### M\_ASSIGN\_CAST(type, a)
 
Check if 'a' can be assigned to a temporary of type 'type' and returns this temporary.
If it cannot, the compilation failed.

##### M\_CONST\_CAST(type, a)
 
Check if 'a' can be properly casted to (const type *) and returns this casted pointer if possible.
If it cannot, the compilation failed.

##### M\_TYPE\_FROM\_FIELD(type, ptr, fieldType, field)
 
Assuming 'ptr' is a pointer to a fieldType object that is stored within a structure of type 'type'
at the position 'field', it returns a pointer to the structure.

#### HASH Functions

##### M\_HASH\_SEED --> size\_t

User shall overwrite this macro by a random seed (of type size_t) before including
the header m-core.h o that all hash functions will use this variable
as a seed for the hash functions. If no user macro is defined,
the default is to expand it to 0,
making all hash computations predictable.

##### M\_HASH\_DECL(hash)

Declare and initialize a new hash computation, named 'hash' that
is an integer.

##### M\_HASH\_UP(hash, value)

Update the 'hash' variable with the given 'value'
by incorporating the 'value' within the 'hash'. 'value' can be up to a 'size_t' 
variable.

##### uint32_t m_core_rotl32a (uint32_t x, uint32_t n)
##### uint64_t m_core_rotl64a (uint64_t x, uint32_t n)

Perform a rotation of 'n' bits of the input 'x'.
n shall be within 1 and the number of bits of the type minus 1.

##### uint64_t m_core_roundpow2(uint64_t v)

Round to the next highest power of 2.

##### unsigned int m_core_clz32(uint32\_t limb)
##### unsigned int m_core_clz64(uint64\_t limb)

Count the number of leading zero and return it.
limb can be 0.

##### size\_t m\_core\_hash (const void *str, size\_t length)

Compute the hash of the binary representation of the data pointer by 'str'
of length 'length'. 'str' shall have the same alignment restriction
than a 'size\_t'.

#### OPERATORS Functions

##### M\_GET\_INIT oplist
##### M\_GET\_INIT\_SET oplist
##### M\_GET\_INIT\_MOVE oplist
##### M\_GET\_SET oplist
##### M\_GET\_MOVE oplist
##### M\_GET\_SWAP oplist
##### M\_GET\_CLEAR oplist
##### M\_GET\_NEW oplist
##### M\_GET\_DEL oplist
##### M\_GET\_REALLOC oplist
##### M\_GET\_FREE oplist
##### M\_GET\_MEMPOOL oplist
##### M\_GET\_MEMPOOL\_LINKAGE oplist
##### M\_GET\_HASH oplist
##### M\_GET\_EQUAL oplist
##### M\_GET\_CMP oplist
##### M\_GET\_UPDATE oplist
##### M\_GET\_TYPE oplist
##### M\_GET\_SUBTYPE oplist
##### M\_GET\_OPLIST oplist
##### M\_GET\_SORT oplist
##### M\_GET\_IT\_TYPE oplist
##### M\_GET\_IT\_FIRST oplist
##### M\_GET\_IT\_LAST oplist
##### M\_GET\_IT\_END oplist
##### M\_GET\_IT\_SET oplist
##### M\_GET\_IT\_END\_P oplist
##### M\_GET\_IT\_LAST\_P oplist
##### M\_GET\_IT\_EQUAL\_P oplist
##### M\_GET\_IT\_NEXT oplist
##### M\_GET\_IT\_PREVIOUS oplist
##### M\_GET\_IT\_REF oplist
##### M\_GET\_IT\_CREF oplist
##### M\_GET\_IT\_REMOVE oplist
##### M\_GET\_IT\_INSERT oplist
##### M\_GET\_ADD oplist
##### M\_GET\_SUB oplist
##### M\_GET\_MUL oplist
##### M\_GET\_DIV oplist
##### M\_GET\_CLEAN oplist
##### M\_GET\_PUSH oplist
##### M\_GET\_POP oplist
##### M\_GET\_REVERSE oplist
##### M\_GET\_GET\_STR oplist
##### M\_GET\_OUT\_STR oplist
##### M\_GET\_IN\_STR oplist
##### M\_GET\_SEPARATOR oplist
##### M\_GET\_EXT\_ALGO oplist
##### M\_GET\_INC\_ALLOC oplist
##### M\_GET\_OOR\_SET oplist
##### M\_GET\_OOR\_EQUAL oplist

Return the associated method to the given operator within the given oplist.

##### M\_BOOL\_OPLIST

Default oplist for C standard boolean.

##### M\_DEFAULT\_OPLIST

Default oplist for C standard types (int & float)

##### M\_ENUM\_OPLIST(type, init_value)

Default oplist for a C standard enumerate of type 'type',
and of initial value 'init_value'

##### M\_CSTR\_OPLIST

Default oplist for the C type const char *, seen as a constant string.

##### M\_POD\_OPLIST

Default oplist for a structure C type without any init & clear
prerequisites (plain old data).

##### M\_A1\_OPLIST

Default oplist for an array of size 1 of a structure C type without any init & clear
prerequisites.

##### M\_EMPTY\_OPLIST

Default oplist for a type that shall not be instanciated.
Each method does nothing.

##### M\_CLASSIC\_OPLIST(name)

Create the oplist with the operators using the pattern 'name', i.e.
name##\_init, name##\_init\_set, name##\_set, name##\_clear, name##\_t

##### M\_OPFLAT oplist

Remove the parenthesis around an oplist.

##### M\_OPCAT(oplist1,oplist2)

Concat two oplists in one. 'oplist1''s operators will have higher priority to 'oplist2'

##### M\_OPEXTEND(oplist, ...)

Extend an oplist with the given list of operators.
Theses new operators will have higher priority than the ones
in the given oplist.

##### M\_TEST\_METHOD\_P(method, oplist)

Test if a method is present in an oplist. Return 0 or 1.

##### M\_IF\_METHOD(method, oplist) 

Perform a preprocessing M\_IF, if the method is present in the oplist.
Example: M\_IF\_METHOD(HASH, oplist)(define function that uses HASH method, ) 

##### M\_IF\_METHOD\_BOTH(method, oplist1, oplist2)     

Perform a preprocessing M\_IF if the method exists in both oplist.
Example: M\_IF\_METHOD\_BOTH(HASH, oplist1, oplist2) (define function , )

##### M\_IF\_METHOD\_ALL(method, ...)

Perform a preprocessing M\_IF if the method exists for all oplist.
Example: M\_IF\_METHOD\_ALL(HASH, oplist1, oplist2, oplist3) (define function, ) 

##### M_IPTR

By putting this after a method for an operator in the oplist,
it specifies that the first argument of the method shall be a pointer
to the destination type, rather than the type.

##### M\_DO\_INIT\_MOVE(oplist, dest, src)
##### M\_DO\_MOVE(oplist, dest, src)

Perform an INIT\_MOVE/MOVE if present, or emulate it otherwise.
Note: default methods for INIT\_MOVE/MOVE are not robust enough yet.

##### M\_GLOBAL\_OPLIST(a)

Check if a is an oplist, and return a
or if a symbol composed of M_OPL_##a() is defined as an oplist, and returns it
otherwise return a.
In short, if a global oplist is defined for the argument, it returns it
otherwise it returns the argument.
Global oplist is limited to typedef types.
   
##### M_GLOBAL_OPLIST_OR_DEF(a)

Check if a a symbol composed of M_OPL_##a() is defined as an oplist, and returns its
name otherwise return a name that will expand to M_DEFAULT_OPLIST.
The return value shall be evaluated once again to get the oplist
(this is needed due to technical reasons).

    M_GLOBAL_OPLIST_OR_DEF(mpz_t)()

In short, if a global oplist is defined for the argument, it returns it
otherwise it returns the default oplist.
Global oplist is limited to typedef types.
       

#### Syntax enhancing

These macros are quite useful to lighten the C style and make full use of the library.

##### M\_EACH(item, container, oplist|type)

This macro iterates over the given 'container' of oplist 'oplist'
(or of type 'type' with a globally registered oplist) and sets 'item' 
to reference one different element of the container for each iteration of
the loop.

'item' is a created pointer variable to the contained type
of the container, only available within the 'for' loop.
There can only have one M\_EACH per line.
It shall be used after the for C keyword to perform a loop over the container.
The order of the iteration depends on the given container.

Example: 
         for M_EACH(item, list, LIST_OPLIST) { action; }

##### M\_LET(var1[,var2[,...]], oplist|type)

This macro defines the variable 'var1'(resp. var2, ...) 
of oplist 'oplist' (or of type 'type' with a globally registered oplist). 
It initializes 'var1' (resp. var2, ...) by calling the initialization method,
and clears 'var1' (resp. var2, ...) by calling the clear method
when the bracket associated to the M\_LET go out of scope.

If 'var1' (resp. var2, ...) has the form (v1, va_list...),
then the variable 'v1' will be initialized with the 
contains of 'va_list...' using the specialized initializer operator INIT\_WITH
and not the empty initializer INIT operator.

Example:

     M_LET(a, STRING_OPLIST) { do something with a }  or
     M_LET(a, b, c, STRING_OPLIST) { do something with a, b & c }

NOTE: The user code can not perform a return or a goto outside the {}
otherwise the clear code of the object won't be called .
However, you can use the break instruction to quit the block.


#### Memory macros

All these macro can be overridden before including the header m-core.h
so that they can be adapted to a particular memory pool.


##### type *M\_MEMORY\_ALLOC (type)

Return a pointer to a new allocated non-initialized object of type 'type'.
In case of allocation error, it returns NULL.
The default used function is the 'malloc' function of the LIBC.


##### void M\_MEMORY\_DEL (type *ptr)

Delete the cleared object pointed by the pointer 'ptr'
that was previously allocated by the macro M\_MEMORY\_ALLOC.
'ptr' can not be NULL.
The default used function is the 'free' function of the LIBC.


##### type *M\_MEMORY\_REALLOC (type, ptr, number)

Return a pointer to an array of 'number' objects of type 'type'
'ptr' is either NULL (in which the array is allocated), 
or a pointer returned from a previous call of M\_MEMORY\_REALLOC 
(in which case the array is reallocated).
The objects are not initialized, nor the state of previous objects changed
(in case of reallocation).
The address of the previous objects may have moved and the MOVE operator
is not used in this case.
In case of allocation error, it returns NULL.
The default used function is the 'realloc' function of the LIBC.


##### void M\_MEMORY\_FREE (type *ptr)

Delete the cleared object pointed by the pointer 'ptr'.
The pointer was previously allocated by the macro M\_MEMORY\_REALLOC.
'ptr' can not be NULL.
The default used function is the 'free' function of the LIBC.


##### void M\_MEMORY\_FULL (size_t size)

This macro is called when a memory error has been detected and shall be raised.
The parameter 'size' is what was tried to be allocated.
The default is to abort the execution.
The macro can :

* abort the execution,
* throw an exception (In this case, the state of the object is unchanged),
* set a global error variable and return.

NOTE: The last two cases are not properly fully supported yet.
Throwing an exception is not fully supported yet.


##### void M\_ASSERT\_INIT\_FAILURE(expression, object_name)

This macro is called when an assertion used in an initialization context
is called to check the good creation of an object (like a thread, a mutex)
that string name is 'object_name'. 
If the given 'expression' is false, the execution shall be aborted.
The assertion is kept in programs built in release mode.
The default is to abort the execution.


#### Generic Serialization objects.

A [serialization](https://en.wikipedia.org/wiki/Serialization) is the process of translating
data structures into a format that can be stored or transmitted.
When the resulting format is reread and translated, 
it creates a semantically identical clone of the original object. 

A generic serialization object is an object that takes a C object (boolean, integer, float, 
structure, union, pointer, array, list, hashmap, ...) and outputs it into a serialization way through
the following defined interface that defined the format of the serialization and where it is 
physically output. 

The M\*LIB containers define the methods \_out\_serial and \_in\_serial
if the underlying types define theses methods over the operators OUT\_SERIAL and IN\_SERIAL.
The methods for the basic C types (int, float, ...) are also defined (but only
in C11 due to technical limitation).

The methods \_out\_serial and \_in\_serial will request the generic serialization object
to serialize their current object:

* calling the interface of the generic serialization object if needed, 
* performing recursive call to serialize the contained-objects.

The final output of this serialization can be a FILE or a string.
Two kinds of serialization objects exist: one for input and one
for output. The serialization is fully recursive and can be seen as a collection of token.
The only constraint is that what is output by the output serialization object
shall be able to be parsed by the input serialization object.


The serialization input object is named as m\_serial\_read\_t, defined in m-core.h as a structure
(of array of size 1) with the following fields:

* m\_interface: a pointer to the constant m\_serial\_read\_interface\_s structure that defines all
methods that operate on this object to parse it. The instance has to be customized for the needs of the
wanted serialization.
* data: a table of M\_SERIAL\_MAX\_DATA\_SIZE of C types (boolean, integer, size or pointer).
This data is used to store the needed data for the methods.

This is pretty much like a pure virtual interface object in C++. The interface has to defines
the following fields with the following definition:

*  read\_boolean: 
   Read from the stream 'serial' a boolean. 
   Set '*b' with the boolean value if it succeeds.
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise
* read\_integer:
   Read from the stream 'serial' an integer that can be represented with 'size_of_type' bytes.
   Set '*i' with the integer value if it succeeds. 
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise.
* read\_float:
   Read from the stream 'serial' a float that can be represented with 'size_of_type' bytes.
   Set '*r' with the float value if it succeeds. 
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise.
* read\_string:
   Read from the stream 'serial' a string.
   Set 's' with the string if it succeeds. 
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise
* read\_array\_start:
   Start reading from the stream 'serial' an array (which is defined as a sequential collection of object).
   Set '*num' with the number of elements, or 0 if it is not known.
   Initialize the object 'local' so that it can be used by the serialization object to serialize the array. 
   ('local' is an unique local serialization object of the array).
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds and the parsing of the array can continue (the array is not empty),
   M\_SERIAL\_OK\_DONE if it succeeds and the array ends (the array is empty),
   M\_SERIAL\_FAIL otherwise.
* read\_array\_next:
   Continue reading from the stream 'serial' an array using 'local' to load / save data if needed.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds and the array can continue (the array end is still not reached),
   M\_SERIAL\_OK\_DONE if it succeeds and the array ends,
   M\_SERIAL\_FAIL otherwise.
* read\_map_start:
   Start reading from the stream 'serial' a map (an associative array).
   Set '*num' with the number of elements, or 0 if it is not known.
   Initialize 'local' so that it can be used to serialize the map. 
   ('local' is an unique serialization object of the map).
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds and the map continue,
   M\_SERIAL\_OK\_DONE if it succeeds and the map ends (the map is empty),
   M\_SERIAL\_FAIL otherwise
* read\_map\_value:
   Continue reading from the stream 'serial' the value separator token (if needed)
   using 'local' to load / save data if needed.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds and the map continue,
   M\_SERIAL\_FAIL otherwise
* read\_map_next:
   Continue reading from the stream 'serial' a map.
   using 'local' to load / save data if needed.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds and the map continue,
   M\_SERIAL\_OK\_DONE if it succeeds and the map ends,
   M\_SERIAL\_FAIL otherwise
* read\_tuple\_start:
   Start reading a tuple from the stream 'serial'.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds and the tuple continues,
   M\_SERIAL\_FAIL otherwise
* read\_tuple\_id:
   Continue reading a tuple (a structure) from the stream 'serial'.
   using 'local' to load / save data if needed.
   Set '*id' with the corresponding index of the table 'field_name[max]'
   associated to the parsed field in the stream.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds and the tuple continues,
   Return M\_SERIAL\_OK\_DONE if it succeeds and the tuple ends,
   M\_SERIAL\_FAIL otherwise
* read\_variant\_start:
   Start reading a variant (an union) from the stream 'serial'.
   Set '*id' with the corresponding index of the table 'field_name[max]'
   associated to the parsed field in the stream.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds and the variant continues,
   Return M\_SERIAL\_OK\_DONE if it succeeds and the variant ends(variant is empty),
   M\_SERIAL\_FAIL otherwise
* read\_variant\_end:
   End reading a variant from the stream 'serial'.
   Return M\_SERIAL\_OK\_DONE if it succeeds and the variant ends,
   M\_SERIAL\_FAIL otherwise

The serialization output object is named as m\_serial\_write\_t, defined in m-core.h as a structure
(of array of size 1) with the following fields:

* m\_interface: a pointer to the constant m\_serial\_write\_interface\_s structure that defines all
methods that operate on this object to output it. The instance has to be customized for the needs of the
wanted serialization.
* data: a table of M\_SERIAL\_MAX\_DATA\_SIZE of C types (boolean, integer, size or pointer).
This data is used to store the needed data for the methods.

This is pretty much like a pure virtual interface object in C++. The interface has to defines
the following fields with the following definition:

* write\_boolean:
   Write the boolean 'b' into the serial stream 'serial'.
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write_\integer:
   Write the integer 'data' of 'size_of_type' bytes into the serial stream 'serial'.
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_float:
   Write the float 'data' of 'size_of_type' bytes into the serial stream 'serial'.
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_string:
   Write the null-terminated string 'data' of 'length' characters into the serial stream 'serial'.
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_array\_start:
   Start writing an array of 'number_of_elements' objects into the serial stream 'serial'.
   If 'number_of_elements' is 0, then either the array has no data,
   or the number of elements of the array is unknown.
   Initialize 'local' so that it can be used to serialize the array 
   (local is an unique serialization object of the array).
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_array\_next:
   Write an array separator between elements of an array into the serial stream 'serial' if needed.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_array\_end:
   End the writing of an array into the serial stream 'serial'.
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_map\_start:
   Start writing a map of 'number_of_elements' pairs of objects into the serial stream 'serial'.
   If 'number_of_elements' is 0, then either the map has no data,
   or the number of elements is unknown.
   Initialize 'local' so that it can be used to serialize the map 
   (local is an unique serialization object of the map).
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_map\_value:
   Write a value separator between element of the same pair of a map into the serial stream 'serial' if needed.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_map\_next:
   Write a map separator between elements of a map into the serial stream 'serial' if needed.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_map\_end:
   End the writing of a map into the serial stream 'serial'.
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_tuple\_start:
   Start writing a tuple into the serial stream 'serial'.
   Initialize 'local' so that it can serial the tuple 
   (local is an unique serialization object of the tuple).
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_tuple\_id:
   Start writing the field named field_name[index] of a tuple into the serial stream 'serial'.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_tuple\_end:
   End the write of a tuple into the serial stream 'serial'.
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_variant\_start:
   Start writing a variant into the serial stream 'serial'.
   If index <= 0, the variant is empty.
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise 
   Otherwise, the field 'field_name[index]' will be filled.
   Return M\_SERIAL\_OK\_CONTINUE if it succeeds, M\_SERIAL\_FAIL otherwise */
* write\_variant\_end:
   End Writing a variant into the serial stream 'serial'. 
   Return M\_SERIAL\_OK\_DONE if it succeeds, M\_SERIAL\_FAIL otherwise */

M\_SERIAL\_MAX\_DATA\_SIZE can be overloaded before including any M\*LIB header
to increase the size of the generic object. The maximum default size is 4 fields.

The full C definition are:

        // Serial return code
        typedef enum m_serial_return_code_e {
         M_SERIAL_OK_DONE = 0, M_SERIAL_OK_CONTINUE = 1, M_SERIAL_FAIL = 2
        } m_serial_return_code_t;
        
        // Different types of types that can be stored in a serial object to represent it.
        typedef union m_serial_ll_u {
          bool   b;
          int    i;
          size_t s;
          void  *p;
        } m_serial_ll_t;
        
        /* Object to handle the construction of a serial write/read of an object
           that needs multiple calls (array, map, ...)
           It is common to all calls to the same object */
        typedef struct m_serial_local_s {
         m_serial_ll_t data[M_SERIAL_MAX_DATA_SIZE];
        } m_serial_local_t[1];
        
        // Object to handle the generic serial read of an object.
        typedef struct m_serial_read_s {
         const struct m_serial_read_interface_s *m_interface;
         m_serial_ll_t data[M_SERIAL_MAX_DATA_SIZE];
        } m_serial_read_t[1];
        
        // Interface exported by the serial read object.
        typedef struct m_serial_read_interface_s {
          m_serial_return_code_t (*read_boolean)(m_serial_read_t serial,bool *b);
          m_serial_return_code_t (*read_integer)(m_serial_read_t serial, long long *i, const size_t size_of_type);
          m_serial_return_code_t (*read_float)(m_serial_read_t serial, long double *f, const size_t size_of_type);
          m_serial_return_code_t (*read_string)(m_serial_read_t serial, struct string_s *s); 
          m_serial_return_code_t (*read_array_start)(m_serial_local_t local, m_serial_read_t serial, size_t *s);
          m_serial_return_code_t (*read_array_next)(m_serial_local_t local, m_serial_read_t serial);
          m_serial_return_code_t (*read_map_start)(m_serial_local_t local, m_serial_read_t serial, size_t *);
          m_serial_return_code_t (*read_map_value)(m_serial_local_t local, m_serial_read_t serial);
          m_serial_return_code_t (*read_map_next)(m_serial_local_t local, m_serial_read_t serial);
          m_serial_return_code_t (*read_tuple_start)(m_serial_local_t local, m_serial_read_t serial);
          m_serial_return_code_t (*read_tuple_id)(m_serial_local_t local, m_serial_read_t serial, const char *const field_name [], const int max, int *id);
          m_serial_return_code_t (*read_variant_start)(m_serial_local_t local, m_serial_read_t serial, const char *const field_name[], const int max, int*id);
          m_serial_return_code_t (*read_variant_end)(m_serial_local_t local, m_serial_read_t serial);
        } m_serial_read_interface_t;
        
        
        // Object to handle the generic serial write of an object.
        typedef struct m_serial_write_s {
         const struct m_serial_write_interface_s *m_interface;
         m_serial_ll_t data[M_SERIAL_MAX_DATA_SIZE];
        } m_serial_write_t[1];
        
        // Interface exported by the serial write object.
        typedef struct m_serial_write_interface_s {
          m_serial_return_code_t (*write_boolean)(m_serial_write_t serial, const bool b);
          m_serial_return_code_t (*write_integer)(m_serial_write_t serial, const long long i, const size_t size_of_type);
          m_serial_return_code_t (*write_float)(m_serial_write_t serial,  const long double f, const size_t size_of_type);
          m_serial_return_code_t (*write_string)(m_serial_write_t serial, const char s[], size_t length); 
          m_serial_return_code_t (*write_array_start)(m_serial_local_t local, m_serial_write_t serial, const size_t number_of_elements);
          m_serial_return_code_t (*write_array_next)(m_serial_local_t local, m_serial_write_t serial);
          m_serial_return_code_t (*write_array_end)(m_serial_local_t local, m_serial_write_t serial);
          m_serial_return_code_t (*write_map_start)(m_serial_local_t local, m_serial_write_t serial,  const size_t number_of_elements);
          m_serial_return_code_t (*write_map_value)(m_serial_local_t local, m_serial_write_t serial);
          m_serial_return_code_t (*write_map_next)(m_serial_local_t local, m_serial_write_t serial);
          m_serial_return_code_t (*write_map_end)(m_serial_local_t local, m_serial_write_t serial);
          m_serial_return_code_t (*write_tuple_start)(m_serial_local_t local, m_serial_write_t serial);
          m_serial_return_code_t (*write_tuple_id)(m_serial_local_t local, m_serial_write_t serial, const char * const field_name[], const int max, const int index);
          m_serial_return_code_t (*write_tuple_end)(m_serial_local_t local, m_serial_write_t serial);
          m_serial_return_code_t (*write_variant_start)(m_serial_local_t local, m_serial_write_t serial,  const char * const field_name[], const int max, const int index);
          m_serial_return_code_t (*write_variant_end)(m_serial_local_t local, m_serial_write_t serial);
        } m_serial_write_interface_t;

See [m-serial-json.h](#m-serial-json) for example of use.


### M-MUTEX

This header is for providing very thin layer around OS implementation of threads, conditional variables and mutex.
It has back-ends for WIN32, POSIX thread or C11 thread.

It was needed due to the low adoption rate of the C11 equivalent layer.

It uses the C11 threads.h if possible.
If the C11 implementation does not respect the C standard
(i.e. the compiler targets C11 mode
the  \_\_STDC\_NO\_THREADS\_\_ macro is not defined
but the header threads.h is not available or not working),
then the user shall define manually the M\_USE\_C11\_NO\_THREADS
macro before including any M\*LIB header to disable it, so that
M\*LIB can select another implementation.

Example:

	m_thread_t idx_p;
	m_thread_t idx_c;

	m_thread_create (idx_p, conso_function, NULL);
	m_thread_create (idx_c, prod_function, NULL);
	m_thread_join (idx_p;
	m_thread_join (idx_c);

#### Attributes

The following attributes are available:

##### M\_THREAD\_ATTR

An attribute used for qualifying a variable to be thread specific.
It is an alias for \_\_thread, \_Thread\_local or \_\_declspec( thread )
depending on the used backend.


#### methods

The following methods are available:

##### m\_mutex\_t

A type representing a mutex.

##### void m\_mutex\_init(mutex)

Initialize the variable mutex of type m\_mutex\_t. 
If the initialization fails, the program aborts.

##### void m\_mutex\_clear(mutex)

Clear the variable mutex of type m\_mutex\_t. 
If the variable is not initialized, the behavior is undefined.

##### void m\_mutex\_lock(mutex)

Lock the variable mutex of type m\_mutex\_t for exclusive use.
If the variable is not free, it will wait indefinitely until it is.
If the variable is not initialized, the behavior is undefined.

##### void m\_mutex\_unlock(mutex)

Unlock the variable mutex of type m\_mutex\_t for exclusive use.
If the variable is not locked, the behavior is undefined.
If the variable is not initialized, the behavior is undefined.

##### M\_LOCK\_DECL(name)

Define the lock 'name'. This shall be called in the global space (reserved for global variables).

##### M\_LOCK(name)

Use the lock 'name': the encapsulation instructions are protected by the lock.
Example:

        M_LOCK_DECL(n_lock);
        unsigned long n = 0;
        void f(void) {
             M_LOCK(n_lock) {
               n ++;
             }
        }

#### m\_cond\_t

A type representing a conditional variable, used within a mutex section.

##### void m\_cond\_init(m\_cond\_t cond)

Initialize the conditional variable cond of type m\_cond\_t. 
If the initialization failed, the program aborts.

##### void m\_cond\_clear(m\_cond\_t cond)

Clear the variable cond of type m\_cond\_t. 
If the variable is not initialized, the behavior is undefined.

##### void m\_cond\_signal(m\_cond\_t cond)

Within a mutex exclusive section,
signal that the event associated to the variable cond of type m\_cond\_t 
has occurred to at least a single thread.
If the variable is not initialized, the behavior is undefined.

##### void m\_cond\_broadcast(m\_cond\_t cond)

Within a mutex exclusive section,
signal that the event associated to the variable cond of type m\_cond\_t 
has occurred to all waiting threads.
If the variable is not initialized, the behavior is undefined.

##### void m\_cond\_wait(m\_cond\_t cond, m\_mutex\_t mutex)

Within a mutex exclusive section defined by mutex,
wait indefinitely for the event associated to the variable cond of type m\_cond\_t
to occur.
IF multiple threads wait for the same event, which thread to awoken
is not specified.
If any variable is not initialized, the behavior is undefined.

#### m\_thread\_t

A type representing an id of a thread.

##### void m\_thread\_create(m\_thread\_t thread, void (\*function)(void\*), void \*argument)

Create a new thread and set the it of the thread to 'thread'.
The new thread run the code function(argument) with
argument a 'void \*' and function taking a 'void \*' and returning
nothing.
If the initialization fails, the program aborts.

##### void m\_thread\_join(m\_thread\_t thread)

Wait indefinitely for the thread 'thread' to exit.


### M-WORKER

This header is for providing a pool of workers.
Each worker run in a separate thread and can handle work orders
sent by the main threads. A work order is a computation task.
Work orders are organized around synchronization points.
Workers can be disabled globaly to ease debugging.

This implements parallelism just like OpenMP or CILK++.

Example:

        worker_t worker;
        worker_init(worker, 0, 0, NULL);
        worker_sync_t sync;
        worker_start(sync, worker);
        void *data = ...;
        worker_spawn (sync, taskFunc, data);
        taskFunc(otherData);
        worker_sync(sync);
        

Currently, there is no support for:

* throw exceptions by the worker tasks,
* unbalanced design: the worker tasks shall not lock a mutex without closing it (same for other synchronization structures).

Thread Local Storage variables have to be reinitialized properly
with the reset function. This may result in subtle difference between the
serial code and the parallel code.

#### Global Conditional Code

##### M\_USE\_WORKER

This macro indicates if the multi-thread code shall be used (=1) or not (=0).
It can be overloaded by the user code before including any headers of M\*LIB.
If it is not defined, the default is to use the multi-thread code.

#### methods

The following methods are available:

#### worker\_t

A pool of worker.

#### worker\_sync\_t

A synchronization point between workers.

#### void worker\_init(worker\_t worker[, unsigned int numWorker, unsigned int extraQueue, void (*resetFunc)(void), void (*clearFunc)(void) ])

Initialize the pool of workers 'worker' with 'numWorker' workers.
if 'numWorker' is 0, then it will detect how many core is available on the
system and creates as much workers as there are cores.

Before starting any work, the function 'resetFunc'
is called by the worker to reset its state (or call nothing if the function
pointer is NULL).

'extraQueue' is the number of tasks that can be accepted by the work order
queue in case if there is no worker available.

Before terminating, each worker will call 'clearFunc' if the function is not NULL.

Default values are respectively 0, 0, NULL and NULL.

#### void worker\_clear(worker\_t worker)

Request terminaison to the pool of workers, and wait for them to terminate.
It is undefined if there is any work order in progress.

#### void worker\_start(worker\_block\_t syncBlock, worker\_t worker)

Start a new synchronization block for a pool of work orders
linked to the pool of worker 'worker'.

#### void worker\_spawn(worker\_block\_t syncBlock, void (*func)(void *data), void *data)

Register the work order 'func(data)' to the the synchronization point 'syncBlock'.
If no worker is available (and no extraQueue), the work order 'func(data)' will be handled
by the caller. Otherwise the work order 'func(data)' will be handled
by an asynchronous worker and the function immediately returns.

#### bool worker\_sync\_p(worker\_block\_t syncBlock)

Test if all work orders registered to this synchronization point are
terminated (true) or not (false). 

#### void worker\_sync(worker\_block\_t syncBlock)

Wait for all work orders registered to this synchronization point 'syncBlock'
to be terminated.

#### size\_t worker\_count(worker\_t worker)

Return the number of workers of the pool.


#### WORKER\_SPAWN(syncBlock, input, core, output)

Request the work order 'core' to the synchronization point syncBlock.
If no worker is available (and no extra queue), the work order 'core' will be handled
by the caller. Otherwise the work order 'core' will be handled
by an asynchronous worker.

'core' is any C code that doesn't break the control flow (you
cannot use return / goto / break to go outside the flow).
'input' is the list of local input variables of the 'core' block within "( )".
'output' is the list of local output variables of the 'core' block within "( )".
These lists shall be exhaustive to capture all needed variables.

This macro needs either GCC (for nested function) or CLANG (for blocks)
or a C++11 compiler (for lambda and functional) to work.

NOTE1: Even if nested functions are used for GCC, it doesn't generate
a trampoline and the stack doesn't need to be executable as all variables are captured by the library.

NOTE2: For CLANG, you need to add -fblocks to CFLAGS and -lBlocksRuntime to LIB (See CLANG manual).

NOTE3: It will generate warnings about shadowed variables. There is no way to avoid this.

NOTE4: arrays and not trivially movable object are not supported as input / output variables due to 
current technical limitations.


### M-ATOMIC

This header goal is to provide the C header 'stdatomic.h'
to any C compiler (C11 or C99 compliant) or C++ compiler.
If available, it uses the C11 header stdatomic.h,
otherwise if the compiler is a C++ compiler,
it uses the header 'atomic' and imports all definition
into the global namespace (this is needed because the
C++ standard doesn't support officially the stdatomic header,
resulting in broken compilation when building C code with
a C++ compiler).
Otherwise it provides a non-thin emulation of atomic
using mutex.


### M-ALGO

This header is for generating generic algorithm to containers.

#### ALGO\_DEF(name, container_oplist)

Define the available algorithms for the container which oplist is container_oplist.
The defined algorithms depend on the availability of the methods of the containers
(For example, if there no CMP operator, there is no MIN method defined).

Example:

	ARRAY_DEF(array_int, int)
	ALGO_DEF(array_int, ARRAY_OPLIST(array_int))
	void f(void) {
		array_int_t l;
		array_int_init(l);
		for(int i = 0; i < 100; i++)
			array_int_push_back (l, i);
		array_int_push_back (l, 17);
		assert( array_int_contains(l, 62) == true);
		assert( array_int_contains(l, -1) == false);
		assert( array_int_count(l, 17) == 2);
		array_int_clear(l);
	}

#### Created methods

The following methods are automatically and properly created by the previous macros. In the following methods, name stands for the name given to the macro that is used to identify the type.

In the following descriptions, it\_t is an iterator of the container
container\_t is the type of the container and type\_t is the type
of object contained in the container.

##### void name\_find(it\_t it, const container\_t c, const type\_t data)

Search for the first occurrence of 'data' within the container.
Update the iterator with the found position or return the end iterator. 
The search is linear.

##### void name\_find\_again(it\_t it, const type\_t data)

Search from the position 'it' for the next occurrence of 'data' within the container.
Update the iterator with the found position or return end iterator. 
The search is linear.

##### void name\_find\_if(it\_t it, const container\_t c, bool (*pred)(type\_t const))

Search for the first occurrence within the container than matches 
the predicate 'pred'
Update the iterator with the found position or return end iterator. 
The search is linear.

##### void name\_find\_again\_if(it\_t it, bool (*pred)(type\_t const))

Search from the position 'it' for the next occurrence matching the predicate
'pred' within the container.
Update the iterator with the found position or return end iterator. 
The search is linear.

##### void name\_find\_last(it\_t it, const container\_t c, const type\_t data)

Search for the last occurrence of 'data' within the container.
Update the iterator with the found position or return end iterator. 
The search is linear and can be backward or forwards depending
on the possibility of the container.

##### bool name\_contains(const container\_t c, const type\_t data)

Return true if 'data' is within the container, false otherwise.
The search is linear.

##### size\_t name\_count(const container\_t c, const type\_t data)

Return the number of occurrence of 'data' within the container.
The search is linear.

##### size\_t name\_count\_if(const container\_t c, bool (*pred)(type\_t const data))

Return the number of occurrence matching the predicate 'pred' within the container.
The search is linear.

##### void name\_mismatch(it\_t it1, it\_t it2, const container\_t c1, const container\_t c2)

Returns the first mismatching pair of elements of the two containers 'c1' and 'c2'.

##### void name\_mismatch\_again(it\_t it1, it\_t it2)

Returns the next mismatching pair of elements of the two containers 
from the position 'it1' of container 'c1' and 
from the position 'it2' of container 'c2'.

##### void name\_mismatch\_if(it\_t it1, it\_t it2, const container\_t c1, const container\_t c2, bool (*cmp)(type\_t const, type\_t const))

Returns the first mismatching pair of elements of the two containers using
the provided comparison 'cmp'.

##### void name\_mismatch\_again\_if(it\_t it1, it\_t it2, bool (*cmp)(type\_t const, type\_t const))

Returns the next mismatching pair of elements of the two containers using
the provided comparison 'cmp'
from the position 'it1' and
from the position 'it2'.

##### void name\_fill(container\_t c, type\_t value)

Set all elements of the container 'c' to 'value'.

##### void name\_fill\_n(container\_t c, size\_t n, type\_t value)

Set the container to 'n' elements equal to 'value'.
This method is defined only if the container exports a PUSH method.

##### void name\_fill\_a(container\_t c, type\_t value, type\_t inc)

Set all elements of the container 'c' to 'value + i * inc'
with i = 0.. size(c)
This method is defined only if the base type exports an ADD method.
This method is defined only if the container exports a PUSH method.

##### void name\_fill\_an(container\_t c, size\_t n, type\_t value)

Set the container to 'n' elements to 'value + i * inc'
with i = 0..n
This method is defined only if the base type exports an ADD method.
This method is defined only if the container exports a PUSH method.

##### void name\_for\_each(container\_t c, void (*func)(type\_t))

Apply the function 'func' to each element of the container 'c'.
The function may transform the element provided it doesn't reallocate the
object and if the container supports iterating over modifiable elements.

##### void name\_transform(container\_t d, container\_t c, void (*func)(type\_t *out, const type\_t in))

Apply the function 'func' to each element of the container 'c'
and push the result into the container 'd' so that 'd = func(c)'

'func' shall output in the initialized object 'out'
the transformed value of the contant object 'in'.
Afterwards 'out' is pushed moved into 'd'.

This method is defined only if the base type exports an INIT method.
This method is defined only if the container exports a PUSH\_MOVE method.
'c' and 'd' cannot be the same containers.

##### void name\_reduce(type\_t *dest, const container\_t c, void (*func)(type\_t *, type\_t const))

Perform a reduction using the function 'func' to the elements of the container 'c'.
The final result is stored in '*dest'.
If there is no element, '*dest' is let unmodified.

##### void name\_map\_reduce(type\_t *dest, const container\_t c, void (*redFunc)(type\_t *, type\_t const), void *(mapFunc)(type\_t *, type\_t const))

Perform a reduction using the function 'redFunc' 
to the transformed elements of the container 'c' using 'mapFunc'.
The final result is stored in '*dest'.
If there is no element, '*dest' is let unmodified.

##### bool name\_any\_of\_p(const container\_t c, void *(func)(const type\_t))

Test if any element of the container 'c' matches the predicate 'func'.

##### bool name\_all\_of\_p(const container\_t c, void *(func)(const type\_t))

Test if all elements of the container 'c' match the predicate 'func'.

##### bool name\_none\_of\_p(const container\_t c, void *(func)(const type\_t))

Test if no element of the container 'c' match the predicate 'func'.

##### type\_t *name\_min(const container\_t c)

Return a reference to the minimum element of the container 'c'.
Return NULL if there is no element.
This method is available if the CMP operator has been defined.

##### type\_t *name\_max(const container\_t c)

Return a reference to the maximum element of the container 'c'.
Return NULL if there is no element.
This method is available if the CMP operator has been defined.

##### void name\_minmax(type\_t **min, type\_t **max, const container\_t c)

Stores in '*min' a reference to the minimum element of the container 'c'.
Stores in '*max' a reference to the minimum element of the container 'c'.
Stores NULL if there is no element.
This method is available if the CMP operator has been defined.

##### void name\_uniq(container\_t c)

Assuming the container 'c' has been sorted, 
remove any duplicate elements of the container.
This method is available if the CMP and IT\_REMOVE operators have been defined.

##### void name\_remove\_val(container\_t c, type\_t val)

Remove all elements equal to 'val' of the container.
This method is available if the CMP and IT\_REMOVE operators have been defined.

##### void name\_remove\_if(container\_t c, bool (*func)(type\_t) )

Remove all elements matching the given condition (function func() returns true) of the container.
This method is available if the CMP and IT\_REMOVE operators have been defined.

##### void name\_add(container\_t dest, const container\_t value)

For each element of the container 'dest',
add the corresponding element of the container 'dest'
up to the minimum size of the containers.
This method is available if the ADD operator has been defined.

##### void name\_sub(container\_t dest, const container\_t value)

For each element of the container 'dest',
sub the corresponding element of the container 'dest'
up to the minimum size of the containers.
This method is available if the SUB operator has been defined.

##### void name\_mul(container\_t dest, const container\_t value)

For each element of the container 'dest',
mul the corresponding element of the container 'dest'
up to the minimum size of the containers.
This method is available if the MUL operator has been defined.

##### void name\_div(container\_t dest, const container\_t value)

For each element of the container 'dest',
div the corresponding element of the container 'dest'
up to the minimum size of the containers.
This method is available if the DIV operator has been defined.

##### bool void name\_sort\_p(const container\_t c)

Test if the container 'c' is sorted (=true) or not (=false).
This method is available if the CMP operator has been defined.

##### bool name\_sort\_dsc\_p(const container\_t c)

Test if the container 'c' is reverse sorted (=true) or not (=false)
This method is available if the CMP operator has been defined.

##### void void name\_sort(container\_t c)

Sort the container 'c'.
This method is available if the CMP operator has been defined.
The used algorithm depends on the available operators:
if a specialized SORT operator is defined for the container, it is used.
if SPLICE\_BACK and SPLICE\_AT operates are defined, a merge sort is defined,
if IT\_PREVIOUS is defined, an insertion sort is used,
otherwise a selection sort is used.

##### bool name\_sort\_dsc(const container\_t c)

Reverse sort the container 'c'.
This method is available if the CMP operator has been defined.
The used algorithm depends on the available operators:
if a specialized SORT operator is defined, it is used.
if SPLICE\_BACK and SPLICE\_AT operates are defined, a merge sort is defined,
if IT\_PREVIOUS is defined, an insertion sort is used,
otherwise a selection sort is used.

##### void name\_sort\_union(container\_t c1, const container\_t c2)

Assuming both containers 'c1' and 'c2' are sorted, 
perform an union of the containers in 'c1'.
This method is available if the IT\_INSERT operator is defined.

##### void name\_sort\_dsc\_union(container\_t c1, const container\_t c2)

Assuming both containers 'c1' and 'c2' are reverse sorted, 
perform an union of the containers in 'c2'.
This method is available if the IT\_INSERT operator is defined.

##### void name\_sort\_intersect(container\_t c1, const container\_t c2)

Assuming both containers 'c1' and 'c2' are sorted, 
perform an intersection of the containers in 'c1'.
This method is available if the IT\_REMOVE operator is defined.

##### void name\_sort\_dsc\_intersect(container\_t c, const container\_t c)

Assuming both containers 'c1' and 'c2' are reverse sorted, 
perform an intersection of the containers in 'c1'.
This method is available if the IT\_REMOVE operator is defined.

##### void name\_split(container\_t c, const string\_t str, const char sp)

Split the string 'str' around the character separator 'sp'
into a set of string in the container 'c'.
This method is defined if the base type of the container is a string\_t type,

##### void name\_join(string\_t dst, container\_t c, const string\_t str)

Join the string 'str' and all the strings of the container 'c' into 'dst'.
This method is defined if the base type of the container is a string\_t type,

#### ALGO\_FOR\_EACH(container, oplist, func[, arguments..])

Apply the function 'func' to each element of the container 'container' of oplist 'oplist' :
     
     for each item in container do
     	 func([arguments,] item)

The function 'func' is a method that takes as argument an object of the
container and returns nothing. It may update the object provided it
doesn't reallocate it.


#### ALGO\_TRANSFORM(contDst, contDstOplist, contSrc, contSrcOplist, func[, arguments..])

Apply the function 'func' 
to each element of the container 'contSrc' of oplist 'contSrcOplist' 
and store its outptut in the container 'contDst' of oplist 'contDstOplist'
so that 'contDst = func(contSrc)'. Exact algorithm is:
     
     clean(contDst)
     for each item in  do
         init(tmp)
     	 func(tmp, item, [, arguments])
         push_move(contDst, tmp)

The function 'func' is a method that takes 
as first argument the object to put in the new container,
and as seconf argument the object in the source container.


#### ALGO\_EXTRACT(containerDest, oplistDest, containerSrc, oplistSrc[, func[, arguments..]])

Extract the items of the container 'containerSrc' of oplist 'oplistSrc'
into the 'containerDest' of oplist 'oplistDest': 
     
     CLEAN (containerDest)
     for each item in containerSrc do
     	 [ if func([arguments,] item) ] 
	      	 Push item in containerDest

The optional function 'func' is a predicate that takes as argument an object of the
container and returns a boolean that is true if the object has to be added
to the other container.

Both containers shall either provide PUSH method, or SET\_KEY method.


#### ALGO\_REDUCE(dest, container, oplist, reduceFunc[, mapFunc[, arguments..])

Reduce the items of the container 'container' of oplist 'oplist'
into a single element by applying the reduce function:

     dest = reduceFunc(mapFunc(item[0]), reduceFunc(..., reduceFunc(mapFunc(item[N-2]), mapFunc(item[N-1]))))


'mapFunc' is a method which prototype is:
    
    void mapFunc(dest, item)

with both 'dest' & 'item' that are of the same type than the one of
the container. It transforms the 'item' into another form that is suitable
for the 'reduceFunc'.
If 'mapFunc' is not specified, identity will be used instead.

'reduceFunc' is a method which prototype is:
 
     void reduceFunc(dest, item)

It integrates the new 'item' into the partial 'sum' 'dest.

The reduce function can be the special keywords 'add', 'sum', 'and', 'or'
'product', 'mul' 
in which case the special function performing a sum/sum/and/or/mul/mul
operation will be used.

'dest' can be either the variable (in which case 'dest' is
assumed to be of type equivalent to the elements of the container)
or a tuple ('var', 'oplist') with 'var' being the variable name and 'oplist' its oplist
(with TYPE, INIT, SET methods). The tuple may be needed if the map function
transform a type into another.


#### ALGO\_INSERT\_AT(containerDst, containerDstOPLIST, position, containerSrc, containerSrcOPLIST)

Insert into the container 'contDst' at position 'position' all the values
of container 'contSrc'.



### M-FUNCOBJ

This header is for generating Function Object. 
A [function object](https://en.wikipedia.org/wiki/Function_object)
is a construct an object to be invoked 
or called as if it were an ordinary function, usually with the same 
syntax (a function parameter that can also be a function)
but with additional "within" parameters.


#### FUNC\_OBJ\_ITF\_DEF(name, retcode\_type[, type\_of\_param1, type\_of\_param 2, ...])
Define a function object interface of name 'name' 
emulating a function pointer returning retcode type (can be void),
and with as inputs the list of types of paramN:

    retcode_type function(type_of_param1, type_of_param 2, ...)

An interface cannot be used without an instance that implements this interface.
It will define the following type and functions:

##### name\_t

Name of the interface type representing an interfac to the function object. 
It cannot be used to instance an object and
shall only be used to create instances of this interface.

##### retcode\_type name\_call(name\_t interface, type\_of\_param1, type\_of\_param 2, ...)

The call function of the interface object.
It will call the implemented callback of the instance of this interface.


#### FUNC\_OBJ\_INS\_DEF(name, interface_name, (param_name_1, ...), { callback_core }, (self_member1, self_type1[, self_oplist1]), ...)
Define a function object instance of name 'name' 
implementing the interface 'interface_name'
The function is defined as per :
- the function prototype of the inherited interface,
- the parameters of the function are named as per the list param_name_list,
- the core of the function shall be defined in callback_core
  within the callback_core, members of the function object can be
  accessed through the pointer named 'self' to access the member 
  attributes of the object, and the parameter names of the function
  as per the param_name_list.
- optionals member attributes of the function object can be defined 
  after the core (just like for tuple & variant):
  Each parameter is defined as pair: (name, type [, oplist])

    interface_name_retcode_type function(interface_name_ *self, interface_name_type_of_param1 param_name_1, interface_name_type_of_param 2 param_name_2, ...) {
        callback_core
    }

##### name\_t

Name of a particular instance to the interface of the Function Object interface\_name.

##### void name\_init(name\_t self)

Initialize the instance of the function with default value.
This method is defined only if all member attributes export an INIT method.

##### void name\_init\_with(name\_t self, self\_type1 a1, self\_type2 a2, ...)

Initialize the instance of the function with the given values of the member attributes.

##### void name\_clear(name\_t self)

Clear the instance of the function.

##### interface\_name\_t name\_as\_interface(name\_t self)

Return the instance object view as the generic interface.


### M-MEMPOOL

This header is for generating specialized and optimized memory pools:
it will generate specialized functions to allocate and free only one kind of an object.
The mempool functions are not specially thread safe for a given mempool,
but the mempool variable can have the attribute M\_THREAD\_ATTR
so that each thread has its own instance of the mempool.

The memory pool has to be initialized and cleared like any other variable.
Clearing the memory pool will free all the memory that has been allocated 
within this memory pool.


#### MEMPOOL\_DEF(name, type)

Generate specialized functions & types prefixed by 'name' to alloc & free an object of type 'type'.

Example:

	MEMPOOL_DEF(mempool_uint, unsigned int)

        mempool_uint_t m;

	void f(void) {
          mempool_uint_init(m);
          unsigned int *p = mempool_uint_alloc(m);
          *p = 17;
          mempool_uint_free(m, p);
          mempool_uint_clear(m);
        }

#### Created methods

The following methods are automatically and properly created by the previous macros. In the following methods, name stands for the name given to the macro that is used to identify the type.

##### name\_t

The type of a mempool.

##### void name\_init(name\_t m)

Initialize the mempool 'm'.

##### void name\_clear(name\_t m)

Clear the mempool 'm'.
All allocated objects associated to the this mempool that weren't explicitly freed
will be deleted too (without calling their clear method).

##### type *name\_alloc(name\_t m)

Create a new object of type 'type' and return a new pointer to the uninitialized object.

##### void name\_free(name\_t m, type *p)

Free the object 'p' created by the call to name\_alloc.
The clear method of the type is not called.



### M-SERIAL-JSON

This header is for defining an instance  of the serial interface
supporting import (and export) of a container
from (to) to a file in [JSON](https://en.wikipedia.org/wiki/JSON) format.
It uses the generic serialization ability of M\*LIB for this purpose,
providing a specialization of the serialization for JSON over FILE*.

Another way of seeing it is that you define your data structure 
using M\*LIB containers (building it using basic types, strings,
tuples, variants, array, dictionaries, ...) and then you
can import / export your data structure for free in JSON format.

If the JSON file cannot be translated into the data structure, a failure
error is reported (M\_SERIAL\_FAIL). For example, if some new fields are present
in the JSON file but not in the data structure.
On contrary, if some fields are missing (or in a different order) in the JSON
file, the parsing will still succeed (object fields are unmodified
except for new sub-objects, for which default value are used).

It is fully working with C11 compilers only.

##### m\_serial\_json\_write\_t

A synonym of m\_serial\_write\_t with a global oplist registered
for use with JSON.

##### void m\_serial\_json\_write\_init(m\_serial\_write\_t serial, FILE *f)

Initialize the 'serial' object to be able to output in JSON format to the file 'f'.
The file 'f' has to remained open in 'wt' mode while the 'serial' is not cleared
otherwise the behavior of the object is undefined.

##### void m\_serial\_json\_write\_clear(m\_serial\_write\_t serial)

Clear the serialization object 'serial'.

##### m\_serial\_json\_read\_t

A synonym of m\_serial\_read\_t with a global oplist registered
for use with JSON.

##### void m_serial_json_read_init(m_serial_read_t serial, FILE *f)

Initialize the 'serial' object to be able to parse in JSON format from the file 'f'.
The file 'f' has to remained open in 'rt' mode while the 'serial' is not cleared
otherwise the behavior of the object is undefined.

##### void m_serial_json_read_clear(m_serial_read_t serial)

Clear the serialization object 'serial'.

Example:

        // Define a structure of two fields.
        TUPLE_DEF2(my,
                   (value, int),
                   (name, string_t)
                   )
        #define M_OPL_my_t() TUPLE_OPLIST(my, M_DEFAULT_OPLIST, STRING_OPLIST )
        
        // Output in JSON file the structure my_t
        void output(my_t el1)
        {
          m_serial_write_t out;
          m_serial_return_code_t ret;
        
          FILE *f = fopen ("data.json", "wt");
          if (!f) abort();
          m_serial_json_write_init(out, f);
          ret = my2_out_serial(out, el1);
          assert (ret == M_SERIAL_OK_DONE);
          m_serial_json_write_clear(out);
          fclose(f);
        }
        
        // Get from JSON file the structure my_t
        void input(my_t el1)
        {
          m_serial_read_t  in;
          m_serial_return_code_t ret;
        
          f = fopen ("data.json", "rt");
          if (!f) abort();
          m_serial_json_read_init(in, f);
          ret = my2_in_serial(el2, in);
          assert (ret == M_SERIAL_OK_DONE);
          m_serial_json_read_clear(in);
          fclose(f);
        }
        

### M-SERIAL-BIN

This header is for defining an instance of the serial interface
supporting import (and export) of a container
from (to) to a file in an ad-hoc binary format.
This format only supports the current system and cannot be used to communicate 
across multiple systems (endianess, size of types are typically not abstracted
by this format).

It uses the generic serialization ability of M\*LIB for this purpose,
providing a specialization of the serialization for JSON over FILE*.

It is fully working with C11 compilers only.

##### void m\_serial\_bin\_write\_init(m\_serial\_write\_t serial, FILE *f)

Initialize the 'serial' object to be able to output in BIN format to the file 'f'.
The file 'f' has to remained open in 'wb' mode while the 'serial' is not cleared
otherwise the behavior of the object is undefined.

##### void m\_serial\_bin\_write\_clear(m\_serial\_write\_t serial)

Clear the serialization object 'serial'.

##### void m_serial_bin_read_init(m_serial_read_t serial, FILE *f)

Initialize the 'serial' object to be able to parse in BIN format from the file 'f'.
The file 'f' has to remained open in 'rb' mode while the 'serial' is not cleared
otherwise the behavior of the object is undefined.

##### void m_serial_bin_read_clear(m_serial_read_t serial)

Clear the serialization object 'serial'.



# Licence

All files of M\*LIB are distributed under the following licence.

Copyright (c) 2017-2020, Patrick Pelissier
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
+ Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
+ Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

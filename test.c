# 1 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 324 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c" 2
# 23 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h" 1 3
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h" 1 3
# 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\sal.h" 1 3
# 2974 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\sal.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\concurrencysal.h" 1 3
# 2975 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\sal.h" 2 3
# 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h" 2 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\vadefs.h" 1 3
# 18 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\vadefs.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h" 1 3
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h" 3
#pragma pack(push, 8)
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h" 3
#pragma warning(push)
#pragma warning(disable: 4514 4820)
# 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h" 3
 typedef unsigned __int64 uintptr_t;
# 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h" 3
        typedef char* va_list;
# 155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h" 3
    void __cdecl __va_start(va_list* , ...);
# 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h" 3
#pragma warning(pop)
#pragma pack(pop)
# 19 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\vadefs.h" 2 3
# 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h" 2 3

#pragma warning(push)
#pragma warning(disable: 4514 4820)
# 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h" 3
#pragma pack(push, 8)
# 193 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h" 3
 typedef unsigned __int64 size_t;
    typedef __int64 ptrdiff_t;
    typedef __int64 intptr_t;
# 209 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h" 3
    typedef _Bool __vcrt_bool;
# 228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h" 3
    typedef unsigned short wchar_t;
# 338 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h" 3
    void __cdecl __security_init_cookie(void);





        void __cdecl __security_check_cookie( uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure( uintptr_t _StackCookie);



extern uintptr_t __security_cookie;







#pragma pack(pop)

#pragma warning(pop)
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h" 2 3

#pragma pack(push, 8)
# 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h" 3
 typedef _Bool __crt_bool;
# 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h" 3
    __declspec(dllimport) void __cdecl _invalid_parameter(
                   wchar_t const*,
                   wchar_t const*,
                   wchar_t const*,
                   unsigned int,
                   uintptr_t
        );


__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
               wchar_t const* _Expression,
               wchar_t const* _FunctionName,
               wchar_t const* _FileName,
               unsigned int _LineNo,
               uintptr_t _Reserved);
# 511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h" 3
typedef int errno_t;
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
typedef long __time32_t;
typedef __int64 __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
                        int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data* locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;
# 552 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h" 3
        typedef __time64_t time_t;
# 562 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h" 3
    typedef size_t rsize_t;
# 2011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h" 3
#pragma pack(push, 8)
# 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h" 3
 __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }





    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
# 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 2 3

#pragma pack(push, 8)
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
 typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;


__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);
# 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) wint_t __cdecl fgetwc(
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);


    __declspec(dllimport) wint_t __cdecl fputwc(
                wchar_t _Character,
                FILE* _Stream);


    __declspec(dllimport) wint_t __cdecl _fputwchar(
             wchar_t _Character
        );


    __declspec(dllimport) wint_t __cdecl getwc(
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl getwchar(void);




    __declspec(dllimport) wchar_t* __cdecl fgetws(
                                     wchar_t* _Buffer,
                                     int _BufferCount,
                                     FILE* _Stream
        );


    __declspec(dllimport) int __cdecl fputws(
                wchar_t const* _Buffer,
                FILE* _Stream
        );



    __declspec(dllimport) wchar_t* __cdecl _getws_s(
                                     wchar_t* _Buffer,
                                     size_t _BufferCount
        );
# 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) wint_t __cdecl putwc(
                wchar_t _Character,
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl putwchar(
             wchar_t _Character
        );


    __declspec(dllimport) int __cdecl _putws(
               wchar_t const* _Buffer
        );


    __declspec(dllimport) wint_t __cdecl ungetwc(
                wint_t _Character,
                FILE* _Stream
        );


    __declspec(dllimport) FILE * __cdecl _wfdopen(
               int _FileHandle,
               wchar_t const* _Mode
        );

                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfopen(
               wchar_t const* _FileName,
               wchar_t const* _Mode
        );


    __declspec(dllimport) errno_t __cdecl _wfopen_s(
                                  FILE** _Stream,
                                  wchar_t const* _FileName,
                                  wchar_t const* _Mode
        );


    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfreopen(
                wchar_t const* _FileName,
                wchar_t const* _Mode,
                FILE* _OldStream
        );


    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
                                  FILE** _Stream,
                                  wchar_t const* _FileName,
                                  wchar_t const* _Mode,
                                  FILE* _OldStream
        );


    __declspec(dllimport) FILE* __cdecl _wfsopen(
               wchar_t const* _FileName,
               wchar_t const* _Mode,
               int _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
                   wchar_t const* _ErrorMessage
        );




        __declspec(dllimport) FILE* __cdecl _wpopen(
                   wchar_t const* _Command,
                   wchar_t const* _Mode
            );



    __declspec(dllimport) int __cdecl _wremove(
               wchar_t const* _FileName
        );





    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
                   wchar_t const* _Directory,
                   wchar_t const* _FilePrefix
        );





    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
                                     wchar_t* _Buffer,
                                     size_t _BufferCount
        );







    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wtmpnam( wchar_t *_Buffer);
# 221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
                wchar_t _Character,
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
                wchar_t _Character,
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
                wint_t _Character,
                FILE* _Stream
        );
# 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __inline int __cdecl _vfwprintf_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vfwprintf(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_l(_Stream, _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vfwprintf_s_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vfwprintf_s(
                                          FILE* const _Stream,
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }





    __inline int __cdecl _vfwprintf_p_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vfwprintf_p(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vwprintf(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vwprintf_s_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vwprintf_s(
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        }





    __inline int __cdecl _vwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vwprintf_p(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _fwprintf_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl fwprintf(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l(_Stream, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _fwprintf_s_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl fwprintf_s(
                                          FILE* const _Stream,
                                          wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vfwprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }





    __inline int __cdecl _fwprintf_p_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _fwprintf_p(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _wprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl wprintf(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _wprintf_s_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl wprintf_s(
                                          wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }





    __inline int __cdecl _wprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _wprintf_p(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
# 702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                               unsigned __int64 _Options,
                                               FILE* _Stream,
                                               wchar_t const* _Format,
                                               _locale_t _Locale,
                                               va_list _ArgList
        );


    __inline int __cdecl _vfwscanf_l(
                FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vfwscanf(
                FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_l(_Stream, _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vfwscanf_s_l(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vfwscanf_s(
                                          FILE* const _Stream,
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }




    __inline int __cdecl _vwscanf_l(
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vwscanf(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vwscanf_s_l(
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vwscanf_s(
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        }




                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                               FILE* const _Stream,
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                                     FILE* const _Stream,
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l(_Stream, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _fwscanf_s_l(
                                                 FILE* const _Stream,
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl fwscanf_s(
                                           FILE* const _Stream,
                                           wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vfwscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }




                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _wscanf_s_l(
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl wscanf_s(
                                           wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }
# 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                                unsigned __int64 _Options,
                                                wchar_t* _Buffer,
                                                size_t _BufferCount,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );



    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                                unsigned __int64 _Options,
                                                wchar_t* _Buffer,
                                                size_t _BufferCount,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );



    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                                unsigned __int64 _Options,
                                                wchar_t* _Buffer,
                                                size_t _BufferCount,
                                                size_t _MaxCount,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );



    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                                unsigned __int64 _Options,
                                                wchar_t* _Buffer,
                                                size_t _BufferCount,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
                                                     wchar_t* const _Buffer,
                                                     size_t const _BufferCount,
                                                     wchar_t const* const _Format,
                                                     _locale_t const _Locale,
                                                     va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


#pragma warning(push)
#pragma warning(disable: 4793)



 __inline int __cdecl _vsnwprintf_s_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsnwprintf_s(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          wchar_t const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
    }


    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _snwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vsnwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, va_list _Args);








#pragma warning(pop)


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
                                                     wchar_t* _Buffer,
                                                     size_t _BufferCount,
                                                     wchar_t const* _Format,
                                                     va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnwprintf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
#pragma warning(pop)
 }
# 1150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __inline int __cdecl _vswprintf_c_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vswprintf_c(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }




    __inline int __cdecl _vswprintf_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)
 }




    __inline int __cdecl __vswprintf_l(
                                                wchar_t* const _Buffer,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }




    __inline int __cdecl _vswprintf(
                                         wchar_t* const _Buffer,
                                         wchar_t const* const _Format,
                                         va_list _ArgList
        )



    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, ((void *)0), _ArgList);
    }




    __inline int __cdecl vswprintf(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }




    __inline int __cdecl _vswprintf_s_l(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }





        __inline int __cdecl vswprintf_s(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          va_list _ArgList
            )



        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        }
# 1302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __inline int __cdecl _vswprintf_p_l(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vswprintf_p(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      va_list _ArgList
        )



    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }




    __inline int __cdecl _vscwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vscwprintf(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscwprintf_l(_Format, ((void *)0), _ArgList);
    }




    __inline int __cdecl _vscwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vscwprintf_p(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscwprintf_p_l(_Format, ((void *)0), _ArgList);
    }




    __inline int __cdecl __swprintf_l(
                                                wchar_t* const _Buffer,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _swprintf_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _swprintf(
                                         wchar_t* const _Buffer,
                                         wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = __vswprintf_l(_Buffer, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl swprintf(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }


#pragma warning(push)


#pragma warning(disable: 4793 4996)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __swprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __vswprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, va_list _Args);
# 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _swprintf( wchar_t *_Buffer, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vswprintf( wchar_t *_Buffer, wchar_t const* _Format, va_list _Args);






#pragma warning(pop)



 __inline int __cdecl _swprintf_s_l(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl swprintf_s(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }
# 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __inline int __cdecl _swprintf_p_l(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _swprintf_p(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _swprintf_c_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _swprintf_c(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
                                                     wchar_t* const _Buffer,
                                                     size_t const _BufferCount,
                                                     wchar_t const* const _Format,
                                                     _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

 __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snwprintf(
                                                     wchar_t* _Buffer,
                                                     size_t _BufferCount,
                                                     wchar_t const* _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
#pragma warning(pop)

 __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snwprintf_s_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snwprintf_s(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
# 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
    __inline int __cdecl _scwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _scwprintf(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscwprintf_l(_Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _scwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _scwprintf_p(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscwprintf_p_l(_Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




#pragma warning(push)
#pragma warning(disable: 4141 4412 4793 4996 6054)
# 1875 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(pop)
# 1892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
 __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                               unsigned __int64 _Options,
                                               wchar_t const* _Buffer,
                                               size_t _BufferCount,
                                               wchar_t const* _Format,
                                               _locale_t _Locale,
                                               va_list _ArgList
        );



    __inline int __cdecl _vswscanf_l(
                                      wchar_t const* const _Buffer,
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }




    __inline int __cdecl vswscanf(
                                      wchar_t const* _Buffer,
                                      wchar_t const* _Format,
                                      va_list _ArgList
        )



    {
        return _vswscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
    }




    __inline int __cdecl _vswscanf_s_l(
                                      wchar_t const* const _Buffer,
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }






        __inline int __cdecl vswscanf_s(
                                          wchar_t const* const _Buffer,
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vswscanf_s_l(_Buffer, _Format, ((void *)0), _ArgList);
        }
# 1980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                                               wchar_t const* const _Buffer,
                                               size_t const _BufferCount,
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
                                               va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }




    __inline int __cdecl _vsnwscanf_s_l(
                                                 wchar_t const* const _Buffer,
                                                 size_t const _BufferCount,
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
                                                 va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                               wchar_t const* const _Buffer,
                                               wchar_t const* const _Format,
                                               _locale_t _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                                     wchar_t const* const _Buffer,
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vswscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _swscanf_s_l(
                                                 wchar_t const* const _Buffer,
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }






        __inline int __cdecl swscanf_s(
                                           wchar_t const* const _Buffer,
                                           wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vswscanf_s_l(_Buffer, _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }





                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                                               wchar_t const* const _Buffer,
                                               size_t const _BufferCount,
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

 __builtin_va_end(_ArgList);
        return _Result;
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
                                         wchar_t const* const _Buffer,
                                         size_t const _BufferCount,
                                         wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
#pragma warning(pop)

 __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snwscanf_s_l(
                                                 wchar_t const* const _Buffer,
                                                 size_t const _BufferCount,
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snwscanf_s(
                                          wchar_t const* const _Buffer,
                                          size_t const _BufferCount,
                                          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
# 2198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 2 3

#pragma pack(push, 8)
# 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
typedef __int64 fpos_t;






    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
                  FILE* _Stream,
                  char*** _Base,
                  char*** _Pointer,
                  int** _Count
        );
# 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
        __declspec(dllimport) errno_t __cdecl clearerr_s(
                    FILE* _Stream
            );


        __declspec(dllimport) errno_t __cdecl fopen_s(
                                      FILE** _Stream,
                                      char const* _FileName,
                                      char const* _Mode
            );



        __declspec(dllimport) size_t __cdecl fread_s(
                                                                               void* _Buffer,
                                                                               size_t _BufferSize,
                                                                               size_t _ElementSize,
                                                                               size_t _ElementCount,
                                                                               FILE* _Stream
            );


        __declspec(dllimport) errno_t __cdecl freopen_s(
                                      FILE** _Stream,
                                      char const* _FileName,
                                      char const* _Mode,
                                      FILE* _OldStream
            );


        __declspec(dllimport) char* __cdecl gets_s(
                                  char* _Buffer,
                                  rsize_t _Size
            );


        __declspec(dllimport) errno_t __cdecl tmpfile_s(
                                         FILE** _Stream
            );



        __declspec(dllimport) errno_t __cdecl tmpnam_s(
                                  char* _Buffer,
                                  rsize_t _Size
            );



    __declspec(dllimport) void __cdecl clearerr(
                FILE* _Stream
        );



    __declspec(dllimport) int __cdecl fclose(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fcloseall(void);


    __declspec(dllimport) FILE* __cdecl _fdopen(
               int _FileHandle,
               char const* _Mode
        );


    __declspec(dllimport) int __cdecl feof(
             FILE* _Stream
        );


    __declspec(dllimport) int __cdecl ferror(
             FILE* _Stream
        );


    __declspec(dllimport) int __cdecl fflush(
                    FILE* _Stream
        );



    __declspec(dllimport) int __cdecl fgetc(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fgetchar(void);



    __declspec(dllimport) int __cdecl fgetpos(
                FILE* _Stream,
                fpos_t* _Position
        );



    __declspec(dllimport) char* __cdecl fgets(
                                  char* _Buffer,
                                  int _MaxCount,
                                  FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fileno(
             FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _flushall(void);

                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl fopen(
               char const* _FileName,
               char const* _Mode
        );




    __declspec(dllimport) int __cdecl fputc(
                int _Character,
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fputchar(
             int _Character
        );



    __declspec(dllimport) int __cdecl fputs(
                char const* _Buffer,
                FILE* _Stream
        );


    __declspec(dllimport) size_t __cdecl fread(
                                                         void* _Buffer,
                                                         size_t _ElementSize,
                                                         size_t _ElementCount,
                                                         FILE* _Stream
        );


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl freopen(
                char const* _FileName,
                char const* _Mode,
                FILE* _Stream
        );


    __declspec(dllimport) FILE* __cdecl _fsopen(
               char const* _FileName,
               char const* _Mode,
               int _ShFlag
        );



    __declspec(dllimport) int __cdecl fsetpos(
                FILE* _Stream,
                fpos_t const* _Position
        );



    __declspec(dllimport) int __cdecl fseek(
                FILE* _Stream,
                long _Offset,
                int _Origin
        );



    __declspec(dllimport) int __cdecl _fseeki64(
                FILE* _Stream,
                __int64 _Offset,
                int _Origin
        );



    __declspec(dllimport) long __cdecl ftell(
                FILE* _Stream
        );



    __declspec(dllimport) __int64 __cdecl _ftelli64(
                FILE* _Stream
        );


    __declspec(dllimport) size_t __cdecl fwrite(
                                                       void const* _Buffer,
                                                       size_t _ElementSize,
                                                       size_t _ElementCount,
                                                       FILE* _Stream
        );



    __declspec(dllimport) int __cdecl getc(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl getchar(void);


    __declspec(dllimport) int __cdecl _getmaxstdio(void);






    __declspec(dllimport) int __cdecl _getw(
                FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
                   char const* _ErrorMessage
        );





        __declspec(dllimport) int __cdecl _pclose(
                    FILE* _Stream
            );


        __declspec(dllimport) FILE* __cdecl _popen(
                   char const* _Command,
                   char const* _Mode
            );





    __declspec(dllimport) int __cdecl putc(
                int _Character,
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl putchar(
             int _Character
        );


    __declspec(dllimport) int __cdecl puts(
               char const* _Buffer
        );



    __declspec(dllimport) int __cdecl _putw(
                int _Word,
                FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
               char const* _FileName
        );


    __declspec(dllimport) int __cdecl rename(
               char const* _OldFileName,
               char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
               char const* _FileName
        );



        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
                   char const* _FileName
            );



    __declspec(dllimport) void __cdecl rewind(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl setbuf(
                                                            FILE* _Stream,
                                                            char* _Buffer
        );


    __declspec(dllimport) int __cdecl _setmaxstdio(
             int _Maximum
        );



    __declspec(dllimport) int __cdecl setvbuf(
                                     FILE* _Stream,
                                     char* _Buffer,
                                     int _Mode,
                                     size_t _Size
        );







    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
                   char const* _DirectoryName,
                   char const* _FilePrefix
        );





                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl tmpfile(void);







#pragma warning(push)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl tmpnam( char *_Buffer);




#pragma warning(pop)



 __declspec(dllimport) int __cdecl ungetc(
                int _Character,
                FILE* _Stream
        );
# 461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) void __cdecl _lock_file(
                FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
                FILE* _Stream
        );



    __declspec(dllimport) int __cdecl _fclose_nolock(
                FILE* _Stream
        );



    __declspec(dllimport) int __cdecl _fflush_nolock(
                    FILE* _Stream
        );



    __declspec(dllimport) int __cdecl _fgetc_nolock(
                FILE* _Stream
        );



    __declspec(dllimport) int __cdecl _fputc_nolock(
                int _Character,
                FILE* _Stream
        );


    __declspec(dllimport) size_t __cdecl _fread_nolock(
                                                         void* _Buffer,
                                                         size_t _ElementSize,
                                                         size_t _ElementCount,
                                                         FILE* _Stream
        );



    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
                                                                         void* _Buffer,
                                                                         size_t _BufferSize,
                                                                         size_t _ElementSize,
                                                                         size_t _ElementCount,
                                                                         FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fseek_nolock(
                FILE* _Stream,
                long _Offset,
                int _Origin
        );


    __declspec(dllimport) int __cdecl _fseeki64_nolock(
                FILE* _Stream,
                __int64 _Offset,
                int _Origin
        );


    __declspec(dllimport) long __cdecl _ftell_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
                                                       void const* _Buffer,
                                                       size_t _ElementSize,
                                                       size_t _ElementCount,
                                                       FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _getc_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _putc_nolock(
                int _Character,
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _ungetc_nolock(
                int _Character,
                FILE* _Stream
        );
# 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) int* __cdecl __p__commode(void);
# 607 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __inline int __cdecl _vfprintf_l(
                 FILE* const _Stream,
                 char const* const _Format,
                 _locale_t const _Locale,
                 va_list _ArgList
        )



    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vfprintf(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_l(_Stream, _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vfprintf_s_l(
                 FILE* const _Stream,
                 char const* const _Format,
                 _locale_t const _Locale,
                 va_list _ArgList
        )



    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vfprintf_s(
                                          FILE* const _Stream,
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }





    __inline int __cdecl _vfprintf_p_l(
                 FILE* const _Stream,
                 char const* const _Format,
                 _locale_t const _Locale,
                 va_list _ArgList
        )



    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vfprintf_p(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vprintf_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vprintf(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vprintf_s_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vprintf_s(
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        }





    __inline int __cdecl _vprintf_p_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vprintf_p(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _fprintf_l(
                                                FILE* const _Stream,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl fprintf(
                                      FILE* const _Stream,
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_l(_Stream, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }


    __declspec(dllimport) int __cdecl _set_printf_count_output(
             int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);


    __inline int __cdecl _fprintf_s_l(
                                                FILE* const _Stream,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl fprintf_s(
                                          FILE* const _Stream,
                                          char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vfprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }





    __inline int __cdecl _fprintf_p_l(
                                                FILE* const _Stream,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _fprintf_p(
                                      FILE* const _Stream,
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _printf_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl printf(
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _printf_s_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl printf_s(
                                          char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }





    __inline int __cdecl _printf_p_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _printf_p(
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
# 1044 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                               unsigned __int64 _Options,
                                               FILE* _Stream,
                                               char const* _Format,
                                               _locale_t _Locale,
                                               va_list _Arglist
        );


    __inline int __cdecl _vfscanf_l(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vfscanf(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfscanf_l(_Stream, _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vfscanf_s_l(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }






        __inline int __cdecl vfscanf_s(
                                          FILE* const _Stream,
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }





    __inline int __cdecl _vscanf_l(
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vscanf(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vscanf_s_l(
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vscanf_s(
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        }




                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                               FILE* const _Stream,
                                               char const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                                     FILE* const _Stream,
                                     char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_l(_Stream, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _fscanf_s_l(
                                                 FILE* const _Stream,
                                                 char const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl fscanf_s(
                                           FILE* const _Stream,
                                           char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vfscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }




                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
                                               char const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
                                     char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _scanf_s_l(
                                                 char const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl scanf_s(
                                           char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }
# 1337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                                unsigned __int64 _Options,
                                                char* _Buffer,
                                                size_t _BufferCount,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                                unsigned __int64 _Options,
                                                char* _Buffer,
                                                size_t _BufferCount,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                                unsigned __int64 _Options,
                                                char* _Buffer,
                                                size_t _BufferCount,
                                                size_t _MaxCount,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                                unsigned __int64 _Options,
                                                char* _Buffer,
                                                size_t _BufferCount,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
                                                     char* const _Buffer,
                                                     size_t const _BufferCount,
                                                     char const* const _Format,
                                                     _locale_t const _Locale,
                                                     va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsnprintf(
                                                     char* const _Buffer,
                                                    size_t const _BufferCount,
                                                    char const* const _Format,
                                                    va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnprintf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
#pragma warning(pop)
 }
# 1430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __inline int __cdecl vsnprintf(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          char const* const _Format,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, ((void *)0), _ArgList);

        return _Result < 0 ? -1 : _Result;
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
                                         char* const _Buffer,
                                         char const* const _Format,
                                         _locale_t const _Locale,
                                         va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
#pragma warning(pop)
 }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
                                         char* const _Buffer,
                                         char const* const _Format,
                                         va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnprintf_l(_Buffer, (size_t)-1, _Format, ((void *)0), _ArgList);
#pragma warning(pop)
 }




    __inline int __cdecl _vsprintf_s_l(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }






        __inline int __cdecl vsprintf_s(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          char const* const _Format,
                                                          va_list _ArgList
            )



        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        }
# 1536 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _vsprintf_p_l(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsprintf_p(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      va_list _ArgList
        )



    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }




    __inline int __cdecl _vsnprintf_s_l(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          char const* const _Format,
                                                          _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsnprintf_s(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          char const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
    }
# 1623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
        __inline int __cdecl vsnprintf_s(
                                                              char* const _Buffer,
                                                              size_t const _BufferCount,
                                                              size_t const _MaxCount,
                                                              char const* const _Format,
                                                              va_list _ArgList
            )



        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
        }
# 1650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _vscprintf_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }



    __inline int __cdecl _vscprintf(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscprintf_l(_Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vscprintf_p_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }



    __inline int __cdecl _vscprintf_p(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscprintf_p_l(_Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vsnprintf_c_l(
                                                char* const _Buffer,
                                                size_t const _BufferCount,
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsnprintf_c(
                                       char* const _Buffer,
                                       size_t const _BufferCount,
                                       char const* const _Format,
                                       va_list _ArgList
        )



    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                                                char* const _Buffer,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
#pragma warning(pop)

 __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl sprintf(
                                         char* const _Buffer,
                                         char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsprintf_l(_Buffer, _Format, ((void *)0), _ArgList);
#pragma warning(pop)

 __builtin_va_end(_ArgList);
        return _Result;
    }


#pragma warning(push)
#pragma warning(disable: 4996)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl sprintf( char *_Buffer, char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl vsprintf( char *_Buffer, char const* _Format, va_list _Args);





#pragma warning(pop)



 __inline int __cdecl _sprintf_s_l(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }






        __inline int __cdecl sprintf_s(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
            __builtin_va_end(_ArgList);
            return _Result;
        }
# 1862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _sprintf_p_l(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _sprintf_p(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
                                                     char* const _Buffer,
                                                     size_t const _BufferCount,
                                                     char const* const _Format,
                                                     _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

 __builtin_va_end(_ArgList);
        return _Result;
    }
# 1940 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __inline int __cdecl snprintf(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
#pragma warning(suppress: 28719)
 _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snprintf(
                                                     char* const _Buffer,
                                                     size_t const _BufferCount,
                                                     char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
#pragma warning(suppress: 28719)
 _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }


    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl _snprintf( char *_Buffer, size_t _BufferCount, char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl _vsnprintf( char *_Buffer, size_t _BufferCount, char const* _Format, va_list _Args);
# 1991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _snprintf_c_l(
                                                char* const _Buffer,
                                                size_t const _BufferCount,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snprintf_c(
                                       char* const _Buffer,
                                       size_t const _BufferCount,
                                       char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snprintf_s_l(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          char const* const _Format,
                                                          _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snprintf_s(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }
# 2082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _scprintf_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _scprintf(
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscprintf_l(_Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _scprintf_p_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _scprintf_p(
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vscprintf_p(_Format, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }







    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                               unsigned __int64 _Options,
                                               char const* _Buffer,
                                               size_t _BufferCount,
                                               char const* _Format,
                                               _locale_t _Locale,
                                               va_list _ArgList
        );


    __inline int __cdecl _vsscanf_l(
                                      char const* const _Buffer,
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vsscanf(
                                      char const* const _Buffer,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vsscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
    }



    __inline int __cdecl _vsscanf_s_l(
                                      char const* const _Buffer,
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }




#pragma warning(push)
#pragma warning(disable: 6530)


 __inline int __cdecl vsscanf_s(
                                          char const* const _Buffer,
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vsscanf_s_l(_Buffer, _Format, ((void *)0), _ArgList);
        }
# 2239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
#pragma warning(pop)



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                               char const* const _Buffer,
                                               char const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                                     char const* const _Buffer,
                                     char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);
        _Result = _vsscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _sscanf_s_l(
                                                 char const* const _Buffer,
                                                 char const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __builtin_va_end(_ArgList);
        return _Result;
    }





        __inline int __cdecl sscanf_s(
                                           char const* const _Buffer,
                                           char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __builtin_va_start(_ArgList, _Format);

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = vsscanf_s(_Buffer, _Format, _ArgList);
#pragma warning(pop)

 __builtin_va_end(_ArgList);
            return _Result;
        }




#pragma warning(push)
#pragma warning(disable: 6530)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
                                               char const* const _Buffer,
                                               size_t const _BufferCount,
                                               char const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        __builtin_va_end(_ArgList);
        return _Result;
    }


                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
                                               char const* const _Buffer,
                                               size_t const _BufferCount,
                                               char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, ((void *)0), _ArgList);

        __builtin_va_end(_ArgList);
        return _Result;
    }




    __inline int __cdecl _snscanf_s_l(
                                                 char const* const _Buffer,
                                                 size_t const _BufferCount,
                                                 char const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Locale);

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        __builtin_va_end(_ArgList);
        return _Result;
    }



    __inline int __cdecl _snscanf_s(
                                               char const* const _Buffer,
                                               size_t const _BufferCount,
                                               char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __builtin_va_start(_ArgList, _Format);

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, ((void *)0), _ArgList);

        __builtin_va_end(_ArgList);
        return _Result;
    }


#pragma warning(pop)
# 2446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h" 3
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
                       char const* _Directory,
                       char const* _FilePrefix
            );





                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int __cdecl fcloseall(void);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details.")) __declspec(dllimport) FILE* __cdecl fdopen( int _FileHandle, char const* _Format);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fgetchar(void);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details.")) __declspec(dllimport) int __cdecl fileno( FILE* _Stream);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details.")) __declspec(dllimport) int __cdecl flushall(void);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fputchar( int _Ch);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details.")) __declspec(dllimport) int __cdecl getw( FILE* _Stream);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details.")) __declspec(dllimport) int __cdecl putw( int _Ch, FILE* _Stream);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details.")) __declspec(dllimport) int __cdecl rmtmp(void);






#pragma pack(pop)
# 24 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c" 2
# 1 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h" 1
# 26 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h"
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stdbool.h" 1 3
# 27 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h" 2
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\assert.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\assert.h" 3
#pragma pack(push, 8)
# 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\assert.h" 3
 __declspec(dllimport) void __cdecl _wassert(
               wchar_t const* _Message,
               wchar_t const* _File,
               unsigned _Line
        );
# 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\assert.h" 3
#pragma pack(pop)
# 28 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h" 2

# 1 "./.\\m-string.h" 1
# 29 "./.\\m-string.h"
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h" 3
#pragma pack(push, 8)
# 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h" 3
 __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t* __cdecl __pwctype_func(void);
# 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h" 3
               __declspec(dllimport) int __cdecl iswalnum ( wint_t _C);
               __declspec(dllimport) int __cdecl iswalpha ( wint_t _C);
               __declspec(dllimport) int __cdecl iswascii ( wint_t _C);
               __declspec(dllimport) int __cdecl iswblank ( wint_t _C);
               __declspec(dllimport) int __cdecl iswcntrl ( wint_t _C);


               __declspec(dllimport) int __cdecl iswdigit ( wint_t _C);

               __declspec(dllimport) int __cdecl iswgraph ( wint_t _C);
               __declspec(dllimport) int __cdecl iswlower ( wint_t _C);
               __declspec(dllimport) int __cdecl iswprint ( wint_t _C);
               __declspec(dllimport) int __cdecl iswpunct ( wint_t _C);
               __declspec(dllimport) int __cdecl iswspace ( wint_t _C);
               __declspec(dllimport) int __cdecl iswupper ( wint_t _C);
               __declspec(dllimport) int __cdecl iswxdigit ( wint_t _C);
               __declspec(dllimport) int __cdecl __iswcsymf( wint_t _C);
               __declspec(dllimport) int __cdecl __iswcsym ( wint_t _C);

               __declspec(dllimport) int __cdecl _iswalnum_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswalpha_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswblank_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswcntrl_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswdigit_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswgraph_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswlower_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswprint_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswpunct_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswspace_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswupper_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswxdigit_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswcsymf_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswcsym_l ( wint_t _C, _locale_t _Locale);


               __declspec(dllimport) wint_t __cdecl towupper( wint_t _C);
               __declspec(dllimport) wint_t __cdecl towlower( wint_t _C);
               __declspec(dllimport) int __cdecl iswctype( wint_t _C, wctype_t _Type);

               __declspec(dllimport) wint_t __cdecl _towupper_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) wint_t __cdecl _towlower_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswctype_l( wint_t _C, wctype_t _Type, _locale_t _Locale);



                   __declspec(dllimport) int __cdecl isleadbyte( int _C);
                   __declspec(dllimport) int __cdecl _isleadbyte_l( int _C, _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype( wint_t _C, wctype_t _Type);
# 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 2 3

#pragma pack(push, 8)
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 3
 __declspec(dllimport) int __cdecl _isctype( int _C, int _Type);
               __declspec(dllimport) int __cdecl _isctype_l( int _C, int _Type, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isalpha( int _C);
               __declspec(dllimport) int __cdecl _isalpha_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isupper( int _C);
               __declspec(dllimport) int __cdecl _isupper_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl islower( int _C);
               __declspec(dllimport) int __cdecl _islower_l( int _C, _locale_t _Locale);


                                  __declspec(dllimport) int __cdecl isdigit( int _C);

               __declspec(dllimport) int __cdecl _isdigit_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isxdigit( int _C);
               __declspec(dllimport) int __cdecl _isxdigit_l( int _C, _locale_t _Locale);


                                  __declspec(dllimport) int __cdecl isspace( int _C);

               __declspec(dllimport) int __cdecl _isspace_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl ispunct( int _C);
               __declspec(dllimport) int __cdecl _ispunct_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isblank( int _C);
               __declspec(dllimport) int __cdecl _isblank_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isalnum( int _C);
               __declspec(dllimport) int __cdecl _isalnum_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isprint( int _C);
               __declspec(dllimport) int __cdecl _isprint_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isgraph( int _C);
               __declspec(dllimport) int __cdecl _isgraph_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iscntrl( int _C);
               __declspec(dllimport) int __cdecl _iscntrl_l( int _C, _locale_t _Locale);


                                  __declspec(dllimport) int __cdecl toupper( int _C);


                                  __declspec(dllimport) int __cdecl tolower( int _C);

                                  __declspec(dllimport) int __cdecl _tolower( int _C);
               __declspec(dllimport) int __cdecl _tolower_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl _toupper( int _C);
               __declspec(dllimport) int __cdecl _toupper_l( int _C, _locale_t _Locale);

               __declspec(dllimport) int __cdecl __isascii( int _C);
               __declspec(dllimport) int __cdecl __toascii( int _C);
               __declspec(dllimport) int __cdecl __iscsymf( int _C);
               __declspec(dllimport) int __cdecl __iscsym( int _C);
# 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 3
__inline int __cdecl __acrt_locale_get_ctype_array_value(
                                unsigned short const * const _Locale_pctype_array,
                                int const _Char_value,
                                int const _Mask
    )
{




    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }

    return 0;
}
# 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 3
        __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

        __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);





        __declspec(dllimport) int __cdecl _chvalidator( int _Ch, int _Mask);
# 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 3
        __forceinline int __cdecl __ascii_tolower(int const _C)
        {
            if (_C >= 'A' && _C <= 'Z')
            {
                return _C - ('A' - 'a');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_toupper(int const _C)
        {
            if (_C >= 'a' && _C <= 'z')
            {
                return _C - ('a' - 'A');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_iswalpha(int const _C)
        {
            return (_C >= 'A' && _C <= 'Z') || (_C >= 'a' && _C <= 'z');
        }

        __forceinline int __cdecl __ascii_iswdigit(int const _C)
        {
            return _C >= '0' && _C <= '9';
        }

        __forceinline int __cdecl __ascii_towlower(int const _C)
        {
            return __ascii_tolower(_C);
        }

        __forceinline int __cdecl __ascii_towupper(int const _C)
        {
            return __ascii_toupper(_C);
        }
# 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 3
    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }


    __declspec(dllimport) int __cdecl _chvalidator_l( _locale_t, int _Ch, int _Mask);


    __inline int __cdecl _chvalidchk_l(
                 int const _C,
                 int const _Mask,
                 _locale_t const _Locale
        )
    {

        return _chvalidator_l(_Locale, _C, _Mask);
# 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 3
    }




    __inline int __cdecl _ischartype_l(
                 int const _C,
                 int const _Mask,
                 _locale_t const _Locale
        )
    {
        if (_Locale) {
            if (_C >= -1 && _C <= 255)
            {
                return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
            }

            if (__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
            {
                return _isctype_l(_C, _Mask, _Locale);
            }

            return 0;
        }

        return _chvalidchk_l(_C, _Mask, 0);
    }
# 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h" 3
#pragma pack(pop)
# 30 "./.\\m-string.h" 2

# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stdarg.h" 1 3
# 14 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stdarg.h" 3
typedef __builtin_va_list va_list;
# 32 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 32 "./.\\m-string.h" 2
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h" 1 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\errno.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\errno.h" 3
#pragma pack(push, 8)




 __declspec(dllimport) int* __cdecl _errno(void);


    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);


    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);
# 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\errno.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h" 2 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime_string.h" 1 3
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime_string.h" 3
#pragma warning(push)
#pragma warning(disable: 4514 4820)



#pragma pack(push, 8)




 void * __cdecl memchr(
                                    void const* _Buf,
                                    int _Val,
                                    size_t _MaxCount
    );


int __cdecl memcmp(
                            void const* _Buf1,
                            void const* _Buf2,
                            size_t _Size
    );
# 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime_string.h" 3
void* __cdecl memcpy(
                                  void* _Dst,
                                  void const* _Src,
                                  size_t _Size
    );


         void* __cdecl memmove(
                                      void* _Dst,
                                      void const* _Src,
                                      size_t _Size
    );
# 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime_string.h" 3
void* __cdecl memset(
                                  void* _Dst,
                                  int _Val,
                                  size_t _Size
    );


         char * __cdecl strchr(
           char const* _Str,
           int _Val
    );


         char * __cdecl strrchr(
           char const* _Str,
           int _Ch
    );


         char * __cdecl strstr(
           char const* _Str,
           char const* _SubStr
    );



         wchar_t * __cdecl wcschr(
           wchar_t const* _Str,
           wchar_t _Ch
    );


         wchar_t * __cdecl wcsrchr(
           wchar_t const* _Str,
           wchar_t _Ch
    );



         wchar_t * __cdecl wcsstr(
           wchar_t const* _Str,
           wchar_t const* _SubStr
    );



#pragma pack(pop)



#pragma warning(pop)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h" 2 3

#pragma pack(push, 8)
# 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h" 3
 static __inline errno_t __cdecl memcpy_s(
                                                                 void* const _Destination,
                                                                 rsize_t const _DestinationSize,
                                                                 void const* const _Source,
                                                                 rsize_t const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == ((void *)0) || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };


            return 22;
        }
#pragma warning(suppress: 4996)
 memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }


    static __inline errno_t __cdecl memmove_s(
                                                                 void* const _Destination,
                                                                 rsize_t const _DestinationSize,
                                                                 void const* const _Source,
                                                                 rsize_t const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

#pragma warning(suppress: 4996)
 memmove(_Destination, _Source, _SourceSize);
        return 0;
    }





#pragma pack(pop)
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h" 2 3




#pragma pack(push, 8)




__declspec(dllimport) int __cdecl _memicmp(
                                void const* _Buf1,
                                void const* _Buf2,
                                size_t _Size
    );


__declspec(dllimport) int __cdecl _memicmp_l(
                                void const* _Buf1,
                                void const* _Buf2,
                                size_t _Size,
                                _locale_t _Locale
    );
# 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h" 3
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
                                      void* _Dst,
                                      void const* _Src,
                                      int _Val,
                                      size_t _Size
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
                                    void const* _Buf1,
                                    void const* _Buf2,
                                    size_t _Size
        );
# 114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 2 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 1 3
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
#pragma pack(push, 8)
# 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
 __declspec(dllimport) errno_t __cdecl wcscat_s(
                                        wchar_t* _Destination,
             rsize_t _SizeInWords,
               wchar_t const* _Source
        );


    __declspec(dllimport) errno_t __cdecl wcscpy_s(
                                     wchar_t* _Destination,
             rsize_t _SizeInWords,
               wchar_t const* _Source
        );


    __declspec(dllimport) errno_t __cdecl wcsncat_s(
                                        wchar_t* _Destination,
                                        rsize_t _SizeInWords,
                                        wchar_t const* _Source,
                                        rsize_t _MaxCount
        );


    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
                                     wchar_t* _Destination,
                                     rsize_t _SizeInWords,
                                     wchar_t const* _Source,
                                     rsize_t _MaxCount
        );


    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                                      wchar_t* _String,
                                      wchar_t const* _Delimiter,
                                      wchar_t** _Context
        );
# 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
           wchar_t const* _String
    );
# 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination, wchar_t const* _Source);




#pragma warning(pop)



__declspec(dllimport) int __cdecl wcscmp(
           wchar_t const* _String1,
           wchar_t const* _String2
    );







#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination, wchar_t const* _Source);




#pragma warning(pop)


__declspec(dllimport) size_t __cdecl wcscspn(
           wchar_t const* _String,
           wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcslen(
           wchar_t const* _String
    );
# 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) size_t __cdecl wcsnlen(
                               wchar_t const* _Source,
                               size_t _MaxCount
    );
# 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
    static __inline size_t __cdecl wcsnlen_s(
                                   wchar_t const* _Source,
                                   size_t _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }
# 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);
# 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) int __cdecl wcsncmp(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );
# 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);
# 214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) wchar_t * __cdecl wcspbrk(
           wchar_t const* _String,
           wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcsspn(
           wchar_t const* _String,
           wchar_t const* _Control
    );

               __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                                      wchar_t* _String,
                                      wchar_t const* _Delimiter,
                                      wchar_t** _Context
    );
# 243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
#pragma warning(push)
#pragma warning(disable: 4141 4996)
#pragma warning(disable: 28719 28726 28727)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
                      wchar_t* const _String,
                      wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }
# 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
#pragma warning(pop)






 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
         int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
                                     wchar_t* _Buffer,
                                     size_t _SizeInWords,
                                     int _ErrorNumber
    );
# 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
               wchar_t const* _String
    );

                   __declspec(dllimport) errno_t __cdecl __wcserror_s(
                                     wchar_t* _Buffer,
                                     size_t _SizeInWords,
                                     wchar_t const* _ErrorMessage
    );







               __declspec(dllimport) int __cdecl _wcsicmp(
           wchar_t const* _String1,
           wchar_t const* _String2
    );

               __declspec(dllimport) int __cdecl _wcsicmp_l(
             wchar_t const* _String1,
             wchar_t const* _String2,
             _locale_t _Locale
    );

               __declspec(dllimport) int __cdecl _wcsnicmp(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );

               __declspec(dllimport) int __cdecl _wcsnicmp_l(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );

                   __declspec(dllimport) errno_t __cdecl _wcsnset_s(
                                    wchar_t* _Destination,
                                    size_t _SizeInWords,
                                    wchar_t _Value,
                                    size_t _MaxCount
    );
# 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset( wchar_t *_String, wchar_t _Value, size_t _MaxCount);







__declspec(dllimport) wchar_t* __cdecl _wcsrev(
              wchar_t* _String
    );

                   __declspec(dllimport) errno_t __cdecl _wcsset_s(
                                    wchar_t* _Destination,
                                    size_t _SizeInWords,
                                    wchar_t _Value
    );







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset( wchar_t *_String, wchar_t _Value);






                   __declspec(dllimport) errno_t __cdecl _wcslwr_s(
                                    wchar_t* _String,
                                    size_t _SizeInWords
    );






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
                                    wchar_t* _String,
                                    size_t _SizeInWords,
                                    _locale_t _Locale
    );







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l( wchar_t *_String, _locale_t _Locale);







__declspec(dllimport) errno_t __cdecl _wcsupr_s(
                             wchar_t* _String,
                             size_t _Size
    );






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
                             wchar_t* _String,
                             size_t _Size,
                             _locale_t _Locale
    );







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l( wchar_t *_String, _locale_t _Locale);
# 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) size_t __cdecl wcsxfrm(
                                              wchar_t* _Destination,
                                              wchar_t const* _Source,
                                              size_t _MaxCount
    );



__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
                                              wchar_t* _Destination,
                                              wchar_t const* _Source,
                                              size_t _MaxCount,
                                              _locale_t _Locale
    );


__declspec(dllimport) int __cdecl wcscoll(
           wchar_t const* _String1,
           wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcscoll_l(
             wchar_t const* _String1,
             wchar_t const* _String2,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _wcsicoll(
           wchar_t const* _String1,
           wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcsicoll_l(
             wchar_t const* _String1,
             wchar_t const* _String2,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _wcsncoll(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsncoll_l(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _wcsnicoll(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsnicoll_l(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );
# 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
               wchar_t const* _String
        );
# 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
               wchar_t const* _String1,
               wchar_t const* _String2
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
                                   wchar_t const* _String1,
                                   wchar_t const* _String2,
                                   size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsnset(
                                     wchar_t* _String,
                                     wchar_t _Value,
                                     size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsrev(
                  wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsset(
                  wchar_t* _String,
                  wchar_t _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcslwr(
                  wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsupr(
                  wchar_t* _String
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
               wchar_t const* _String1,
               wchar_t const* _String2
        );





#pragma pack(pop)
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 2 3




#pragma pack(push, 8)








 __declspec(dllimport) errno_t __cdecl strcpy_s(
                                     char* _Destination,
                                     rsize_t _SizeInBytes,
                                     char const* _Source
        );


    __declspec(dllimport) errno_t __cdecl strcat_s(
                                        char* _Destination,
                                        rsize_t _SizeInBytes,
                                        char const* _Source
        );


    __declspec(dllimport) errno_t __cdecl strerror_s(
                                     char* _Buffer,
                                     size_t _SizeInBytes,
                                     int _ErrorNumber);


    __declspec(dllimport) errno_t __cdecl strncat_s(
                                        char* _Destination,
                                        rsize_t _SizeInBytes,
                                        char const* _Source,
                                        rsize_t _MaxCount
        );


    __declspec(dllimport) errno_t __cdecl strncpy_s(
                                     char* _Destination,
                                     rsize_t _SizeInBytes,
                                     char const* _Source,
                                     rsize_t _MaxCount
        );


    __declspec(dllimport) char* __cdecl strtok_s(
                                      char* _String,
                                      char const* _Delimiter,
                                      char** _Context
        );



__declspec(dllimport) void* __cdecl _memccpy(
                                      void* _Dst,
                                      void const* _Src,
                                      int _Val,
                                      size_t _MaxCount
    );
# 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl strcat( char *_Destination, char const* _Source);




#pragma warning(pop)




int __cdecl strcmp(
           char const* _Str1,
           char const* _Str2
    );


__declspec(dllimport) int __cdecl _strcmpi(
           char const* _String1,
           char const* _String2
    );


__declspec(dllimport) int __cdecl strcoll(
           char const* _String1,
           char const* _String2
    );


__declspec(dllimport) int __cdecl _strcoll_l(
             char const* _String1,
             char const* _String2,
             _locale_t _Locale
    );







#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl strcpy( char *_Destination, char const* _Source);




#pragma warning(pop)


__declspec(dllimport) size_t __cdecl strcspn(
           char const* _Str,
           char const* _Control
    );







__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
               char const* _Source
    );







               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _strerror(
               char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
                                 char* _Buffer,
                                 size_t _SizeInBytes,
                                 char const* _ErrorMessage
    );
# 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
         int _ErrorMessage
    );
# 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
__declspec(dllimport) int __cdecl _stricmp(
           char const* _String1,
           char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll(
           char const* _String1,
           char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll_l(
             char const* _String1,
             char const* _String2,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _stricmp_l(
             char const* _String1,
             char const* _String2,
             _locale_t _Locale
    );


size_t __cdecl strlen(
           char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
                             char* _String,
                             size_t _Size
    );






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);





__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
                             char* _String,
                             size_t _Size,
                             _locale_t _Locale
    );







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l( char *_String, _locale_t _Locale);
# 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat( char *_Destination, char const* _Source, size_t _Count);
# 275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
__declspec(dllimport) int __cdecl strncmp(
                               char const* _Str1,
                               char const* _Str2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp_l(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _strnicoll(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicoll_l(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _strncoll(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _strncoll_l(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
                            char const* _String,
                            size_t _Count
    );
# 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy( char *_Destination, char const* _Source, size_t _Count);
# 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
__declspec(dllimport) size_t __cdecl strnlen(
                               char const* _String,
                               size_t _MaxCount
    );
# 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
    static __inline size_t __cdecl strnlen_s(
                                   char const* _String,
                                   size_t _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }




__declspec(dllimport) errno_t __cdecl _strnset_s(
                                    char* _String,
                                    size_t _SizeInBytes,
                                    int _Value,
                                    size_t _MaxCount
    );
# 396 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset( char *_Destination, int _Value, size_t _Count);
# 405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
__declspec(dllimport) char * __cdecl strpbrk(
           char const* _Str,
           char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
              char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
                                        char* _Destination,
                                        size_t _DestinationSize,
                                        int _Value
    );







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl _strset( char *_Destination, int _Value);






__declspec(dllimport) size_t __cdecl strspn(
           char const* _Str,
           char const* _Control
    );

               __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
                  char* _String,
                  char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
                             char* _String,
                             size_t _Size
    );






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);





__declspec(dllimport) errno_t __cdecl _strupr_s_l(
                             char* _String,
                             size_t _Size,
                             _locale_t _Locale
    );







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l( char *_String, _locale_t _Locale);
# 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
__declspec(dllimport) size_t __cdecl strxfrm(
                                              char* _Destination,
                                              char const* _Source,
                                              size_t _MaxCount
    );



__declspec(dllimport) size_t __cdecl _strxfrm_l(
                                              char* _Destination,
                                              char const* _Source,
                                              size_t _MaxCount,
                                              _locale_t _Locale
    );
# 535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
                   char const* _String
        );



                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
               char const* _String1,
               char const* _String2
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
               char const* _String1,
               char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
                  char* _String
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
                                   char const* _String1,
                                   char const* _String2,
                                   size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
                                     char* _String,
                                     int _Value,
                                     size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
                  char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
                  char* _String,
                  int _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
                  char* _String
        );





#pragma pack(pop)
# 33 "./.\\m-string.h" 2

# 1 "././m-core.h" 1
# 28 "././m-core.h"
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stddef.h" 1 3
# 35 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stddef.h" 3
typedef long long int ptrdiff_t;
# 46 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stddef.h" 3
typedef long long unsigned int size_t;
# 60 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stddef.h" 3
typedef long long unsigned int rsize_t;
# 74 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stddef.h" 3
typedef unsigned short wchar_t;
# 102 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stddef.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include/__stddef_max_align_t.h" 1 3
# 14 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include/__stddef_max_align_t.h" 3
typedef double max_align_t;
# 103 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stddef.h" 2 3
# 29 "././m-core.h" 2

# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stdint.h" 1 3
# 52 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stdint.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\stdint.h" 1 3
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\stdint.h" 3
#pragma warning(push)
#pragma warning(disable: 4514 4820)

typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long intmax_t;
typedef unsigned long long uintmax_t;
# 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\stdint.h" 3
#pragma warning(pop)
# 53 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stdint.h" 2 3
# 31 "././m-core.h" 2
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\limits.h" 1 3
# 21 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\limits.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\limits.h" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\limits.h" 3
#pragma warning(push)
#pragma warning(disable: 4514 4820)

#pragma pack(push, 8)
# 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\limits.h" 3
#pragma pack(pop)

#pragma warning(pop)
# 22 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\limits.h" 2 3
# 32 "././m-core.h" 2



# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_malloc.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_malloc.h" 3
#pragma pack(push, 8)
# 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_malloc.h" 3
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
         size_t _Count,
         size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl calloc(
                            size_t _Count,
                            size_t _Size
    );


__declspec(dllimport) int __cdecl _callnewh(
         size_t _Size
    );


__declspec(dllimport) __declspec(allocator)
void* __cdecl _expand(
                            void* _Block,
                            size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
                                   void* _Block
    );

__declspec(dllimport)
void __cdecl free(
                                   void* _Block
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
         size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl malloc(
                            size_t _Size
    );


__declspec(dllimport)
size_t __cdecl _msize_base(
                  void* _Block
    );


__declspec(dllimport)
size_t __cdecl _msize(
                  void* _Block
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
                                    void* _Block,
                                    size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl realloc(
                                   void* _Block,
                                   size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
                                   void* _Block
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
                            size_t _Size,
                            size_t _Alignment
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
                            size_t _Size,
                            size_t _Alignment,
                            size_t _Offset
    );


__declspec(dllimport)
size_t __cdecl _aligned_msize(
                  void* _Block,
                  size_t _Alignment,
                  size_t _Offset
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
                                   void* _Block,
                                   size_t _Size,
                                   size_t _Alignment,
                                   size_t _Offset
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size,
                                   size_t _Alignment,
                                   size_t _Offset
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
                                   void* _Block,
                                   size_t _Size,
                                   size_t _Alignment
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size,
                                   size_t _Alignment
    );
# 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_malloc.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 2 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_search.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_search.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\stddef.h" 1 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_search.h" 2 3

#pragma pack(push, 8)


 typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);





    __declspec(dllimport) void* __cdecl bsearch_s(
                                                           void const* _Key,
                                                           void const* _Base,
                                                           rsize_t _NumOfElements,
                                                           rsize_t _SizeOfElements,
                               _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                           void* _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
                                                                void* _Base,
                                                                rsize_t _NumOfElements,
                                                                rsize_t _SizeOfElements,
                                _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                                void* _Context
        );






__declspec(dllimport) void* __cdecl bsearch(
                                                       void const* _Key,
                                                       void const* _Base,
                                                       size_t _NumOfElements,
                                                       size_t _SizeOfElements,
                        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
                                                            void* _Base,
                                                            size_t _NumOfElements,
                                                            size_t _SizeOfElements,
                        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lfind_s(
                                                          void const* _Key,
                                                          void const* _Base,
                                                          unsigned int* _NumOfElements,
                                                          size_t _SizeOfElements,
                                _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                          void* _Context
    );


__declspec(dllimport) void* __cdecl _lfind(
                                                          void const* _Key,
                                                          void const* _Base,
                                                          unsigned int* _NumOfElements,
                                                          unsigned int _SizeOfElements,
                             _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lsearch_s(
                                                                void const* _Key,
                                                                void* _Base,
                                                                unsigned int* _NumOfElements,
                                                                size_t _SizeOfElements,
                                      _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                                void* _Context
    );


__declspec(dllimport) void* __cdecl _lsearch(
                                                                void const* _Key,
                                                                void* _Base,
                                                                unsigned int* _NumOfElements,
                                                                unsigned int _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );
# 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_search.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                              void const* _Key,
                                                              void const* _Base,
                                                              unsigned int* _NumOfElements,
                                                              unsigned int _SizeOfElements,
                                 _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                   void const* _Key,
                                                                   void* _Base,
                                                                   unsigned int* _NumOfElements,
                                                                   unsigned int _SizeOfElements,
                                      _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );





#pragma pack(pop)
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 2 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
#pragma pack(push, 8)
# 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
 __declspec(dllimport) errno_t __cdecl _itow_s(
                                     int _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );
# 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow(int _Value, wchar_t *_Buffer, int _Radix);
# 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                     long _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );
# 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow(long _Value, wchar_t *_Buffer, int _Radix);







    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                     unsigned long _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );
# 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix);







    __declspec(dllimport) double __cdecl wcstod(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr
        );


    __declspec(dllimport) double __cdecl _wcstod_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 _locale_t _Locale
        );


    __declspec(dllimport) long __cdecl wcstol(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) long __cdecl _wcstol_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) long long __cdecl wcstoll(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) long long __cdecl _wcstoll_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) unsigned long __cdecl wcstoul(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) long double __cdecl wcstold(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr
        );


    __declspec(dllimport) long double __cdecl _wcstold_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 _locale_t _Locale
        );


    __declspec(dllimport) float __cdecl wcstof(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr
        );


    __declspec(dllimport) float __cdecl _wcstof_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 _locale_t _Locale
        );


    __declspec(dllimport) double __cdecl _wtof(
               wchar_t const* _String
        );


    __declspec(dllimport) double __cdecl _wtof_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) int __cdecl _wtoi(
               wchar_t const* _String
        );


    __declspec(dllimport) int __cdecl _wtoi_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) long __cdecl _wtol(
               wchar_t const* _String
        );


    __declspec(dllimport) long __cdecl _wtol_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) long long __cdecl _wtoll(
               wchar_t const* _String
        );


    __declspec(dllimport) long long __cdecl _wtoll_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                     __int64 _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                               __int64 _Value,
                               wchar_t* _Buffer,
                               int _Radix
        );


    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                     unsigned __int64 _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                               unsigned __int64 _Value,
                               wchar_t* _Buffer,
                               int _Radix
        );


    __declspec(dllimport) __int64 __cdecl _wtoi64(
               wchar_t const* _String
        );


    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );






    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
                                         wchar_t* _Buffer,
                                         wchar_t const* _Path,
                                         size_t _BufferCount
        );




    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     wchar_t const* _Drive,
                                     wchar_t const* _Dir,
                                     wchar_t const* _Filename,
                                     wchar_t const* _Ext
        );
# 362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath( wchar_t *_Buffer, wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);







#pragma warning(pop)

 __declspec(dllimport) void __cdecl _wperror(
                   wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl _wsplitpath(
                                 wchar_t const* _FullPath,
                                 wchar_t* _Drive,
                                 wchar_t* _Dir,
                                 wchar_t* _Filename,
                                 wchar_t* _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                           wchar_t const* _FullPath,
                                           wchar_t* _Drive,
                                           size_t _DriveCount,
                                           wchar_t* _Dir,
                                           size_t _DirCount,
                                           wchar_t* _Filename,
                                           size_t _FilenameCount,
                                           wchar_t* _Ext,
                                           size_t _ExtCount
        );
# 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
                                                                                        wchar_t** _Buffer,
                                                                                        size_t* _BufferCount,
                                                                                        wchar_t const* _VarName
            );



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
                   wchar_t const* _VarName
            );



        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                             size_t* _RequiredCount,
                                             wchar_t* _Buffer,
                                             size_t _BufferCount,
                                             wchar_t const* _VarName
            );
# 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
        __declspec(dllimport) int __cdecl _wputenv(
                   wchar_t const* _EnvString
            );


        __declspec(dllimport) errno_t __cdecl _wputenv_s(
                   wchar_t const* _Name,
                   wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                         wchar_t const* _Filename,
                                         wchar_t const* _VarName,
                                         wchar_t* _Buffer,
                                         size_t _BufferCount
            );
# 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h" 3
        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t *_ResultPath);






        __declspec(dllimport) int __cdecl _wsystem(
                       wchar_t const* _Command
            );





#pragma pack(pop)
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 2 3


#pragma pack(push, 8)
# 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) void __cdecl _swab(
                                                                     char* _Buf1,
                                                                     char* _Buf2,
                                                                     int _SizeInBytes
    );
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
    __declspec(dllimport) __declspec(noreturn) void __cdecl exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);






__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
         unsigned int _Flags,
         unsigned int _Mask
    );






    typedef int (__cdecl* _onexit_t)(void);
# 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
    int __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit( _onexit_t _Func);


int __cdecl at_quick_exit(void (__cdecl*)(void));
# 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
    typedef void (__cdecl* _purecall_handler)(void);


    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );


             _purecall_handler __cdecl _set_purecall_handler(
                 _purecall_handler _Handler
        );

             _purecall_handler __cdecl _get_purecall_handler(void);


    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
                 _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
                 _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
# 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
                   __declspec(dllimport) int __cdecl _set_error_mode( int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);


    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);


    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);


    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);


    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);


    __declspec(dllimport) void __cdecl perror( char const* _ErrMsg);





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char** __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int* __cdecl __p__fmode (void);
# 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) errno_t __cdecl _get_pgmptr ( char** _Value);


__declspec(dllimport) errno_t __cdecl _get_wpgmptr( wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode ( int _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode ( int* _PMode);
# 271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

               int __cdecl abs ( int _Number);
               long __cdecl labs ( long _Number);
               long long __cdecl llabs ( long long _Number);
               __int64 __cdecl _abs64( __int64 _Number);

               unsigned short __cdecl _byteswap_ushort( unsigned short _Number);
               unsigned long __cdecl _byteswap_ulong ( unsigned long _Number);
               unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64 _Number);

               __declspec(dllimport) div_t __cdecl div ( int _Numerator, int _Denominator);
               __declspec(dllimport) ldiv_t __cdecl ldiv ( long _Numerator, long _Denominator);
               __declspec(dllimport) lldiv_t __cdecl lldiv( long long _Numerator, long long _Denominator);



#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
         unsigned int _Value,
         int _Shift
    );


unsigned long __cdecl _lrotl(
         unsigned long _Value,
         int _Shift
    );

unsigned __int64 __cdecl _rotl64(
         unsigned __int64 _Value,
         int _Shift
    );

unsigned int __cdecl _rotr(
         unsigned int _Value,
         int _Shift
    );


unsigned long __cdecl _lrotr(
         unsigned long _Value,
         int _Shift
    );

unsigned __int64 __cdecl _rotr64(
         unsigned __int64 _Value,
         int _Shift
    );

#pragma warning(pop)






__declspec(dllimport) void __cdecl srand( unsigned int _Seed);

               __declspec(dllimport) int __cdecl rand(void);
# 390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
#pragma pack(push, 4)
 typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
#pragma pack(pop)
# 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








 __declspec(dllimport) double __cdecl atof ( char const* _String);
                                  __declspec(dllimport) int __cdecl atoi ( char const* _String);
                                  __declspec(dllimport) long __cdecl atol ( char const* _String);
                                  __declspec(dllimport) long long __cdecl atoll ( char const* _String);
                                  __declspec(dllimport) __int64 __cdecl _atoi64( char const* _String);

               __declspec(dllimport) double __cdecl _atof_l ( char const* _String, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _atoi_l ( char const* _String, _locale_t _Locale);
               __declspec(dllimport) long __cdecl _atol_l ( char const* _String, _locale_t _Locale);
               __declspec(dllimport) long long __cdecl _atoll_l ( char const* _String, _locale_t _Locale);
               __declspec(dllimport) __int64 __cdecl _atoi64_l( char const* _String, _locale_t _Locale);

               __declspec(dllimport) int __cdecl _atoflt ( _CRT_FLOAT* _Result, char const* _String);
               __declspec(dllimport) int __cdecl _atodbl ( _CRT_DOUBLE* _Result, char* _String);
               __declspec(dllimport) int __cdecl _atoldbl( _LDOUBLE* _Result, char* _String);


__declspec(dllimport) int __cdecl _atoflt_l(
             _CRT_FLOAT* _Result,
             char const* _String,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _atodbl_l(
             _CRT_DOUBLE* _Result,
             char* _String,
             _locale_t _Locale
    );



__declspec(dllimport) int __cdecl _atoldbl_l(
             _LDOUBLE* _Result,
             char* _String,
             _locale_t _Locale
    );


__declspec(dllimport) float __cdecl strtof(
                             char const* _String,
                             char** _EndPtr
    );


__declspec(dllimport) float __cdecl _strtof_l(
                             char const* _String,
                             char** _EndPtr,
                             _locale_t _Locale
    );


__declspec(dllimport) double __cdecl strtod(
                             char const* _String,
                             char** _EndPtr
    );


__declspec(dllimport) double __cdecl _strtod_l(
                             char const* _String,
                             char** _EndPtr,
                             _locale_t _Locale
    );


__declspec(dllimport) long double __cdecl strtold(
                             char const* _String,
                             char** _EndPtr
    );


__declspec(dllimport) long double __cdecl _strtold_l(
                             char const* _String,
                             char** _EndPtr,
                             _locale_t _Locale
    );


__declspec(dllimport) long __cdecl strtol(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) long __cdecl _strtol_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) long long __cdecl strtoll(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) long long __cdecl _strtoll_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) unsigned long __cdecl strtoul(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) unsigned long long __cdecl strtoull(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) __int64 __cdecl _strtoi64(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );
# 622 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) errno_t __cdecl _itoa_s(
                                 int _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );
# 637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa(int _Value, char *_Buffer, int _Radix);





#pragma warning(pop)



__declspec(dllimport) errno_t __cdecl _ltoa_s(
                                 long _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );
# 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa(long _Value, char *_Buffer, int _Radix);
# 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) errno_t __cdecl _ultoa_s(
                                 unsigned long _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );








#pragma warning(push)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa(unsigned long _Value, char *_Buffer, int _Radix);





#pragma warning(pop)



__declspec(dllimport) errno_t __cdecl _i64toa_s(
                                 __int64 _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                           __int64 _Value,
                           char* _Buffer,
                           int _Radix
    );



__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                                 unsigned __int64 _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                           unsigned __int64 _Value,
                           char* _Buffer,
                           int _Radix
    );
# 744 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) errno_t __cdecl _ecvt_s(
                                 char* _Buffer,
          size_t _BufferCount,
          double _Value,
          int _DigitCount,
          int* _PtDec,
          int* _PtSign
    );
# 762 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
          double _Value,
          int _DigitCount,
          int* _PtDec,
          int* _PtSign
    );



__declspec(dllimport) errno_t __cdecl _fcvt_s(
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 double _Value,
                                 int _FractionalDigitCount,
                                 int* _PtDec,
                                 int* _PtSign
    );
# 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
          double _Value,
          int _FractionalDigitCount,
          int* _PtDec,
          int* _PtSign
    );


__declspec(dllimport) errno_t __cdecl _gcvt_s(
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 double _Value,
                                 int _DigitCount
    );
# 816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                           double _Value,
                           int _DigitCount,
                           char* _Buffer
    );
# 855 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) int __cdecl mblen(
                                                char const* _Ch,
                                                size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _mblen_l(
                                                char const* _Ch,
                                                size_t _MaxCount,
                                                _locale_t _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrlen(
           char const* _String
    );



__declspec(dllimport) size_t __cdecl _mbstrlen_l(
             char const* _String,
             _locale_t _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen(
           char const* _String,
           size_t _MaxCount
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
             char const* _String,
             size_t _MaxCount,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl mbtowc(
                                         wchar_t* _DstCh,
                                         char const* _SrcCh,
                                         size_t _SrcSizeInBytes
    );


__declspec(dllimport) int __cdecl _mbtowc_l(
                                         wchar_t* _DstCh,
                                         char const* _SrcCh,
                                         size_t _SrcSizeInBytes,
                                         _locale_t _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                              size_t* _PtNumOfCharConverted,
                                                              wchar_t* _DstBuf,
                                                              size_t _SizeInWords,
                                                              char const* _SrcBuf,
                                                              size_t _MaxCount
    );
# 927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest, char const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                              size_t* _PtNumOfCharConverted,
                                                              wchar_t* _DstBuf,
                                                              size_t _SizeInWords,
                                                              char const* _SrcBuf,
                                                              size_t _MaxCount,
                                                              _locale_t _Locale
    );
# 953 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l( wchar_t *_Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);
# 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
                                   char* _MbCh,
                                   wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
                             char* _MbCh,
                             wchar_t _WCh,
                             _locale_t _Locale
    );




    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                                 int* _SizeConverted,
                                                                 char* _MbCh,
                                                                 rsize_t _SizeInBytes,
                                                                 wchar_t _WCh
        );




__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                                     int* _SizeConverted,
                                     char* _MbCh,
                                     size_t _SizeInBytes,
                                     wchar_t _WCh,
                                     _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                                       size_t* _PtNumOfCharConverted,
                                                                       char* _Dst,
                                                                       size_t _DstSizeInBytes,
                                                                       wchar_t const* _Src,
                                                                       size_t _MaxCountInBytes
    );
# 1015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest, wchar_t const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                                       size_t* _PtNumOfCharConverted,
                                                                       char* _Dst,
                                                                       size_t _DstSizeInBytes,
                                                                       wchar_t const* _Src,
                                                                       size_t _MaxCountInBytes,
                                                                       _locale_t _Locale
    );
# 1041 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l( char *_Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);
# 1071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
                                     char* _Buffer,
                                     char const* _Path,
                                     size_t _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 char const* _Drive,
                                 char const* _Dir,
                                 char const* _Filename,
                                 char const* _Ext
    );
# 1098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath( char *_Buffer, char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext);







#pragma warning(pop)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                             char const* _FullPath,
                             char* _Drive,
                             char* _Dir,
                             char* _Filename,
                             char* _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                       char const* _FullPath,
                                       char* _Drive,
                                       size_t _DriveCount,
                                       char* _Dir,
                                       size_t _DirCount,
                                       char* _Filename,
                                       size_t _FilenameCount,
                                       char* _Ext,
                                       size_t _ExtCount
    );







__declspec(dllimport) errno_t __cdecl getenv_s(
                                     size_t* _RequiredCount,
                                     char* _Buffer,
                                     rsize_t _BufferCount,
                                     char const* _VarName
    );






__declspec(dllimport) int* __cdecl __p___argc (void);
__declspec(dllimport) char*** __cdecl __p___argv (void);
__declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);
# 1165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) char*** __cdecl __p__environ (void);
__declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);
# 1190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl getenv(
               char const* _VarName
        );
# 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
                                                                                    char** _Buffer,
                                                                                    size_t* _BufferCount,
                                                                                    char const* _VarName
        );





    __declspec(dllimport) int __cdecl system(
                   char const* _Command
        );



#pragma warning(push)
#pragma warning(disable: 6540)


 __declspec(dllimport) int __cdecl _putenv(
               char const* _EnvString
        );


    __declspec(dllimport) errno_t __cdecl _putenv_s(
               char const* _Name,
               char const* _Value
        );

#pragma warning(pop)

 __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                     char const* _Filename,
                                     char const* _VarName,
                                     char* _Buffer,
                                     size_t _BufferCount
        );
# 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv(char const* _Filename, char const* _VarName, char *_Buffer);







    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
             int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
             unsigned _Frequency,
             unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
             unsigned long _Duration
        );
# 1296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h" 3
#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
              double _Value,
              int _DigitCount,
              int* _PtDec,
              int* _PtSign
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
              double _Value,
              int _FractionalDigitCount,
              int* _PtDec,
              int* _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                               double _Value,
                               int _DigitCount,
                               char* _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                               int _Value,
                               char* _Buffer,
                               int _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                               long _Value,
                               char* _Buffer,
                               int _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
                                        char* _Buf1,
                                        char* _Buf2,
                                        int _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                               unsigned long _Value,
                               char* _Buffer,
                               int _Radix
        );



                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
    __declspec(dllimport) int __cdecl putenv(
               char const* _EnvString
        );

#pragma warning(pop)

 _onexit_t __cdecl onexit( _onexit_t _Func);





#pragma pack(pop)
# 36 "././m-core.h" 2
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\assert.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\assert.h" 3
#pragma pack(push, 8)
# 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\assert.h" 3
 __declspec(dllimport) void __cdecl _wassert(
               wchar_t const* _Message,
               wchar_t const* _File,
               unsigned _Line
        );
# 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\assert.h" 3
#pragma pack(pop)
# 37 "././m-core.h" 2
# 204 "././m-core.h"
#pragma clang diagnostic push
# 204 "././m-core.h"
#pragma clang diagnostic ignored "-Wunused-function"
# 204 "././m-core.h"
#pragma clang diagnostic ignored "-Wformat-nonliteral"
# 2105 "././m-core.h"
static inline FILE *
m_core_fopen(const char filename[], const char opt[])
{
    FILE *f;
    int err = fopen_s(&f, filename, opt);
    if (err) return ((void*)0);
    return f;
}
# 2172 "././m-core.h"
static inline _Bool
m_core_fscan_bool (_Bool *ptr, FILE *f)
{
  int c = fgetc(f);
  *ptr = (c == '1');
  return (c == '0' || c == '1');
}

static inline _Bool
m_core_fscan_char (char *ptr, FILE *f)
{
  int c = fgetc(f);
  *ptr = (char) c;
  return c != (-1);
}







static inline _Bool m_core_fscan_schar (signed char *ptr, FILE *f) { return fscanf_s(f, "%hhd", ptr) == 1; }
static inline _Bool m_core_fscan_uchar (unsigned char *ptr, FILE *f) { return fscanf_s(f, "%hhu", ptr) == 1; }
static inline _Bool m_core_fscan_sshort (signed short *ptr, FILE *f) { return fscanf_s(f, "%hd", ptr) == 1; }
static inline _Bool m_core_fscan_ushort (unsigned short *ptr, FILE *f) { return fscanf_s(f, "%hu", ptr) == 1; }
static inline _Bool m_core_fscan_sint (signed int *ptr, FILE *f) { return fscanf_s(f, "%d", ptr) == 1; }
static inline _Bool m_core_fscan_uint (unsigned int *ptr, FILE *f) { return fscanf_s(f, "%u", ptr) == 1; }
static inline _Bool m_core_fscan_slong (signed long *ptr, FILE *f) { return fscanf_s(f, "%ld", ptr) == 1; }
static inline _Bool m_core_fscan_ulong (unsigned long *ptr, FILE *f) { return fscanf_s(f, "%lu", ptr) == 1; }
static inline _Bool m_core_fscan_sllong (signed long long *ptr, FILE *f) { return fscanf_s(f, "%lld", ptr) == 1; }
static inline _Bool m_core_fscan_ullong (unsigned long long *ptr, FILE *f) { return fscanf_s(f, "%llu", ptr) == 1; }
static inline _Bool m_core_fscan_float (float *ptr, FILE *f) { return fscanf_s(f, "%f", ptr) == 1; }
static inline _Bool m_core_fscan_double (double *ptr, FILE *f) { return fscanf_s(f, "%lf", ptr) == 1; }
static inline _Bool m_core_fscan_ldouble (long double *ptr, FILE *f) { return fscanf_s(f, "%Lf", ptr) == 1; }
# 2240 "././m-core.h"
static inline _Bool
m_core_parse_char (char *ptr, const char str[], const char **endptr)
{
    *ptr = *str++;
    if (endptr != ((void*)0)) *endptr = str;
    return 1;
}

static inline _Bool
m_core_parse_bool (_Bool *ptr, const char str[], const char **endptr)
{
  char c = *str++;
  *ptr = (c == '1');
  if (endptr != ((void*)0)) *endptr = str;
  return (c == '0' || c == '1');
}
# 2267 "././m-core.h"
static inline _Bool m_core_parse_schar (signed char *ptr, const char str[], const char **endptr) { char *end; *ptr = (signed char) strtol (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_uchar (unsigned char *ptr, const char str[], const char **endptr) { char *end; *ptr = (unsigned char) strtoul (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_sshort (signed short *ptr, const char str[], const char **endptr) { char *end; *ptr = (signed short) strtol (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_ushort (unsigned short *ptr, const char str[], const char **endptr) { char *end; *ptr = (unsigned short) strtoul (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_sint (signed int *ptr, const char str[], const char **endptr) { char *end; *ptr = (signed int) strtol (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_uint (unsigned int *ptr, const char str[], const char **endptr) { char *end; *ptr = (unsigned int) strtoul (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_slong (signed long *ptr, const char str[], const char **endptr) { char *end; *ptr = (signed long) strtol (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_ulong (unsigned long *ptr, const char str[], const char **endptr) { char *end; *ptr = (unsigned long) strtoul (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_sllong (signed long long *ptr, const char str[], const char **endptr) { char *end; *ptr = (signed long long) strtoll (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_ullong (unsigned long long *ptr, const char str[], const char **endptr) { char *end; *ptr = (unsigned long long) strtoull (str, &end , 10); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_float (float *ptr, const char str[], const char **endptr) { char *end; *ptr = (float) strtof (str, &end ); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_double (double *ptr, const char str[], const char **endptr) { char *end; *ptr = (double) strtod (str, &end ); if (endptr != ((void*)0)) *endptr = end; return end != str; }
static inline _Bool m_core_parse_ldouble (long double *ptr, const char str[], const char **endptr) { char *end; *ptr = (long double) strtold (str, &end ); if (endptr != ((void*)0)) *endptr = end; return end != str; }
# 2434 "././m-core.h"
static inline uint32_t m_core_rotl32a (uint32_t x, uint32_t n)
{
  (void)( (!!(n > 0 && n<32)) || (_wassert(L"n > 0 && n<32", L"././m-core.h", (unsigned)(2436)), 0) );
  return (x<<n) | (x>>(32-n));
}
static inline uint64_t m_core_rotl64a (uint64_t x, uint32_t n)
{
  (void)( (!!(n > 0 && n<64)) || (_wassert(L"n > 0 && n<64", L"././m-core.h", (unsigned)(2441)), 0) );
  return (x<<n) | (x>>(64-n));
}




static inline uint64_t m_core_roundpow2(uint64_t v)
{
  v--;
  v |= v >> 1;
  v |= v >> 2;
  v |= v >> 4;
  v |= v >> 8;
  v |= v >> 16;
  v |= v >> 32;
  v++;
  return v;
}
# 2474 "././m-core.h"
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\intrin.h" 1 3
# 20 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\intrin.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\x86intrin.h" 1 3
# 13 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\x86intrin.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 1 3
# 29 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__))
__bsfd(int __A) {
  return __builtin_ctz(__A);
}
# 46 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__))
__bsrd(int __A) {
  return 31 - __builtin_clz(__A);
}
# 62 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__))
__bswapd(int __A) {
  return __builtin_bswap32(__A);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_bswap(int __A) {
  return __builtin_bswap32(__A);
}
# 88 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__))
__bsfq(long long __A) {
  return __builtin_ctzll(__A);
}
# 105 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__))
__bsrq(long long __A) {
  return 63 - __builtin_clzll(__A);
}
# 121 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__))
__bswapq(long long __A) {
  return __builtin_bswap64(__A);
}
# 141 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__))
__popcntd(unsigned int __A)
{
  return __builtin_popcount(__A);
}
# 162 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__))
__popcntq(unsigned long long __A)
{
  return __builtin_popcountll(__A);
}





static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__readeflags(void)
{
  return __builtin_ia32_readeflags_u64();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
__writeeflags(unsigned long long __f)
{
  __builtin_ia32_writeeflags_u64(__f);
}
# 208 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ unsigned int __attribute__((__always_inline__))
_castf32_u32(float __A) {
  unsigned int D;
  __builtin_memcpy(&D, &__A, sizeof(__A));
  return D;
}
# 225 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ unsigned long long __attribute__((__always_inline__))
_castf64_u64(double __A) {
  unsigned long long D;
  __builtin_memcpy(&D, &__A, sizeof(__A));
  return D;
}
# 242 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ float __attribute__((__always_inline__))
_castu32_f32(unsigned int __A) {
  float D;
  __builtin_memcpy(&D, &__A, sizeof(__A));
  return D;
}
# 259 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ double __attribute__((__always_inline__))
_castu64_f64(unsigned long long __A) {
  double D;
  __builtin_memcpy(&D, &__A, sizeof(__A));
  return D;
}
# 281 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
__crc32b(unsigned int __C, unsigned char __D)
{
  return __builtin_ia32_crc32qi(__C, __D);
}
# 302 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
__crc32w(unsigned int __C, unsigned short __D)
{
  return __builtin_ia32_crc32hi(__C, __D);
}
# 323 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
__crc32d(unsigned int __C, unsigned int __D)
{
  return __builtin_ia32_crc32si(__C, __D);
}
# 345 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\ia32intrin.h" 3
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
__crc32q(unsigned long long __C, unsigned long long __D)
{
  return __builtin_ia32_crc32di(__C, __D);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdpmc(int __A) {
  return __builtin_ia32_rdpmc(__A);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdtscp(unsigned int *__A) {
  return __builtin_ia32_rdtscp(__A);
}





static __inline__ void __attribute__((__always_inline__, __nodebug__))
_wbinvd(void) {
  __builtin_ia32_wbinvd();
}

static __inline__ unsigned char __attribute__((__always_inline__, __nodebug__))
__rolb(unsigned char __X, int __C) {
  return __builtin_rotateleft8(__X, __C);
}

static __inline__ unsigned char __attribute__((__always_inline__, __nodebug__))
__rorb(unsigned char __X, int __C) {
  return __builtin_rotateright8(__X, __C);
}

static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__))
__rolw(unsigned short __X, int __C) {
  return __builtin_rotateleft16(__X, __C);
}

static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__))
__rorw(unsigned short __X, int __C) {
  return __builtin_rotateright16(__X, __C);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
__rold(unsigned int __X, int __C) {
  return __builtin_rotateleft32(__X, __C);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
__rord(unsigned int __X, int __C) {
  return __builtin_rotateright32(__X, __C);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rolq(unsigned long long __X, int __C) {
  return __builtin_rotateleft64(__X, __C);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rorq(unsigned long long __X, int __C) {
  return __builtin_rotateright64(__X, __C);
}
# 14 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\x86intrin.h" 2 3

# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 1 3
# 15 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 1 3
# 13 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
typedef long long __m64 __attribute__((__vector_size__(8), __aligned__(8)));

typedef long long __v1di __attribute__((__vector_size__(8)));
typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));
# 30 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_empty(void)
{
    __builtin_ia32_emms();
}
# 47 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}
# 64 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}
# 80 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}
# 96 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}
# 126 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}
# 156 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}
# 186 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}
# 213 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}
# 236 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}
# 257 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}
# 284 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}
# 307 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}
# 328 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}
# 349 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}
# 370 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}
# 391 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}
# 413 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}
# 436 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}
# 458 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}
# 480 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}
# 501 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}
# 522 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}
# 543 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}
# 566 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}
# 589 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}
# 613 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}
# 637 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}
# 664 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}
# 685 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}
# 706 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}
# 729 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}
# 751 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}
# 774 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}
# 796 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}
# 816 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq((__v1di)__m, __count);
}
# 836 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi((__v1di)__m, __count);
}
# 860 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}
# 883 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}
# 907 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}
# 930 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}
# 953 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}
# 975 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}
# 998 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}
# 1020 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}
# 1040 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq((__v1di)__m, __count);
}
# 1061 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi((__v1di)__m, __count);
}
# 1079 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand((__v1di)__m1, (__v1di)__m2);
}
# 1100 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn((__v1di)__m1, (__v1di)__m2);
}
# 1118 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por((__v1di)__m1, (__v1di)__m2);
}
# 1136 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor((__v1di)__m1, (__v1di)__m2);
}
# 1158 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}
# 1180 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}
# 1202 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}
# 1224 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}
# 1246 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}
# 1268 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}
# 1281 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setzero_si64(void)
{
    return __extension__ (__m64){ 0LL };
}
# 1302 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}
# 1325 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}
# 1356 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}
# 1377 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}
# 1396 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}
# 1414 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}
# 1435 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}
# 1458 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}
# 1489 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 16 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 2 3




# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 1 3
# 15 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16), __aligned__(16)));

typedef float __m128_u __attribute__((__vector_size__(16), __aligned__(1)));


typedef unsigned int __v4su __attribute__((__vector_size__(16)));





# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mm_malloc.h" 1 3
# 16 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mm_malloc.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\malloc.h" 1 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\malloc.h" 3
#pragma pack(push, 8)
# 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\malloc.h" 3
typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;
# 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\malloc.h" 3
void* __cdecl _alloca( size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);


    __declspec(dllimport) int __cdecl _heapmin(void);


        __declspec(dllimport) int __cdecl _heapwalk( _HEAPINFO* _EntryInfo);



                       __declspec(dllimport) int __cdecl _heapchk(void);


    __declspec(dllimport) int __cdecl _resetstkoflw(void);
# 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\malloc.h" 3
    typedef char __static_assert_t[(sizeof(unsigned int) <= 16) != 0];


#pragma warning(push)
#pragma warning(disable: 6540)

 __inline void* _MarkAllocaS( void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

#pragma warning(pop)
# 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\malloc.h" 3
#pragma warning(push)
#pragma warning(disable: 6014)
 __inline void __cdecl _freea( void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }






        }
    }
#pragma warning(pop)
# 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\malloc.h" 3
#pragma pack(pop)
# 17 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\mm_malloc.h" 2 3
# 28 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 2 3
# 49 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}
# 69 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a + (__v4sf)__b);
}
# 91 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}
# 112 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a - (__v4sf)__b);
}
# 134 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}
# 154 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a * (__v4sf)__b);
}
# 176 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}
# 195 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a / (__v4sf)__b);
}
# 213 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sqrt_ss(__m128 __a)
{
  return (__m128)__builtin_ia32_sqrtss((__v4sf)__a);
}
# 230 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps((__v4sf)__a);
}
# 248 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rcp_ss(__m128 __a)
{
  return (__m128)__builtin_ia32_rcpss((__v4sf)__a);
}
# 265 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rcp_ps(__m128 __a)
{
  return (__m128)__builtin_ia32_rcpps((__v4sf)__a);
}
# 284 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rsqrt_ss(__m128 __a)
{
  return __builtin_ia32_rsqrtss((__v4sf)__a);
}
# 301 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps((__v4sf)__a);
}
# 324 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss((__v4sf)__a, (__v4sf)__b);
}
# 343 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps((__v4sf)__a, (__v4sf)__b);
}
# 366 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss((__v4sf)__a, (__v4sf)__b);
}
# 385 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps((__v4sf)__a, (__v4sf)__b);
}
# 403 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a & (__v4su)__b);
}
# 425 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4su)__a & (__v4su)__b);
}
# 443 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a | (__v4su)__b);
}
# 462 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a ^ (__v4su)__b);
}
# 484 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqss((__v4sf)__a, (__v4sf)__b);
}
# 502 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqps((__v4sf)__a, (__v4sf)__b);
}
# 525 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltss((__v4sf)__a, (__v4sf)__b);
}
# 544 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__a, (__v4sf)__b);
}
# 568 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpless((__v4sf)__a, (__v4sf)__b);
}
# 587 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__a, (__v4sf)__b);
}
# 610 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 631 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__b, (__v4sf)__a);
}
# 655 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 676 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__b, (__v4sf)__a);
}
# 699 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqss((__v4sf)__a, (__v4sf)__b);
}
# 718 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqps((__v4sf)__a, (__v4sf)__b);
}
# 742 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltss((__v4sf)__a, (__v4sf)__b);
}
# 762 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__a, (__v4sf)__b);
}
# 787 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnless((__v4sf)__a, (__v4sf)__b);
}
# 807 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__a, (__v4sf)__b);
}
# 832 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 854 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__b, (__v4sf)__a);
}
# 879 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 901 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__b, (__v4sf)__a);
}
# 926 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordss((__v4sf)__a, (__v4sf)__b);
}
# 946 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordps((__v4sf)__a, (__v4sf)__b);
}
# 971 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordss((__v4sf)__a, (__v4sf)__b);
}
# 991 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordps((__v4sf)__a, (__v4sf)__b);
}
# 1015 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq((__v4sf)__a, (__v4sf)__b);
}
# 1040 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt((__v4sf)__a, (__v4sf)__b);
}
# 1064 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile((__v4sf)__a, (__v4sf)__b);
}
# 1088 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt((__v4sf)__a, (__v4sf)__b);
}
# 1112 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige((__v4sf)__a, (__v4sf)__b);
}
# 1136 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq((__v4sf)__a, (__v4sf)__b);
}
# 1160 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq((__v4sf)__a, (__v4sf)__b);
}
# 1184 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt((__v4sf)__a, (__v4sf)__b);
}
# 1209 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile((__v4sf)__a, (__v4sf)__b);
}
# 1234 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt((__v4sf)__a, (__v4sf)__b);
}
# 1259 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige((__v4sf)__a, (__v4sf)__b);
}
# 1283 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq((__v4sf)__a, (__v4sf)__b);
}
# 1301 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si((__v4sf)__a);
}
# 1319 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}
# 1339 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64((__v4sf)__a);
}
# 1357 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi((__v4sf)__a);
}
# 1373 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}
# 1392 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvttss_si32(__m128 __a)
{
  return __builtin_ia32_cvttss2si((__v4sf)__a);
}
# 1411 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}
# 1431 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvttss_si64(__m128 __a)
{
  return __builtin_ia32_cvttss2si64((__v4sf)__a);
}
# 1450 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi((__v4sf)__a);
}
# 1467 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}
# 1489 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}
# 1512 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}
# 1536 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}
# 1562 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps((__v4sf)__a, (__v2si)__b);
}
# 1585 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}
# 1602 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}
# 1623 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((const struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}
# 1650 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((const struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}
# 1677 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((const struct __mm_load_ss_struct*)__p)->__u;
  return __extension__ (__m128){ __u, 0, 0, 0 };
}
# 1699 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((const struct __mm_load1_ps_struct*)__p)->__u;
  return __extension__ (__m128){ __u, __u, __u, __u };
}
# 1722 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load_ps(const float *__p)
{
  return *(const __m128*)__p;
}
# 1739 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_ps*)__p)->__v;
}
# 1761 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
}
# 1775 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_undefined_ps(void)
{
  return (__m128)__builtin_ia32_undef128();
}
# 1795 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ss(float __w)
{
  return __extension__ (__m128){ __w, 0, 0, 0 };
}
# 1813 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set1_ps(float __w)
{
  return __extension__ (__m128){ __w, __w, __w, __w };
}
# 1832 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}
# 1859 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return __extension__ (__m128){ __w, __x, __y, __z };
}
# 1887 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return __extension__ (__m128){ __z, __y, __x, __w };
}
# 1902 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_setzero_ps(void)
{
  return __extension__ (__m128){ 0, 0, 0, 0 };
}
# 1919 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  typedef float __mm_storeh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_storeh_pi_struct {
    __mm_storeh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pi_struct*)__p)->__u = __builtin_shufflevector(__a, __a, 2, 3);
}
# 1940 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  typedef float __mm_storeh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_storeh_pi_struct {
    __mm_storeh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pi_struct*)__p)->__u = __builtin_shufflevector(__a, __a, 0, 1);
}
# 1961 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}
# 1982 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storeu_ps(float *__p, __m128 __a)
{
  struct __storeu_ps {
    __m128_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_ps*)__p)->__v = __a;
}
# 2003 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128*)__p = __a;
}
# 2022 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 0, 0, 0);
  _mm_store_ps(__p, __a);
}
# 2042 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ps1(float *__p, __m128 __a)
{
  _mm_store1_ps(__p, __a);
}
# 2061 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}
# 2119 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}
# 2138 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_nontemporal_store((__v4sf)__a, (__v4sf*)__p);
}
# 2157 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
void _mm_sfence(void);
# 2230 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}
# 2249 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}
# 2268 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}
# 2287 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}
# 2305 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}
# 2324 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}
# 2387 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}
# 2406 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}
# 2425 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}
# 2447 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}
# 2507 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
unsigned int _mm_getcsr(void);
# 2561 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
void _mm_setcsr(unsigned int __i);
# 2623 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 2, 6, 3, 7);
}
# 2645 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 4, 1, 5);
}
# 2667 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_move_ss(__m128 __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}
# 2689 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 6, 7, 2, 3);
}
# 2710 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 1, 4, 5);
}
# 2728 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 2758 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 2787 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 2812 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 2839 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}
# 2868 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}
# 2898 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}
# 2923 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps((__v4sf)__a);
}
# 3005 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 1 3
# 13 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 1 3
# 14 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 2 3

typedef double __m128d __attribute__((__vector_size__(16), __aligned__(16)));
typedef long long __m128i __attribute__((__vector_size__(16), __aligned__(16)));

typedef double __m128d_u __attribute__((__vector_size__(16), __aligned__(1)));
typedef long long __m128i_u __attribute__((__vector_size__(16), __aligned__(1)));


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));


typedef unsigned long long __v2du __attribute__ ((__vector_size__ (16)));
typedef unsigned short __v8hu __attribute__((__vector_size__(16)));
typedef unsigned char __v16qu __attribute__((__vector_size__(16)));



typedef signed char __v16qs __attribute__((__vector_size__(16)));
# 55 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_sd(__m128d __a, __m128d __b)
{
  __a[0] += __b[0];
  return __a;
}
# 74 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a + (__v2df)__b);
}
# 97 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_sd(__m128d __a, __m128d __b)
{
  __a[0] -= __b[0];
  return __a;
}
# 116 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a - (__v2df)__b);
}
# 138 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mul_sd(__m128d __a, __m128d __b)
{
  __a[0] *= __b[0];
  return __a;
}
# 157 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mul_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a * (__v2df)__b);
}
# 180 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_div_sd(__m128d __a, __m128d __b)
{
  __a[0] /= __b[0];
  return __a;
}
# 200 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_div_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a / (__v2df)__b);
}
# 225 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sqrt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_sqrtsd((__v2df)__b);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 243 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sqrt_pd(__m128d __a)
{
  return __builtin_ia32_sqrtpd((__v2df)__a);
}
# 267 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_min_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minsd((__v2df)__a, (__v2df)__b);
}
# 287 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_min_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minpd((__v2df)__a, (__v2df)__b);
}
# 311 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_max_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxsd((__v2df)__a, (__v2df)__b);
}
# 331 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_max_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxpd((__v2df)__a, (__v2df)__b);
}
# 349 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_and_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2du)__a & (__v2du)__b);
}
# 370 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_andnot_pd(__m128d __a, __m128d __b)
{
  return (__m128d)(~(__v2du)__a & (__v2du)__b);
}
# 388 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_or_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2du)__a | (__v2du)__b);
}
# 406 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_xor_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2du)__a ^ (__v2du)__b);
}
# 425 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpeqpd((__v2df)__a, (__v2df)__b);
}
# 445 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__a, (__v2df)__b);
}
# 466 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmple_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__a, (__v2df)__b);
}
# 487 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__b, (__v2df)__a);
}
# 508 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__b, (__v2df)__a);
}
# 531 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpordpd((__v2df)__a, (__v2df)__b);
}
# 555 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpunord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpunordpd((__v2df)__a, (__v2df)__b);
}
# 576 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpneq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpneqpd((__v2df)__a, (__v2df)__b);
}
# 597 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnlt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__a, (__v2df)__b);
}
# 618 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnle_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__a, (__v2df)__b);
}
# 639 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpngt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__b, (__v2df)__a);
}
# 660 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__b, (__v2df)__a);
}
# 683 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpeqsd((__v2df)__a, (__v2df)__b);
}
# 708 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltsd((__v2df)__a, (__v2df)__b);
}
# 733 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmple_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplesd((__v2df)__a, (__v2df)__b);
}
# 758 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpltsd((__v2df)__b, (__v2df)__a);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 784 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmplesd((__v2df)__b, (__v2df)__a);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 812 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpordsd((__v2df)__a, (__v2df)__b);
}
# 840 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpunord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpunordsd((__v2df)__a, (__v2df)__b);
}
# 865 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpneq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpneqsd((__v2df)__a, (__v2df)__b);
}
# 890 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnlt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltsd((__v2df)__a, (__v2df)__b);
}
# 915 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnle_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlesd((__v2df)__a, (__v2df)__b);
}
# 940 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpngt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpnltsd((__v2df)__b, (__v2df)__a);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 966 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpnlesd((__v2df)__b, (__v2df)__a);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 991 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdeq((__v2df)__a, (__v2df)__b);
}
# 1017 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdlt((__v2df)__a, (__v2df)__b);
}
# 1043 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdle((__v2df)__a, (__v2df)__b);
}
# 1069 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdgt((__v2df)__a, (__v2df)__b);
}
# 1095 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdge((__v2df)__a, (__v2df)__b);
}
# 1121 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdneq((__v2df)__a, (__v2df)__b);
}
# 1145 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdeq((__v2df)__a, (__v2df)__b);
}
# 1171 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdlt((__v2df)__a, (__v2df)__b);
}
# 1197 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdle((__v2df)__a, (__v2df)__b);
}
# 1223 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdgt((__v2df)__a, (__v2df)__b);
}
# 1249 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdge((__v2df)__a, (__v2df)__b);
}
# 1275 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdneq((__v2df)__a, (__v2df)__b);
}
# 1294 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtpd_ps(__m128d __a)
{
  return __builtin_ia32_cvtpd2ps((__v2df)__a);
}
# 1314 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtps_pd(__m128 __a)
{
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 1), __v2df);
}
# 1337 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtepi32_pd(__m128i __a)
{
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4si)__a, (__v4si)__a, 0, 1), __v2df);
}
# 1357 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtpd_epi32(__m128d __a)
{
  return __builtin_ia32_cvtpd2dq((__v2df)__a);
}
# 1374 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsd_si32(__m128d __a)
{
  return __builtin_ia32_cvtsd2si((__v2df)__a);
}
# 1399 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsd_ss(__m128 __a, __m128d __b)
{
  return (__m128)__builtin_ia32_cvtsd2ss((__v4sf)__a, (__v2df)__b);
}
# 1422 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi32_sd(__m128d __a, int __b)
{
  __a[0] = __b;
  return __a;
}
# 1448 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtss_sd(__m128d __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}
# 1472 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvttpd_epi32(__m128d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq((__v2df)__a);
}
# 1490 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvttsd_si32(__m128d __a)
{
  return __builtin_ia32_cvttsd2si((__v2df)__a);
}
# 1507 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_cvtpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvtpd2pi((__v2df)__a);
}
# 1527 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_cvttpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvttpd2pi((__v2df)__a);
}
# 1544 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_cvtpi32_pd(__m64 __a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}
# 1561 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsd_f64(__m128d __a)
{
  return __a[0];
}
# 1578 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load_pd(double const *__dp)
{
  return *(const __m128d*)__dp;
}
# 1596 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load1_pd(double const *__dp)
{
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_load1_pd_struct*)__dp)->__u;
  return __extension__ (__m128d){ __u, __u };
}
# 1622 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadr_pd(double const *__dp)
{
  __m128d __u = *(const __m128d*)__dp;
  return __builtin_shufflevector((__v2df)__u, (__v2df)__u, 1, 0);
}
# 1640 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_pd(double const *__dp)
{
  struct __loadu_pd {
    __m128d_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_pd*)__dp)->__v;
}
# 1660 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si64(void const *__a)
{
  struct __loadu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  long long __u = ((const struct __loadu_si64*)__a)->__v;
  return __extension__ (__m128i)(__v2di){__u, 0LL};
}
# 1681 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si32(void const *__a)
{
  struct __loadu_si32 {
    int __v;
  } __attribute__((__packed__, __may_alias__));
  int __u = ((const struct __loadu_si32*)__a)->__v;
  return __extension__ (__m128i)(__v4si){__u, 0, 0, 0};
}
# 1702 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si16(void const *__a)
{
  struct __loadu_si16 {
    short __v;
  } __attribute__((__packed__, __may_alias__));
  short __u = ((const struct __loadu_si16*)__a)->__v;
  return __extension__ (__m128i)(__v8hi){__u, 0, 0, 0, 0, 0, 0, 0};
}
# 1723 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load_sd(double const *__dp)
{
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_load_sd_struct*)__dp)->__u;
  return __extension__ (__m128d){ __u, 0 };
}
# 1750 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadh_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_loadh_pd_struct*)__dp)->__u;
  return __extension__ (__m128d){ __a[0], __u };
}
# 1777 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadl_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_loadl_pd_struct*)__dp)->__u;
  return __extension__ (__m128d){ __u, __a[1] };
}
# 1798 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_undefined_pd(void)
{
  return (__m128d)__builtin_ia32_undef128();
}
# 1818 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_sd(double __w)
{
  return __extension__ (__m128d){ __w, 0 };
}
# 1836 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_pd(double __w)
{
  return __extension__ (__m128d){ __w, __w };
}
# 1854 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_pd1(double __w)
{
  return _mm_set1_pd(__w);
}
# 1874 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_pd(double __w, double __x)
{
  return __extension__ (__m128d){ __x, __w };
}
# 1895 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_pd(double __w, double __x)
{
  return __extension__ (__m128d){ __w, __x };
}
# 1910 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setzero_pd(void)
{
  return __extension__ (__m128d){ 0, 0 };
}
# 1931 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_move_sd(__m128d __a, __m128d __b)
{
  __a[0] = __b[0];
  return __a;
}
# 1949 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store_sd(double *__dp, __m128d __a)
{
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)__dp)->__u = __a[0];
}
# 1971 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store_pd(double *__dp, __m128d __a)
{
  *(__m128d*)__dp = __a;
}
# 1991 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store1_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
  _mm_store_pd(__dp, __a);
}
# 2012 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store_pd1(double *__dp, __m128d __a)
{
  _mm_store1_pd(__dp, __a);
}
# 2030 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_pd(double *__dp, __m128d __a)
{
  struct __storeu_pd {
    __m128d_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_pd*)__dp)->__v = __a;
}
# 2053 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storer_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 1, 0);
  *(__m128d *)__dp = __a;
}
# 2071 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeh_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[1];
}
# 2091 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storel_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[0];
}
# 2116 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qu)__a + (__v16qu)__b);
}
# 2138 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hu)__a + (__v8hu)__b);
}
# 2160 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4su)__a + (__v4su)__b);
}
# 2178 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_add_si64(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_paddq((__v1di)__a, (__v1di)__b);
}
# 2200 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a + (__v2du)__b);
}
# 2221 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_adds_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)__a, (__v16qi)__b);
}
# 2243 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_adds_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)__a, (__v8hi)__b);
}
# 2264 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_adds_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)__a, (__v16qi)__b);
}
# 2285 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_adds_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)__a, (__v8hi)__b);
}
# 2305 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_avg_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}
# 2325 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_avg_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}
# 2351 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_madd_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}
# 2371 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_max_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)__a, (__v8hi)__b);
}
# 2391 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_max_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)__a, (__v16qi)__b);
}
# 2411 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_min_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)__a, (__v8hi)__b);
}
# 2431 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_min_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)__a, (__v16qi)__b);
}
# 2451 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mulhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}
# 2471 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mulhi_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}
# 2491 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mullo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hu)__a * (__v8hu)__b);
}
# 2510 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_mul_su32(__m64 __a, __m64 __b)
{
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}
# 2529 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mul_epu32(__m128i __a, __m128i __b)
{
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}
# 2551 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sad_epu8(__m128i __a, __m128i __b)
{
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}
# 2569 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qu)__a - (__v16qu)__b);
}
# 2587 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hu)__a - (__v8hu)__b);
}
# 2605 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4su)__a - (__v4su)__b);
}
# 2624 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_sub_si64(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psubq((__v1di)__a, (__v1di)__b);
}
# 2642 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a - (__v2du)__b);
}
# 2663 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_subs_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)__a, (__v16qi)__b);
}
# 2684 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_subs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)__a, (__v8hi)__b);
}
# 2704 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_subs_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)__a, (__v16qi)__b);
}
# 2724 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_subs_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)__a, (__v8hi)__b);
}
# 2742 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_and_si128(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a & (__v2du)__b);
}
# 2762 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_andnot_si128(__m128i __a, __m128i __b)
{
  return (__m128i)(~(__v2du)__a & (__v2du)__b);
}
# 2779 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_or_si128(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a | (__v2du)__b);
}
# 2797 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_xor_si128(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a ^ (__v2du)__b);
}
# 2839 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_slli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}
# 2858 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sll_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}
# 2877 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_slli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}
# 2896 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sll_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}
# 2915 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_slli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psllqi128((__v2di)__a, __count);
}
# 2934 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sll_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psllq128((__v2di)__a, (__v2di)__count);
}
# 2954 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srai_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}
# 2974 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sra_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}
# 2994 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srai_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}
# 3014 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sra_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}
# 3056 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}
# 3075 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srl_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}
# 3094 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}
# 3113 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srl_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}
# 3132 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psrlqi128((__v2di)__a, __count);
}
# 3151 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srl_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psrlq128((__v2di)__a, (__v2di)__count);
}
# 3170 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}
# 3189 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}
# 3208 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a == (__v4si)__b);
}
# 3228 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_epi8(__m128i __a, __m128i __b)
{


  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}
# 3251 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}
# 3272 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a > (__v4si)__b);
}
# 3293 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_epi8(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi8(__b, __a);
}
# 3314 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_epi16(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi16(__b, __a);
}
# 3335 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_epi32(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi32(__b, __a);
}
# 3359 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi64_sd(__m128d __a, long long __b)
{
  __a[0] = __b;
  return __a;
}
# 3377 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsd_si64(__m128d __a)
{
  return __builtin_ia32_cvtsd2si64((__v2df)__a);
}
# 3395 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvttsd_si64(__m128d __a)
{
  return __builtin_ia32_cvttsd2si64((__v2df)__a);
}
# 3411 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtepi32_ps(__m128i __a)
{
  return (__m128)__builtin_convertvector((__v4si)__a, __v4sf);
}
# 3427 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvtps2dq((__v4sf)__a);
}
# 3444 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvttps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvttps2dq((__v4sf)__a);
}
# 3460 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi32_si128(int __a)
{
  return __extension__ (__m128i)(__v4si){ __a, 0, 0, 0 };
}
# 3477 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi64_si128(long long __a)
{
  return __extension__ (__m128i)(__v2di){ __a, 0 };
}
# 3495 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi128_si32(__m128i __a)
{
  __v4si __b = (__v4si)__a;
  return __b[0];
}
# 3514 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi128_si64(__m128i __a)
{
  return __a[0];
}
# 3531 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load_si128(__m128i const *__p)
{
  return *__p;
}
# 3547 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si128(__m128i_u const *__p)
{
  struct __loadu_si128 {
    __m128i_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_si128*)__p)->__v;
}
# 3568 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadl_epi64(__m128i_u const *__p)
{
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return __extension__ (__m128i) { ((const struct __mm_loadl_epi64_struct*)__p)->__u, 0};
}
# 3586 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_undefined_si128(void)
{
  return (__m128i)__builtin_ia32_undef128();
}
# 3608 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi64x(long long __q1, long long __q0)
{
  return __extension__ (__m128i)(__v2di){ __q0, __q1 };
}
# 3630 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi64(__m64 __q1, __m64 __q0)
{
  return _mm_set_epi64x((long long)__q1, (long long)__q0);
}
# 3658 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi32(int __i3, int __i2, int __i1, int __i0)
{
  return __extension__ (__m128i)(__v4si){ __i0, __i1, __i2, __i3};
}
# 3698 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi16(short __w7, short __w6, short __w5, short __w4, short __w3, short __w2, short __w1, short __w0)
{
  return __extension__ (__m128i)(__v8hi){ __w0, __w1, __w2, __w3, __w4, __w5, __w6, __w7 };
}
# 3746 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi8(char __b15, char __b14, char __b13, char __b12, char __b11, char __b10, char __b9, char __b8, char __b7, char __b6, char __b5, char __b4, char __b3, char __b2, char __b1, char __b0)
{
  return __extension__ (__m128i)(__v16qi){ __b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7, __b8, __b9, __b10, __b11, __b12, __b13, __b14, __b15 };
}
# 3765 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi64x(long long __q)
{
  return _mm_set_epi64x(__q, __q);
}
# 3784 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi64(__m64 __q)
{
  return _mm_set_epi64(__q, __q);
}
# 3803 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi32(int __i)
{
  return _mm_set_epi32(__i, __i, __i, __i);
}
# 3822 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi16(short __w)
{
  return _mm_set_epi16(__w, __w, __w, __w, __w, __w, __w, __w);
}
# 3841 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi8(char __b)
{
  return _mm_set_epi8(__b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b);
}
# 3861 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi64(__m64 __q0, __m64 __q1)
{
  return _mm_set_epi64(__q1, __q0);
}
# 3884 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi32(int __i0, int __i1, int __i2, int __i3)
{
  return _mm_set_epi32(__i3, __i2, __i1, __i0);
}
# 3915 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi16(short __w0, short __w1, short __w2, short __w3, short __w4, short __w5, short __w6, short __w7)
{
  return _mm_set_epi16(__w7, __w6, __w5, __w4, __w3, __w2, __w1, __w0);
}
# 3962 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5, char __b6, char __b7, char __b8, char __b9, char __b10, char __b11, char __b12, char __b13, char __b14, char __b15)
{
  return _mm_set_epi8(__b15, __b14, __b13, __b12, __b11, __b10, __b9, __b8, __b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 3976 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setzero_si128(void)
{
  return __extension__ (__m128i)(__v2di){ 0LL, 0LL };
}
# 3994 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store_si128(__m128i *__p, __m128i __b)
{
  *__p = __b;
}
# 4010 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_si128(__m128i_u *__p, __m128i __b)
{
  struct __storeu_si128 {
    __m128i_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si128*)__p)->__v = __b;
}
# 4031 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_si64(void *__p, __m128i __b)
{
  struct __storeu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si64*)__p)->__v = ((__v2di)__b)[0];
}
# 4052 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_si32(void *__p, __m128i __b)
{
  struct __storeu_si32 {
    int __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si32*)__p)->__v = ((__v4si)__b)[0];
}
# 4073 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_si16(void *__p, __m128i __b)
{
  struct __storeu_si16 {
    short __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si16*)__p)->__v = ((__v8hi)__b)[0];
}
# 4103 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_maskmoveu_si128(__m128i __d, __m128i __n, char *__p)
{
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}
# 4122 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storel_epi64(__m128i_u *__p, __m128i __a)
{
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct*)__p)->__u = __a[0];
}
# 4145 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_stream_pd(double *__p, __m128d __a)
{
  __builtin_nontemporal_store((__v2df)__a, (__v2df*)__p);
}
# 4164 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_stream_si128(__m128i *__p, __m128i __a)
{
  __builtin_nontemporal_store((__v2di)__a, (__v2di*)__p);
}
# 4183 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si32(int *__p, int __a)
{
  __builtin_ia32_movnti(__p, __a);
}
# 4203 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si64(long long *__p, long long __a)
{
  __builtin_ia32_movnti64(__p, __a);
}
# 4224 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
void _mm_clflush(void const * __p);
# 4235 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
void _mm_lfence(void);
# 4246 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
void _mm_mfence(void);
# 4274 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_packs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}
# 4302 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_packs_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}
# 4330 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_packus_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}
# 4398 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_movemask_epi8(__m128i __a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}
# 4524 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}
# 4551 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}
# 4574 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4+2, 3, 4+3);
}
# 4595 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 1, 2+1);
}
# 4630 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}
# 4658 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}
# 4681 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4+0, 1, 4+1);
}
# 4702 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 0, 2+0);
}
# 4719 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_movepi64_pi64(__m128i __a)
{
  return (__m64)__a[0];
}
# 4736 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_movpi64_epi64(__m64 __a)
{
  return __extension__ (__m128i)(__v2di){ (long long)__a, 0 };
}
# 4754 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_move_epi64(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, _mm_setzero_si128(), 0, 2);
}
# 4775 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 1, 2+1);
}
# 4796 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 0, 2+0);
}
# 4815 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_movemask_pd(__m128d __a)
{
  return __builtin_ia32_movmskpd((__v2df)__a);
}
# 4861 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castpd_ps(__m128d __a)
{
  return (__m128)__a;
}
# 4878 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castpd_si128(__m128d __a)
{
  return (__m128i)__a;
}
# 4895 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castps_pd(__m128 __a)
{
  return (__m128d)__a;
}
# 4912 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castps_si128(__m128 __a)
{
  return (__m128i)__a;
}
# 4929 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castsi128_ps(__m128i __a)
{
  return (__m128)__a;
}
# 4946 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castsi128_pd(__m128i __a)
{
  return (__m128d)__a;
}
# 4963 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\emmintrin.h" 3
void _mm_pause(void);
# 3006 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xmmintrin.h" 2 3
# 21 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 2 3
# 79 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\bmiintrin.h" 1 3
# 34 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\bmiintrin.h" 3
static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__))
__tzcnt_u16(unsigned short __X)
{
  return __builtin_ia32_tzcnt_u16(__X);
}
# 50 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\bmiintrin.h" 3
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
__tzcnt_u32(unsigned int __X)
{
  return __builtin_ia32_tzcnt_u32(__X);
}
# 66 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\bmiintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_tzcnt_32(unsigned int __X)
{
  return __builtin_ia32_tzcnt_u32(__X);
}
# 86 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\bmiintrin.h" 3
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__tzcnt_u64(unsigned long long __X)
{
  return __builtin_ia32_tzcnt_u64(__X);
}
# 102 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\bmiintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_tzcnt_64(unsigned long long __X)
{
  return __builtin_ia32_tzcnt_u64(__X);
}
# 80 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 2 3
# 399 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\fxsrintrin.h" 1 3
# 29 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\fxsrintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave(void *__p)
{
  __builtin_ia32_fxsave(__p);
}
# 47 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\fxsrintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor(void *__p)
{
  __builtin_ia32_fxrstor(__p);
}
# 64 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\fxsrintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave64(void *__p)
{
  __builtin_ia32_fxsave64(__p);
}
# 82 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\fxsrintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor64(void *__p)
{
  __builtin_ia32_fxrstor64(__p);
}
# 400 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 2 3



# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xsaveintrin.h" 1 3
# 24 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xsaveintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave(void *__p, unsigned long long __m) {
  __builtin_ia32_xsave(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstor(__p, __m);
}
# 41 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\xsaveintrin.h" 3
unsigned __int64 __cdecl _xgetbv(unsigned int);
void __cdecl _xsetbv(unsigned int, unsigned __int64);






static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsave64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor64(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstor64(__p, __m);
}
# 404 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 2 3
# 427 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 3
# 1 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\adxintrin.h" 1 3
# 21 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\adxintrin.h" 3
static __inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
               unsigned int *__p)
{
  return __builtin_ia32_addcarryx_u32(__cf, __x, __y, __p);
}


static __inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarryx_u64(__cf, __x, __y, __p);
}



static __inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_addcarryx_u32(__cf, __x, __y, __p);
}


static __inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u64(unsigned char __cf, unsigned long long __x,
              unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarryx_u64(__cf, __x, __y, __p);
}


static __inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_subborrow_u32(__cf, __x, __y, __p);
}


static __inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_subborrow_u64(__cf, __x, __y, __p);
}
# 428 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 2 3
# 514 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\immintrin.h" 3
static __inline__ long __attribute__((__always_inline__, __nodebug__))
_InterlockedExchange_HLEAcquire(long volatile *_Target, long _Value) {
  __asm__ __volatile__(".byte 0xf2 ; lock ; xchg %0, %1"
                       : "+r" (_Value), "+m" (*_Target) :: "memory");
  return _Value;
}
static __inline__ long __attribute__((__always_inline__, __nodebug__))
_InterlockedExchange_HLERelease(long volatile *_Target, long _Value) {
  __asm__ __volatile__(".byte 0xf3 ; lock ; xchg %0, %1"
                       : "+r" (_Value), "+m" (*_Target) :: "memory");
  return _Value;
}


static __inline__ __int64 __attribute__((__always_inline__, __nodebug__))
_InterlockedExchange64_HLEAcquire(__int64 volatile *_Target, __int64 _Value) {
  __asm__ __volatile__(".byte 0xf2 ; lock ; xchg %0, %1"
                       : "+r" (_Value), "+m" (*_Target) :: "memory");
  return _Value;
}
static __inline__ __int64 __attribute__((__always_inline__, __nodebug__))
_InterlockedExchange64_HLERelease(__int64 volatile *_Target, __int64 _Value) {
  __asm__ __volatile__(".byte 0xf3 ; lock ; xchg %0, %1"
                       : "+r" (_Value), "+m" (*_Target) :: "memory");
  return _Value;
}





static __inline__ long __attribute__((__always_inline__, __nodebug__))
_InterlockedCompareExchange_HLEAcquire(long volatile *_Destination,
                              long _Exchange, long _Comparand) {
  __asm__ __volatile__(".byte 0xf2 ; lock ; cmpxchg %2, %1"
                       : "+a" (_Comparand), "+m" (*_Destination)
                       : "r" (_Exchange) : "memory");
  return _Comparand;
}
static __inline__ long __attribute__((__always_inline__, __nodebug__))
_InterlockedCompareExchange_HLERelease(long volatile *_Destination,
                              long _Exchange, long _Comparand) {
  __asm__ __volatile__(".byte 0xf3 ; lock ; cmpxchg %2, %1"
                       : "+a" (_Comparand), "+m" (*_Destination)
                       : "r" (_Exchange) : "memory");
  return _Comparand;
}


static __inline__ __int64 __attribute__((__always_inline__, __nodebug__))
_InterlockedCompareExchange64_HLEAcquire(__int64 volatile *_Destination,
                              __int64 _Exchange, __int64 _Comparand) {
  __asm__ __volatile__(".byte 0xf2 ; lock ; cmpxchg %2, %1"
                       : "+a" (_Comparand), "+m" (*_Destination)
                       : "r" (_Exchange) : "memory");
  return _Comparand;
}
static __inline__ __int64 __attribute__((__always_inline__, __nodebug__))
_InterlockedCompareExchange64_HLERelease(__int64 volatile *_Destination,
                              __int64 _Exchange, __int64 _Comparand) {
  __asm__ __volatile__(".byte 0xf3 ; lock ; cmpxchg %2, %1"
                       : "+a" (_Comparand), "+m" (*_Destination)
                       : "r" (_Exchange) : "memory");
  return _Comparand;
}
# 16 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\x86intrin.h" 2 3
# 21 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\intrin.h" 2 3
# 33 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\intrin.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\setjmp.h" 1 3
# 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\setjmp.h" 3
#pragma warning(push)
#pragma warning(disable: 4514 4820)

#pragma pack(push, 8)
# 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\setjmp.h" 3
 typedef struct __declspec(align(16)) _SETJMP_FLOAT128
    {
        unsigned __int64 Part[2];
    } SETJMP_FLOAT128;


    typedef SETJMP_FLOAT128 _JBTYPE;

    typedef struct _JUMP_BUFFER
    {
        unsigned __int64 Frame;
        unsigned __int64 Rbx;
        unsigned __int64 Rsp;
        unsigned __int64 Rbp;
        unsigned __int64 Rsi;
        unsigned __int64 Rdi;
        unsigned __int64 R12;
        unsigned __int64 R13;
        unsigned __int64 R14;
        unsigned __int64 R15;
        unsigned __int64 Rip;
        unsigned long MxCsr;
        unsigned short FpCsr;
        unsigned short Spare;

        SETJMP_FLOAT128 Xmm6;
        SETJMP_FLOAT128 Xmm7;
        SETJMP_FLOAT128 Xmm8;
        SETJMP_FLOAT128 Xmm9;
        SETJMP_FLOAT128 Xmm10;
        SETJMP_FLOAT128 Xmm11;
        SETJMP_FLOAT128 Xmm12;
        SETJMP_FLOAT128 Xmm13;
        SETJMP_FLOAT128 Xmm14;
        SETJMP_FLOAT128 Xmm15;
    } _JUMP_BUFFER;
# 148 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\setjmp.h" 3
    typedef _JBTYPE jmp_buf[16];
# 160 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.28.29333\\include\\setjmp.h" 3
int __cdecl _setjmp(
          jmp_buf _Buf
    );







    __declspec(noreturn) void __cdecl longjmp(
                           jmp_buf _Buf,
             int _Value
        );



#pragma pack(pop)

#pragma warning(pop)
# 34 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\intrin.h" 2 3
# 51 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\intrin.h" 3
__m64 _m_from_float(float);
float _m_to_float(__m64);



void __addfsbyte(unsigned long, unsigned char);
void __addfsdword(unsigned long, unsigned long);
void __addfsword(unsigned long, unsigned short);
void __code_seg(const char *);
static __inline__
void __cpuid(int[4], int);
static __inline__
void __cpuidex(int[4], int, int);
static __inline__
__int64 __emul(int, int);
static __inline__
unsigned __int64 __emulu(unsigned int, unsigned int);
unsigned int __getcallerseflags(void);
static __inline__
void __halt(void);
unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);
void __incfsbyte(unsigned long);
void __incfsdword(unsigned long);
void __incfsword(unsigned long);
unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);
void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
static __inline__
void __movsb(unsigned char *, unsigned char const *, size_t);
static __inline__
void __movsd(unsigned long *, unsigned long const *, size_t);
static __inline__
void __movsw(unsigned short *, unsigned short const *, size_t);
static __inline__
void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned long __readcr0(void);
unsigned long __readcr2(void);
unsigned __int64 __readcr3(void);
unsigned long __readcr4(void);
unsigned long __readcr8(void);
unsigned int __readdr(unsigned int);
# 115 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\intrin.h" 3
static __inline__
unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);
unsigned long __segmentlimit(unsigned long);
void __sidt(void *);
static __inline__
void __stosb(unsigned char *, unsigned char, size_t);
static __inline__
void __stosd(unsigned long *, unsigned long, size_t);
static __inline__
void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);
void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);
void __vmx_off(void);
void __vmx_vmptrst(unsigned __int64 *);
void __wbinvd(void);
void __writecr0(unsigned int);
static __inline__
void __writecr3(unsigned long long int);
void __writecr4(unsigned int);
void __writecr8(unsigned int);
void __writedr(unsigned int, unsigned int);
void __writefsbyte(unsigned long, unsigned char);
void __writefsdword(unsigned long, unsigned long);
void __writefsqword(unsigned long, unsigned __int64);
void __writefsword(unsigned long, unsigned short);
void __writemsr(unsigned long, unsigned __int64);
static __inline__
void *_AddressOfReturnAddress(void);
static __inline__
unsigned char _BitScanForward(unsigned long *_Index, unsigned long _Mask);
static __inline__
unsigned char _BitScanReverse(unsigned long *_Index, unsigned long _Mask);
unsigned char _bittest(long const *, long);
unsigned char _bittestandcomplement(long *, long);
unsigned char _bittestandreset(long *, long);
unsigned char _bittestandset(long *, long);
void __cdecl _disable(void);
void __cdecl _enable(void);
long _InterlockedAddLargeStatistic(__int64 volatile *_Addend, long _Value);
unsigned char _interlockedbittestandreset(long volatile *, long);
unsigned char _interlockedbittestandset(long volatile *, long);
void *_InterlockedCompareExchangePointer_HLEAcquire(void *volatile *, void *,
                                                    void *);
void *_InterlockedCompareExchangePointer_HLERelease(void *volatile *, void *,
                                                    void *);
long _InterlockedExchangeAdd_HLEAcquire(long volatile *, long);
long _InterlockedExchangeAdd_HLERelease(long volatile *, long);
__int64 _InterlockedExchangeAdd64_HLEAcquire(__int64 volatile *, __int64);
__int64 _InterlockedExchangeAdd64_HLERelease(__int64 volatile *, __int64);
static __inline__ void
__attribute__((__deprecated__("use other intrinsics or C++11 atomics instead")))
_ReadBarrier(void);
static __inline__ void
__attribute__((__deprecated__("use other intrinsics or C++11 atomics instead")))
_ReadWriteBarrier(void);
unsigned int _rorx_u32(unsigned int, const unsigned int);
int _sarx_i32(int, unsigned int);

int __cdecl _setjmp(jmp_buf);

unsigned int _shlx_u32(unsigned int, unsigned int);
unsigned int _shrx_u32(unsigned int, unsigned int);
void _Store_HLERelease(long volatile *, long);
void _Store64_HLERelease(__int64 volatile *, __int64);
void _StorePointer_HLERelease(void *volatile *, void *);
static __inline__ void
__attribute__((__deprecated__("use other intrinsics or C++11 atomics instead")))
_WriteBarrier(void);
unsigned __int32 xbegin(void);
void _xend(void);



void __addgsbyte(unsigned long, unsigned char);
void __addgsdword(unsigned long, unsigned long);
void __addgsqword(unsigned long, unsigned __int64);
void __addgsword(unsigned long, unsigned short);
static __inline__
void __faststorefence(void);
void __incgsbyte(unsigned long);
void __incgsdword(unsigned long);
void __incgsqword(unsigned long);
void __incgsword(unsigned long);
static __inline__
void __movsq(unsigned long long *, unsigned long long const *, size_t);
static __inline__
unsigned char __readgsbyte(unsigned long);
static __inline__
unsigned long __readgsdword(unsigned long);
static __inline__
unsigned __int64 __readgsqword(unsigned long);
unsigned short __readgsword(unsigned long);
unsigned __int64 __shiftleft128(unsigned __int64 _LowPart,
                                unsigned __int64 _HighPart,
                                unsigned char _Shift);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart,
                                 unsigned __int64 _HighPart,
                                 unsigned char _Shift);
static __inline__
void __stosq(unsigned __int64 *, unsigned __int64, size_t);
unsigned char __vmx_on(unsigned __int64 *);
unsigned char __vmx_vmclear(unsigned __int64 *);
unsigned char __vmx_vmlaunch(void);
unsigned char __vmx_vmptrld(unsigned __int64 *);
unsigned char __vmx_vmread(size_t, size_t *);
unsigned char __vmx_vmresume(void);
unsigned char __vmx_vmwrite(size_t, size_t);
void __writegsbyte(unsigned long, unsigned char);
void __writegsdword(unsigned long, unsigned long);
void __writegsqword(unsigned long, unsigned __int64);
void __writegsword(unsigned long, unsigned short);
unsigned char _bittest64(__int64 const *, __int64);
unsigned char _bittestandcomplement64(__int64 *, __int64);
unsigned char _bittestandreset64(__int64 *, __int64);
unsigned char _bittestandset64(__int64 *, __int64);
long _InterlockedAnd_np(long volatile *_Value, long _Mask);
short _InterlockedAnd16_np(short volatile *_Value, short _Mask);
__int64 _InterlockedAnd64_np(__int64 volatile *_Value, __int64 _Mask);
char _InterlockedAnd8_np(char volatile *_Value, char _Mask);
unsigned char _interlockedbittestandreset64(__int64 volatile *, __int64);
unsigned char _interlockedbittestandset64(__int64 volatile *, __int64);
long _InterlockedCompareExchange_np(long volatile *_Destination, long _Exchange,
                                    long _Comparand);
unsigned char _InterlockedCompareExchange128(__int64 volatile *_Destination,
                                             __int64 _ExchangeHigh,
                                             __int64 _ExchangeLow,
                                             __int64 *_CompareandResult);
unsigned char _InterlockedCompareExchange128_np(__int64 volatile *_Destination,
                                                __int64 _ExchangeHigh,
                                                __int64 _ExchangeLow,
                                                __int64 *_ComparandResult);
short _InterlockedCompareExchange16_np(short volatile *_Destination,
                                       short _Exchange, short _Comparand);
__int64 _InterlockedCompareExchange64_np(__int64 volatile *_Destination,
                                         __int64 _Exchange, __int64 _Comparand);
void *_InterlockedCompareExchangePointer_np(void *volatile *_Destination,
                                            void *_Exchange, void *_Comparand);
long _InterlockedOr_np(long volatile *_Value, long _Mask);
short _InterlockedOr16_np(short volatile *_Value, short _Mask);
__int64 _InterlockedOr64_np(__int64 volatile *_Value, __int64 _Mask);
char _InterlockedOr8_np(char volatile *_Value, char _Mask);
long _InterlockedXor_np(long volatile *_Value, long _Mask);
short _InterlockedXor16_np(short volatile *_Value, short _Mask);
__int64 _InterlockedXor64_np(__int64 volatile *_Value, __int64 _Mask);
char _InterlockedXor8_np(char volatile *_Value, char _Mask);
unsigned __int64 _rorx_u64(unsigned __int64, const unsigned int);
__int64 _sarx_i64(__int64, unsigned int);
unsigned __int64 _shlx_u64(unsigned __int64, unsigned int);
unsigned __int64 _shrx_u64(unsigned __int64, unsigned int);
static __inline__
__int64 __mulh(__int64, __int64);
static __inline__
unsigned __int64 __umulh(unsigned __int64, unsigned __int64);
static __inline__
__int64 _mul128(__int64, __int64, __int64*);
static __inline__
unsigned __int64 _umul128(unsigned __int64,
                          unsigned __int64,
                          unsigned __int64*);





static __inline__
unsigned char _BitScanForward64(unsigned long *_Index, unsigned __int64 _Mask);
static __inline__
unsigned char _BitScanReverse64(unsigned long *_Index, unsigned __int64 _Mask);




static __inline__
__int64 _InterlockedDecrement64(__int64 volatile *_Addend);
static __inline__
__int64 _InterlockedExchange64(__int64 volatile *_Target, __int64 _Value);
static __inline__
__int64 _InterlockedExchangeAdd64(__int64 volatile *_Addend, __int64 _Value);
static __inline__
__int64 _InterlockedExchangeSub64(__int64 volatile *_Subend, __int64 _Value);
static __inline__
__int64 _InterlockedIncrement64(__int64 volatile *_Addend);
static __inline__
__int64 _InterlockedOr64(__int64 volatile *_Value, __int64 _Mask);
static __inline__
__int64 _InterlockedXor64(__int64 volatile *_Value, __int64 _Mask);
static __inline__
__int64 _InterlockedAnd64(__int64 volatile *_Value, __int64 _Mask);
# 478 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\intrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__))
__movsb(unsigned char *__dst, unsigned char const *__src, size_t __n) {
  __asm__ __volatile__("rep movsb" : "+D"(__dst), "+S"(__src), "+c"(__n)
                       : : "memory");
}
static __inline__ void __attribute__((__always_inline__, __nodebug__))
__movsd(unsigned long *__dst, unsigned long const *__src, size_t __n) {
  __asm__ __volatile__("rep movsl" : "+D"(__dst), "+S"(__src), "+c"(__n)
                       : : "memory");
}
static __inline__ void __attribute__((__always_inline__, __nodebug__))
__movsw(unsigned short *__dst, unsigned short const *__src, size_t __n) {
  __asm__ __volatile__("rep movsw" : "+D"(__dst), "+S"(__src), "+c"(__n)
                       : : "memory");
}
static __inline__ void __attribute__((__always_inline__, __nodebug__))
__stosd(unsigned long *__dst, unsigned long __x, size_t __n) {
  __asm__ __volatile__("rep stosl" : "+D"(__dst), "+c"(__n) : "a"(__x)
                       : "memory");
}
static __inline__ void __attribute__((__always_inline__, __nodebug__))
__stosw(unsigned short *__dst, unsigned short __x, size_t __n) {
  __asm__ __volatile__("rep stosw" : "+D"(__dst), "+c"(__n) : "a"(__x)
                       : "memory");
}


static __inline__ void __attribute__((__always_inline__, __nodebug__))
__movsq(unsigned long long *__dst, unsigned long long const *__src, size_t __n) {
  __asm__ __volatile__("rep movsq" : "+D"(__dst), "+S"(__src), "+c"(__n)
                       : : "memory");
}
static __inline__ void __attribute__((__always_inline__, __nodebug__))
__stosq(unsigned __int64 *__dst, unsigned __int64 __x, size_t __n) {
  __asm__ __volatile__("rep stosq" : "+D"(__dst), "+c"(__n) : "a"(__x)
                       : "memory");
}






static __inline__ void __attribute__((__always_inline__, __nodebug__))
__cpuid(int __info[4], int __level) {
  __asm__ ("cpuid" : "=a"(__info[0]), "=b" (__info[1]), "=c"(__info[2]), "=d"(__info[3])
                   : "a"(__level), "c"(0));
}
static __inline__ void __attribute__((__always_inline__, __nodebug__))
__cpuidex(int __info[4], int __level, int __ecx) {
  __asm__ ("cpuid" : "=a"(__info[0]), "=b" (__info[1]), "=c"(__info[2]), "=d"(__info[3])
                   : "a"(__level), "c"(__ecx));
}
static __inline__ void __attribute__((__always_inline__, __nodebug__))
__halt(void) {
  __asm__ volatile ("hlt");
}



static __inline__ void __attribute__((__always_inline__, __nodebug__))
__nop(void) {
  __asm__ volatile ("nop");
}
# 562 "C:\\PROGRA~1\\LLVM\\lib\\clang\\11.0.0\\include\\intrin.h" 3
static __inline__ unsigned __int64 __attribute__((__always_inline__, __nodebug__))
__readmsr(unsigned long __register) {






  unsigned long __edx;
  unsigned long __eax;
  __asm__ ("rdmsr" : "=d"(__edx), "=a"(__eax) : "c"(__register));
  return (((unsigned __int64)__edx) << 32) | (unsigned __int64)__eax;
}


static __inline__ unsigned __int64 __attribute__((__always_inline__, __nodebug__))
__readcr3(void) {
  unsigned __int64 __cr3_val;
  __asm__ __volatile__ ("mov %%cr3, %0" : "=r"(__cr3_val) : : "memory");
  return __cr3_val;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
__writecr3(unsigned long long int __cr3_val) {
  __asm__ ("mov %0, %%cr3" : : "r"(__cr3_val) : "memory");
}
# 2475 "././m-core.h" 2
static inline unsigned int m_core_clz32(uint32_t limb)
{
  unsigned long bit = 0;
  if (_BitScanReverse( &bit, limb ) != 0) {
    return 31 - bit;
  } else {
    return 32;
  }
}
static inline unsigned int m_core_clz64(uint64_t limb)
{
  unsigned long bit = 0;
  if (_BitScanReverse64( &bit, limb ) != 0) {
    return 63 - bit;
  } else {
    return 64;
  }
}
# 2584 "././m-core.h"
static inline uint64_t
m_core_hash (const void *str, size_t length)
{
  const uint64_t prime = 1099511628211ULL;
  uint64_t hash64 = 14695981039346656037ULL ^ 0UL;
  const uint8_t *p = ((const uint8_t *) { 0 } = (str));

  (void)( (!!(str != ((void*)0) || length == 0)) || (_wassert(L"str != ((void*)0) || length == 0", L"././m-core.h", (unsigned)(2591)), 0) );
  (void)( (!!((( (uintptr_t)p & (sizeof(uint64_t)-1) ) == 0) || (length <= sizeof(uint32_t)))) || (_wassert(L"(( (uintptr_t)p & (sizeof(uint64_t)-1) ) == 0) || (length <= sizeof(uint32_t))", L"././m-core.h", (unsigned)(2593)), 0) );


  while (length >= 2*sizeof(uint64_t)) {
    const uint64_t *ptr = (const uint64_t *) (uintptr_t) p;
    hash64 = (hash64 ^ (m_core_rotl64a(ptr[0], 5) ^ ptr[1])) * prime;
    length -= 2*sizeof(uint64_t);
    p += 2*sizeof(uint64_t);
  }

  if (length & sizeof(uint64_t)) {
    const uint64_t *ptr = (const uint64_t *) (uintptr_t) p;
    hash64 = (hash64 ^ ptr[0]) * prime;
    p += sizeof(uint64_t);
    }

  if (length & sizeof(uint32_t)) {
    const uint32_t *ptr = (const uint32_t *) (uintptr_t) p;
    hash64 = (hash64 ^ ptr[0]) * prime;
    p += sizeof(uint32_t);
    }
  if (length & sizeof(uint16_t)) {
    const uint16_t *ptr = (const uint16_t *) (uintptr_t) p;
    hash64 = (hash64 ^ ptr[0]) * prime;
    p += sizeof(uint16_t);
  }
  if (length & 1)
    hash64 = (hash64 ^ *p) * prime;
  return hash64 ^ (hash64 >> 32);
}



static inline size_t m_core_cstr_hash(const char str[])
{
  size_t hash = 0UL ^ 0UL;
  while (*str) {
    unsigned long u = (unsigned char) *str++;
    do { hash = (size_t) (((hash) * 0x811C9DC5UL) ^ ((u))); } while (0);
  }
  return ( (hash) >> (sizeof(size_t)*8/2) | (hash) );
}
# 3173 "././m-core.h"
static inline long long
m_core_fscan_enum (FILE *f)
{
  long long ret;
  int s = fscanf_s(f, "%lld", &ret) == 1;


  ungetc(s, f);
  return ret;
}







static inline long long
m_core_parse1_enum(const char str[])
{
  return strtoll(str, ((void*)0), 10);
}
static inline _Bool
m_core_parse2_enum(const char str[], const char **endptr)
{
  char *end;
  strtoll(str, &end, 10);
  if (endptr != ((void*)0)) *endptr = end;
  return end != str;
}
# 3592 "././m-core.h"
typedef struct m_core_backoff_s {
  unsigned int count;
  unsigned int seed;
} m_core_backoff_ct[1];




static inline void
m_core_backoff_init(m_core_backoff_ct backoff)
{
  backoff->count = 0;
  backoff->seed = (unsigned int) rand();
}


static inline void
m_core_backoff_reset(m_core_backoff_ct backoff)
{
  backoff->count = 0;
}




static inline void
m_core_backoff_wait(m_core_backoff_ct backoff)
{


  volatile int x = 0;

  backoff->seed = backoff->seed * 34721 + 17449;
  const unsigned int mask = (1U << backoff->count) -1;
  const unsigned int count = mask & (backoff->seed >> 8);

  for (unsigned int i = 0; i <= count; i++)
    x = 0;
  (void) x;

  backoff->count += (backoff->count < 6);
}


static inline void
m_core_backoffclear(m_core_backoff_ct backoff)
{

  (void) backoff;
}







struct string_s;






typedef enum m_serial_return_code_e {
  M_SERIAL_OK_DONE = 0, M_SERIAL_OK_CONTINUE = 1, M_SERIAL_FAIL = 2
} m_serial_return_code_t;
# 3689 "././m-core.h"
typedef union m_serial_ll_u {
  _Bool b;
  int i;
  size_t s;
  void *p;
  m_serial_return_code_t r;
} m_serial_ll_ct;





typedef struct m_serial_local_s {
  m_serial_ll_ct data[4];
} m_serial_local_t[1];
# 3712 "././m-core.h"
typedef struct m_serial_read_s {
  const struct m_serial_read_interface_s *m_interface;
  m_serial_ll_ct tmp;
  m_serial_ll_ct data[4];
} m_serial_read_t[1];




typedef struct m_serial_read_interface_s {
  m_serial_return_code_t (*read_boolean)(m_serial_read_t,_Bool *);
  m_serial_return_code_t (*read_integer)(m_serial_read_t, long long *, const size_t size_of_type);
  m_serial_return_code_t (*read_float)(m_serial_read_t, long double *, const size_t size_of_type);
  m_serial_return_code_t (*read_string)(m_serial_read_t, struct string_s *);
  m_serial_return_code_t (*read_array_start)(m_serial_local_t, m_serial_read_t, size_t *);
  m_serial_return_code_t (*read_array_next)(m_serial_local_t, m_serial_read_t);
  m_serial_return_code_t (*read_map_start)(m_serial_local_t, m_serial_read_t, size_t *);
  m_serial_return_code_t (*read_map_value)(m_serial_local_t, m_serial_read_t);
  m_serial_return_code_t (*read_map_next)(m_serial_local_t, m_serial_read_t);
  m_serial_return_code_t (*read_tuple_start)(m_serial_local_t, m_serial_read_t);
  m_serial_return_code_t (*read_tuple_id)(m_serial_local_t, m_serial_read_t, const char *const field_name [], const int max, int *);
  m_serial_return_code_t (*read_variant_start)(m_serial_local_t, m_serial_read_t, const char *const field_name[], const int max, int*);
  m_serial_return_code_t (*read_variant_end)(m_serial_local_t, m_serial_read_t);
} m_serial_read_interface_t;
# 3745 "././m-core.h"
typedef struct m_serial_write_s {
  const struct m_serial_write_interface_s *m_interface;
  m_serial_ll_ct tmp;
  m_serial_ll_ct data[4];
} m_serial_write_t[1];




typedef struct m_serial_write_interface_s {
  m_serial_return_code_t (*write_boolean)(m_serial_write_t,const _Bool data);
  m_serial_return_code_t (*write_integer)(m_serial_write_t,const long long data, const size_t size_of_type);
  m_serial_return_code_t (*write_float)(m_serial_write_t, const long double data, const size_t size_of_type);
  m_serial_return_code_t (*write_string)(m_serial_write_t,const char data[], size_t len);
  m_serial_return_code_t (*write_array_start)(m_serial_local_t, m_serial_write_t, const size_t number_of_elements);
  m_serial_return_code_t (*write_array_next)(m_serial_local_t, m_serial_write_t);
  m_serial_return_code_t (*write_array_end)(m_serial_local_t, m_serial_write_t);
  m_serial_return_code_t (*write_map_start)(m_serial_local_t, m_serial_write_t, const size_t number_of_elements);
  m_serial_return_code_t (*write_map_value)(m_serial_local_t, m_serial_write_t);
  m_serial_return_code_t (*write_map_next)(m_serial_local_t, m_serial_write_t);
  m_serial_return_code_t (*write_map_end)(m_serial_local_t, m_serial_write_t);
  m_serial_return_code_t (*write_tuple_start)(m_serial_local_t, m_serial_write_t);
  m_serial_return_code_t (*write_tuple_id)(m_serial_local_t, m_serial_write_t, const char * const field_name[], const int max, const int index);
  m_serial_return_code_t (*write_tuple_end)(m_serial_local_t, m_serial_write_t);
  m_serial_return_code_t (*write_variant_start)(m_serial_local_t, m_serial_write_t, const char * const field_name[], const int max, const int index);
  m_serial_return_code_t (*write_variant_end)(m_serial_local_t, m_serial_write_t);
} m_serial_write_interface_t;
# 3878 "././m-core.h"
static inline m_serial_return_code_t m_core_in_serial_char(m_serial_read_t serial, char *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (char)); *ptr = (char) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_schar(m_serial_read_t serial, signed char *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (signed char)); *ptr = (signed char) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_uchar(m_serial_read_t serial, unsigned char *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (unsigned char)); *ptr = (unsigned char) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_sshort(m_serial_read_t serial, signed short *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (signed short)); *ptr = (signed short) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_ushort(m_serial_read_t serial, unsigned short *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (unsigned short)); *ptr = (unsigned short) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_sint(m_serial_read_t serial, signed int *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (signed int)); *ptr = (signed int) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_uint(m_serial_read_t serial, unsigned int *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (unsigned int)); *ptr = (unsigned int) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_slong(m_serial_read_t serial, signed long *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (signed long)); *ptr = (signed long) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_ulong(m_serial_read_t serial, unsigned long *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (unsigned long)); *ptr = (unsigned long) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_sllong(m_serial_read_t serial, signed long long *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (signed long long)); *ptr = (signed long long) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_ullong(m_serial_read_t serial, unsigned long long *ptr) { long long i; m_serial_return_code_t r; r = serial->m_interface->read_integer(serial, &i, sizeof (unsigned long long)); *ptr = (unsigned long long) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_float(m_serial_read_t serial, float *ptr) { long double i; m_serial_return_code_t r; r = serial->m_interface->read_float(serial, &i, sizeof (float)); *ptr = (float) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_double(m_serial_read_t serial, double *ptr) { long double i; m_serial_return_code_t r; r = serial->m_interface->read_float(serial, &i, sizeof (double)); *ptr = (double) i; return r; }

static inline m_serial_return_code_t m_core_in_serial_ldouble(m_serial_read_t serial, long double *ptr) { long double i; m_serial_return_code_t r; r = serial->m_interface->read_float(serial, &i, sizeof (long double)); *ptr = (long double) i; return r; }



static inline long long
m_core_in_serial_enum(m_serial_read_t serial)
{
  long long i;

  serial->tmp.r = serial->m_interface->read_integer(serial, &i, sizeof (long long));
  return i;
}





static inline size_t
m_core_out_serial_strlen(const char s[])
{
  (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"././m-core.h", (unsigned)(3924)), 0) );
  return strlen(s);
}






static inline m_serial_return_code_t
m_core_serial_fail(void)
{
  return M_SERIAL_FAIL;
}

#pragma clang diagnostic pop
# 35 "./.\\m-string.h" 2





#pragma clang diagnostic push
# 40 "./.\\m-string.h"
#pragma clang diagnostic ignored "-Wunused-function"
# 40 "./.\\m-string.h"
#pragma clang diagnostic ignored "-Wformat-nonliteral"
# 70 "./.\\m-string.h"
typedef struct string_heap_s {
  size_t size;
  size_t alloc;
} string_heap_ct;

typedef struct string_stack_s {
  char buffer[sizeof (string_heap_ct)];
} string_stack_ct;

typedef union string_union_u {
  string_heap_ct heap;
  string_stack_ct stack;
} string_union_ct;


typedef struct string_s {
  string_union_ct u;
  char *ptr;
} string_t[1];


typedef struct string_s *string_ptr;


typedef const struct string_s *string_srcptr;






typedef enum string_fgets_s {
  STRING_READ_LINE = 0, STRING_READ_PURE_LINE = 1, STRING_READ_FILE = 2
} string_fgets_t;


static inline _Bool
stringi_stack_p(const string_t s)
{

  return (s->ptr == ((void*)0));
}


static inline void
stringi_set_size(string_t s, size_t size)
{

  if (stringi_stack_p(s)) {
    (void)( (!!(size < sizeof (string_heap_ct) - 1)) || (_wassert(L"size < sizeof (string_heap_ct) - 1", L"./.\\m-string.h", (unsigned)(119)), 0) );
    s->u.stack.buffer[sizeof (string_heap_ct) - 1] = (char) size;
  } else
    s->u.heap.size = size;
}


static inline size_t
string_size(const string_t s)
{


  const size_t s_stack = (size_t) s->u.stack.buffer[sizeof (string_heap_ct) - 1];
  const size_t s_heap = s->u.heap.size;
  return stringi_stack_p(s) ? s_stack : s_heap;
}


static inline size_t
string_capacity(const string_t s)
{


  const size_t c_stack = sizeof (string_heap_ct) - 1;
  const size_t c_heap = s->u.heap.alloc;
  return stringi_stack_p(s) ? c_stack : c_heap;
}


static inline char*
stringi_get_cstr(string_t v)
{

  char *const ptr_stack = &v->u.stack.buffer[0];
  char *const ptr_heap = v->ptr;
  return stringi_stack_p(v) ? ptr_stack : ptr_heap;
}


static inline const char*
string_get_cstr(const string_t v)
{


  const char *const ptr_stack = &v->u.stack.buffer[0];
  const char *const ptr_heap = v->ptr;
  return stringi_stack_p(v) ? ptr_stack : ptr_heap;
}



static inline void
string_init(string_t s)
{
  s->ptr = ((void*)0);
  s->u.stack.buffer[0] = 0;
  stringi_set_size(s, 0);
  do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"./.\\m-string.h", (unsigned)(176)), 0) ); (void) 0; (void)( (!!(string_get_cstr(s)[string_size(s)] == 0)) || (_wassert(L"string_get_cstr(s)[string_size(s)] == 0", L"./.\\m-string.h", (unsigned)(176)), 0) ); (void)( (!!(string_size(s) < string_capacity(s))) || (_wassert(L"string_size(s) < string_capacity(s)", L"./.\\m-string.h", (unsigned)(176)), 0) ); (void)( (!!(string_capacity(s) < sizeof(string_heap_ct) || !stringi_stack_p(s))) || (_wassert(L"string_capacity(s) < sizeof(string_heap_ct) || !stringi_stack_p(s)", L"./.\\m-string.h", (unsigned)(176)), 0) ); } while(0);
}


static inline void
string_clear(string_t v)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(183)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(183)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(183)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(183)), 0) ); } while(0);
  if (!stringi_stack_p(v)) {
    free(v->ptr);
    v->ptr = ((void*)0);
  }


  v->u.stack.buffer[sizeof (string_heap_ct) - 1] = 127;
}


static inline void stringi_clear2(string_t *v) { string_clear(*v); }





static inline char *
string_clear_get_cstr(string_t v)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(203)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(203)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(203)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(203)), 0) ); } while(0);
  char *p = v->ptr;
  if (stringi_stack_p(v)) {

    p = v->u.stack.buffer;

    size_t alloc = string_size(v)+1;
    char *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(char)) ? ((void*)0) : realloc ((((void*)0)), (alloc)*sizeof (char)));
    if ((ptr == ((void*)0))) {
      do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (char) * alloc), "./.\\m-string.h", __func__, 212); abort(); } while (0);
      return ((void*)0);
    }
    (void)( (!!(ptr != ((void*)0) && p != ((void*)0))) || (_wassert(L"ptr != ((void*)0) && p != ((void*)0)", L"./.\\m-string.h", (unsigned)(215)), 0) );
    memcpy(ptr, p, alloc);
    p = ptr;
  }
  v->ptr = ((void*)0);
  v->u.stack.buffer[sizeof (string_heap_ct) - 1] = 127;
  return p;
}


static inline void
string_clean(string_t v)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(228)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(228)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(228)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(228)), 0) ); } while(0);
  stringi_set_size(v, 0);
  stringi_get_cstr(v)[0] = 0;
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(231)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(231)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(231)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(231)), 0) ); } while(0);
}


static inline char
string_get_char(const string_t v, size_t index)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(238)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(238)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(238)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(238)), 0) ); } while(0);
  do { (void)( (!!((index) < (string_size(v)))) || (_wassert(L"(index) < (string_size(v))", L"./.\\m-string.h", (unsigned)(239)), 0) ); } while (0);
  return string_get_cstr(v)[index];
}


static inline _Bool
stringempty_p(const string_t v)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(247)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(247)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(247)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(247)), 0) ); } while(0);
  return string_size(v) == 0;
}






static inline char *
stringi_fit2size(string_t v, size_t size_alloc)
{
  do { (void)( (!!((0) < (size_alloc))) || (_wassert(L"(0) < (size_alloc)", L"./.\\m-string.h", (unsigned)(259)), 0) ); } while (0);


  const size_t old_alloc = string_capacity(v);
  if ((size_alloc > old_alloc)) {
    size_t alloc = size_alloc + size_alloc / 2;
    if ((alloc <= old_alloc)) {

      do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (char) * alloc), "./.\\m-string.h", __func__, 267); abort(); } while (0);

      abort();
      return ((void*)0);
    }
    char *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(char)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (char)));
    if ((ptr == ((void*)0))) {
      do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (char) * alloc), "./.\\m-string.h", __func__, 274); abort(); } while (0);

      abort();
      return ((void*)0);
    }
    (void)( (!!(ptr != &v->u.stack.buffer[0])) || (_wassert(L"ptr != &v->u.stack.buffer[0]", L"./.\\m-string.h", (unsigned)(279)), 0) );
    if (stringi_stack_p(v)) {

      memcpy(ptr, &v->u.stack.buffer[0],
              (size_t) v->u.stack.buffer[sizeof (string_heap_ct) - 1] + 1U);
    }
    v->ptr = ptr;
    v->u.heap.alloc = alloc;
    return ptr;
  }
  return stringi_get_cstr(v);
}



static inline void
string_reserve(string_t v, size_t alloc)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(297)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(297)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(297)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(297)), 0) ); } while(0);
  const size_t size = string_size(v);

  if (size + 1 > alloc) {
    alloc = size+1;
  }
  (void)( (!!(alloc > 0)) || (_wassert(L"alloc > 0", L"./.\\m-string.h", (unsigned)(303)), 0) );
  if (alloc < sizeof (string_heap_ct)) {

    if (!stringi_stack_p(v)) {

      char *ptr = &v->u.stack.buffer[0];
      memcpy(ptr, v->ptr, size+1);
      free(v->ptr);
      v->ptr = ((void*)0);
      stringi_set_size(v, size);
    } else {

    }
  } else {


    char *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(char)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (char)));
    if ((ptr == ((void*)0)) ) {
      do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (char) * alloc), "./.\\m-string.h", __func__, 321); abort(); } while (0);
      return;
    }
    if (stringi_stack_p(v)) {

      char *ptr_stack = &v->u.stack.buffer[0];
      memcpy(ptr, ptr_stack, size+1);
      v->u.heap.size = size;
    }
    v->ptr = ptr;
    v->u.heap.alloc = alloc;
  }
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(333)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(333)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(333)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(333)), 0) ); } while(0);
}


static inline void
string_set_cstr(string_t v, const char str[])
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(340)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(340)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(340)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(340)), 0) ); } while(0);
  (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(341)), 0) );
  size_t size = strlen(str);
  char *ptr = stringi_fit2size(v, size+1);
  memcpy(ptr, str, size+1);
  stringi_set_size(v, size);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(346)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(346)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(346)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(346)), 0) ); } while(0);
}


static inline void
string_set_cstrn(string_t v, const char str[], size_t n)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(353)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(353)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(353)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(353)), 0) ); } while(0);
  (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(354)), 0) );
  size_t len = strlen(str);
  size_t size = ((len) < (n) ? (len) : (n));
  char *ptr = stringi_fit2size(v, size+1);
  memcpy(ptr, str, size);
  ptr[size] = 0;
  stringi_set_size(v, size);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(361)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(361)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(361)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(361)), 0) ); } while(0);
}


static inline void
string_set(string_t v1, const string_t v2)
{
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(368)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(368)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(368)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(368)), 0) ); } while(0);
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(369)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(369)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(369)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(369)), 0) ); } while(0);
  if ((v1 != v2)) {
    const size_t size = string_size(v2);
    char *ptr = stringi_fit2size(v1, size+1);
    memcpy(ptr, string_get_cstr(v2), size + 1);
    stringi_set_size(v1, size);
  }
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(376)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(376)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(376)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(376)), 0) ); } while(0);
}


static inline void
string_set_n(string_t v, const string_t ref, size_t offset, size_t length)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(383)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(383)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(383)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(383)), 0) ); } while(0);
  do { (void)( (!!(ref != ((void*)0))) || (_wassert(L"ref != ((void*)0)", L"./.\\m-string.h", (unsigned)(384)), 0) ); (void) 0; (void)( (!!(string_get_cstr(ref)[string_size(ref)] == 0)) || (_wassert(L"string_get_cstr(ref)[string_size(ref)] == 0", L"./.\\m-string.h", (unsigned)(384)), 0) ); (void)( (!!(string_size(ref) < string_capacity(ref))) || (_wassert(L"string_size(ref) < string_capacity(ref)", L"./.\\m-string.h", (unsigned)(384)), 0) ); (void)( (!!(string_capacity(ref) < sizeof(string_heap_ct) || !stringi_stack_p(ref))) || (_wassert(L"string_capacity(ref) < sizeof(string_heap_ct) || !stringi_stack_p(ref)", L"./.\\m-string.h", (unsigned)(384)), 0) ); } while(0);
  do { (void)( (!!((offset) < (string_size(ref) + 1))) || (_wassert(L"(offset) < (string_size(ref) + 1)", L"./.\\m-string.h", (unsigned)(385)), 0) ); } while (0);
  size_t size = ((string_size(ref) - offset) < (length) ? (string_size(ref) - offset) : (length));
  char *ptr = stringi_fit2size(v, size+1);
  memmove(ptr, string_get_cstr(ref) + offset, size);
  ptr[size] = 0;
  stringi_set_size(v, size);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(391)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(391)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(391)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(391)), 0) ); } while(0);
}



static inline void
stringinit_set(string_t v1, const string_t v2)
{
  string_init(v1);
  string_set(v1,v2);
}



static inline void
string_init_set_cstr(string_t v1, const char str[])
{
  string_init(v1);
  string_set_cstr(v1, str);
}




static inline void
string_init_move(string_t v1, string_t v2)
{
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(418)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(418)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(418)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(418)), 0) ); } while(0);
  memcpy(v1, v2, sizeof (string_t));

  v2->ptr = ((void*)0);
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(422)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(422)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(422)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(422)), 0) ); } while(0);
}


static inline void
string_swap(string_t v1, string_t v2)
{
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(429)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(429)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(429)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(429)), 0) ); } while(0);
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(430)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(430)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(430)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(430)), 0) ); } while(0);
  do { size_t _tmp = (v1->u.heap.size); (v1->u.heap.size) = (v2->u.heap.size); (v2->u.heap.size) = _tmp; } while (0);
  do { size_t _tmp = (v1->u.heap.alloc); (v1->u.heap.alloc) = (v2->u.heap.alloc); (v2->u.heap.alloc) = _tmp; } while (0);
  do { char * _tmp = (v1->ptr); (v1->ptr) = (v2->ptr); (v2->ptr) = _tmp; } while (0);
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(434)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(434)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(434)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(434)), 0) ); } while(0);
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(435)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(435)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(435)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(435)), 0) ); } while(0);
}




static inline void
string_move(string_t v1, string_t v2)
{
  string_clear(v1);
  string_init_move(v1,v2);
}


static inline void
string_push_back(string_t v, char c)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(452)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(452)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(452)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(452)), 0) ); } while(0);
  const size_t size = string_size(v);
  char *ptr = stringi_fit2size(v, size+2);
  ptr[size + 0] = c;
  ptr[size + 1] = 0;
  stringi_set_size(v, size+1);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(458)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(458)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(458)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(458)), 0) ); } while(0);
}


static inline void
string_cat_cstr(string_t v, const char str[])
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(465)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(465)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(465)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(465)), 0) ); } while(0);
  (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(466)), 0) );
  const size_t old_size = string_size(v);
  const size_t size = strlen(str);
  char *ptr = stringi_fit2size(v, old_size + size + 1);
  memcpy(&ptr[old_size], str, size + 1);
  stringi_set_size(v, old_size + size);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(472)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(472)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(472)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(472)), 0) ); } while(0);
}


static inline void
string_cat(string_t v, const string_t v2)
{
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(479)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(479)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(479)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(479)), 0) ); } while(0);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(480)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(480)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(480)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(480)), 0) ); } while(0);
  const size_t size = string_size(v2);
  if ((size > 0)) {
    const size_t old_size = string_size(v);
    char *ptr = stringi_fit2size(v, old_size + size + 1);
    memcpy(&ptr[old_size], string_get_cstr(v2), size);
    ptr[old_size + size] = 0;
    stringi_set_size(v, old_size + size);
  }
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(489)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(489)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(489)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(489)), 0) ); } while(0);
}



static inline int
string_cmp_cstr(const string_t v1, const char str[])
{
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(497)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(497)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(497)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(497)), 0) ); } while(0);
  (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(498)), 0) );
  return strcmp(string_get_cstr(v1), str);
}



static inline int
string_cmp(const string_t v1, const string_t v2)
{
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(507)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(507)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(507)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(507)), 0) ); } while(0);
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(508)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(508)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(508)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(508)), 0) ); } while(0);
  return strcmp(string_get_cstr(v1), string_get_cstr(v2));
}


static inline _Bool
string_equal_cstr_p(const string_t v1, const char str[])
{
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(516)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(516)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(516)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(516)), 0) ); } while(0);
  (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(517)), 0) );
  return string_cmp_cstr(v1, str) == 0;
}


static inline _Bool
stringequal_p(const string_t v1, const string_t v2)
{




  (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(529)), 0) );
  (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(530)), 0) );

  return string_size(v1) == string_size(v2)
      && string_cmp(v1, v2) == 0;
}





static inline int
string_cmpi_cstr(const string_t v1, const char p2[])
{
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(543)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(543)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(543)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(543)), 0) ); } while(0);
  (void)( (!!(p2 != ((void*)0))) || (_wassert(L"p2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(544)), 0) );

  const char *p1 = string_get_cstr(v1);
  int c1, c2;
  do {

    c1 = toupper((unsigned char) *p1++);
    c2 = toupper((unsigned char) *p2++);
    c1 = tolower((unsigned char) c1);
    c2 = tolower((unsigned char) c2);
  } while (c1 == c2 && c1 != 0);
  return c1 - c2;
}





static inline int
string_cmpi(const string_t v1, const string_t v2)
{
  return string_cmpi_cstr(v1, string_get_cstr(v2));
}






static inline size_t
string_search_char(const string_t v, char c, size_t start)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(576)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(576)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(576)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(576)), 0) ); } while(0);
  do { (void)( (!!((start) < (string_size(v) + 1))) || (_wassert(L"(start) < (string_size(v) + 1)", L"./.\\m-string.h", (unsigned)(577)), 0) ); } while (0);
  const char *p = ((const char*) { 0 } = (strchr(string_get_cstr(v)+start, c)));

  return p == ((void*)0) ? ((size_t)-1) : (size_t) (p - string_get_cstr(v));
}






static inline size_t
string_search_rchar(const string_t v, char c, size_t start)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(591)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(591)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(591)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(591)), 0) ); } while(0);
  do { (void)( (!!((start) < (string_size(v)+1))) || (_wassert(L"(start) < (string_size(v)+1)", L"./.\\m-string.h", (unsigned)(592)), 0) ); } while (0);



  const char *p = ((const char*) { 0 } = (strrchr(string_get_cstr(v)+start, c)));

  return p == ((void*)0) ? ((size_t)-1) : (size_t) (p-string_get_cstr(v));
}




static inline size_t
string_search_cstr(const string_t v, const char str[], size_t start)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(607)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(607)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(607)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(607)), 0) ); } while(0);
  do { (void)( (!!((start) < (string_size(v) + 1))) || (_wassert(L"(start) < (string_size(v) + 1)", L"./.\\m-string.h", (unsigned)(608)), 0) ); } while (0);
  (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(609)), 0) );
  const char *p = ((const char*) { 0 } = (strstr(string_get_cstr(v)+start, str)));

  return p == ((void*)0) ? ((size_t)-1) : (size_t) (p-string_get_cstr(v));
}




static inline size_t
string_search(const string_t v1, const string_t v2, size_t start)
{
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(621)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(621)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(621)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(621)), 0) ); } while(0);
  do { (void)( (!!((start) < (string_size(v1) + 1))) || (_wassert(L"(start) < (string_size(v1) + 1)", L"./.\\m-string.h", (unsigned)(622)), 0) ); } while (0);
  return string_search_cstr(v1, string_get_cstr(v2), start);
}





static inline size_t
string_search_pbrk(const string_t v1, const char first_of[], size_t start)
{
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(633)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(633)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(633)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(633)), 0) ); } while(0);
  do { (void)( (!!((start) < (string_size(v1) + 1))) || (_wassert(L"(start) < (string_size(v1) + 1)", L"./.\\m-string.h", (unsigned)(634)), 0) ); } while (0);
  (void)( (!!(first_of != ((void*)0))) || (_wassert(L"first_of != ((void*)0)", L"./.\\m-string.h", (unsigned)(635)), 0) );
  const char *p = ((const char*) { 0 } = (strpbrk(string_get_cstr(v1)+start, first_of)));

  return p == ((void*)0) ? ((size_t)-1) : (size_t) (p-string_get_cstr(v1));
}


static inline int
string_strcoll_cstr(const string_t v, const char str[])
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(645)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(645)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(645)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(645)), 0) ); } while(0);
  return strcoll(string_get_cstr(v), str);
}


static inline int
string_strcoll(const string_t v1, const string_t v2)
{
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(653)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(653)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(653)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(653)), 0) ); } while(0);
  return string_strcoll_cstr(v1, string_get_cstr(v2));
}



static inline size_t
string_spn(const string_t v1, const char accept[])
{
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(662)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(662)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(662)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(662)), 0) ); } while(0);
  (void)( (!!(accept != ((void*)0))) || (_wassert(L"accept != ((void*)0)", L"./.\\m-string.h", (unsigned)(663)), 0) );
  return strspn(string_get_cstr(v1), accept);
}



static inline size_t
string_cspn(const string_t v1, const char reject[])
{
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(672)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(672)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(672)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(672)), 0) ); } while(0);
  (void)( (!!(reject != ((void*)0))) || (_wassert(L"reject != ((void*)0)", L"./.\\m-string.h", (unsigned)(673)), 0) );
  return strcspn(string_get_cstr(v1), reject);
}


static inline void
string_left(string_t v, size_t index)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(681)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(681)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(681)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(681)), 0) ); } while(0);
  const size_t size = string_size(v);
  if (index >= size)
    return;
  stringi_get_cstr(v)[index] = 0;
  stringi_set_size(v,index);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(687)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(687)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(687)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(687)), 0) ); } while(0);
}


static inline void
string_right(string_t v, size_t index)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(694)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(694)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(694)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(694)), 0) ); } while(0);
  char *ptr = stringi_get_cstr(v);
  const size_t size = string_size(v);
  if (index >= size) {
    ptr[0] = 0;
    stringi_set_size(v, 0);
    do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(700)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(700)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(700)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(700)), 0) ); } while(0);
    return;
  }
  size_t s2 = size - index;
  memmove(&ptr[0], &ptr[index], s2+1);
  stringi_set_size(v, s2);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(706)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(706)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(706)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(706)), 0) ); } while(0);
}




static inline void
string_mid(string_t v, size_t index, size_t size)
{
  string_right(v, index);
  string_left(v, size);
}




static inline size_t
string_replace_cstr(string_t v, const char str1[], const char str2[], size_t start)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(725)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(725)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(725)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(725)), 0) ); } while(0);
  (void)( (!!(str1 != ((void*)0) && str2 != ((void*)0))) || (_wassert(L"str1 != ((void*)0) && str2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(726)), 0) );
  size_t i = string_search_cstr(v, str1, start);
  if (i != ((size_t)-1)) {
    const size_t str1_l = strlen(str1);
    const size_t str2_l = strlen(str2);
    const size_t size = string_size(v);
    (void)( (!!(size + 1 + str2_l > str1_l)) || (_wassert(L"size + 1 + str2_l > str1_l", L"./.\\m-string.h", (unsigned)(732)), 0) );
    char *ptr = stringi_fit2size(v, size + str2_l - str1_l + 1);
    if (str1_l != str2_l) {
      memmove(&ptr[i+str2_l], &ptr[i+str1_l], size - i - str1_l + 1);
      stringi_set_size(v, size + str2_l - str1_l);
    }
    memcpy(&ptr[i], str2, str2_l);
    do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(739)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(739)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(739)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(739)), 0) ); } while(0);
  }
  return i;
}




static inline size_t
string_replace(string_t v, const string_t v1, const string_t v2, size_t start)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(750)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(750)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(750)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(750)), 0) ); } while(0);
  do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"./.\\m-string.h", (unsigned)(751)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v1)[string_size(v1)] == 0)) || (_wassert(L"string_get_cstr(v1)[string_size(v1)] == 0", L"./.\\m-string.h", (unsigned)(751)), 0) ); (void)( (!!(string_size(v1) < string_capacity(v1))) || (_wassert(L"string_size(v1) < string_capacity(v1)", L"./.\\m-string.h", (unsigned)(751)), 0) ); (void)( (!!(string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1))) || (_wassert(L"string_capacity(v1) < sizeof(string_heap_ct) || !stringi_stack_p(v1)", L"./.\\m-string.h", (unsigned)(751)), 0) ); } while(0);
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(752)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(752)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(752)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(752)), 0) ); } while(0);
  return string_replace_cstr(v, string_get_cstr(v1), string_get_cstr(v2), start);
}



static inline void
string_replace_at(string_t v, size_t pos, size_t len, const char str2[])
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(761)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(761)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(761)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(761)), 0) ); } while(0);
  (void)( (!!(str2 != ((void*)0))) || (_wassert(L"str2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(762)), 0) );
  const size_t str1_l = len;
  const size_t str2_l = strlen(str2);
  const size_t size = string_size(v);
  char *ptr;
  if (str1_l != str2_l) {

    do { (void)( (!!((str1_l) < (size + str2_l + 1))) || (_wassert(L"(str1_l) < (size + str2_l + 1)", L"./.\\m-string.h", (unsigned)(769)), 0) ); } while (0);
    ptr = stringi_fit2size (v, size + str2_l - str1_l + 1);
    do { (void)( (!!((pos + str1_l) < (size + 1))) || (_wassert(L"(pos + str1_l) < (size + 1)", L"./.\\m-string.h", (unsigned)(771)), 0) ); } while (0);
    (void)( (!!(pos + str1_l < size + 1)) || (_wassert(L"pos + str1_l < size + 1", L"./.\\m-string.h", (unsigned)(772)), 0) );
    memmove(&ptr[pos+str2_l], &ptr[pos+str1_l], size - pos - str1_l + 1);
    stringi_set_size(v, size + str2_l - str1_l);
  } else {
    ptr = stringi_get_cstr(v);
  }
  memcpy(&ptr[pos], str2, str2_l);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(779)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(779)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(779)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(779)), 0) ); } while(0);
}


static inline void
stringi_replace_all_str_1ge2(string_t v, const char str1[], size_t str1len, const char str2[], size_t str2len)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(786)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(786)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(786)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(786)), 0) ); } while(0);
  (void)( (!!(str1len >= str2len)) || (_wassert(L"str1len >= str2len", L"./.\\m-string.h", (unsigned)(787)), 0) );


  size_t vlen = string_size(v);
  char *org = stringi_get_cstr(v);
  char *src = org;
  char *dst = org;


  while (*src != 0) {

    char *occ = strstr(src, str1);
    if (occ == ((void*)0)) {

      break;
    }
    (void)( (!!(occ >= src)) || (_wassert(L"occ >= src", L"./.\\m-string.h", (unsigned)(803)), 0) );

    if (src != dst) {
      memmove(dst, src, (size_t) (occ - src));
    }
    dst += (occ - src);
    src = occ;

    memcpy(dst, str2, str2len);
    dst += str2len;

    src = occ + str1len;
  }

  (void)( (!!(src <= org + vlen)) || (_wassert(L"src <= org + vlen", L"./.\\m-string.h", (unsigned)(817)), 0) );
  if (src != dst) {
    memmove(dst, src, (size_t) (org + vlen + 1 - src) );
  }

  stringi_set_size(v, (size_t) (dst + vlen - src) );
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(823)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(823)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(823)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(823)), 0) ); } while(0);
}






static inline char *
stringi_strstr_r(char org[], char src[], const char pattern[], size_t pattern_size)
{
  src -= pattern_size - 1;
  while (org <= src) {
    if (src[0] == pattern[0]
      && src[pattern_size-1] == pattern[pattern_size-1]
      && memcmp(src, pattern, pattern_size) == 0) {
        return src;
    }
    src --;
  }
  return ((void*)0);
}


static inline void
stringi_replace_all_str_1lo2(string_t v, const char str1[], size_t str1len, const char str2[], size_t str2len)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(850)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(850)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(850)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(850)), 0) ); } while(0);
  (void)( (!!(str1len < str2len)) || (_wassert(L"str1len < str2len", L"./.\\m-string.h", (unsigned)(851)), 0) );





  size_t vlen = string_size(v);
  size_t alloc = 1 + vlen / str1len * str2len;
  char *org = stringi_fit2size(v, alloc);
  char *src = org + vlen - 1;
  char *end = org + string_capacity(v);
  char *dst = end;


  while (src >= org) {
    char *occ = stringi_strstr_r(org, src, str1, str1len);
    if (occ == ((void*)0)) {
      break;
    }
    (void)( (!!(occ + str1len - 1 <= src)) || (_wassert(L"occ + str1len - 1 <= src", L"./.\\m-string.h", (unsigned)(870)), 0) );

    dst -= (src - (occ + str1len - 1));
    memmove(dst, occ+str1len, (size_t) (src - (occ + str1len - 1)));

    dst -= str2len;
    memcpy(dst, str2, str2len);

    src = occ - 1;
  }

  memmove(src + 1, dst, (size_t) (end - dst) );

  vlen = (size_t) (src - org + end - dst + 1);
  org[vlen] = 0;
  stringi_set_size(v, vlen );
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(886)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(886)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(886)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(886)), 0) ); } while(0);
}

static inline void
string_replace_all_cstr(string_t v, const char str1[], const char str2[])
{
  size_t str1_l = strlen(str1);
  size_t str2_l = strlen(str2);
  (void)( (!!(str1_l > 0)) || (_wassert(L"str1_l > 0", L"./.\\m-string.h", (unsigned)(894)), 0) );
  if (str1_l >= str2_l) {
    stringi_replace_all_str_1ge2(v, str1, str1_l, str2, str2_l );
  } else {
    stringi_replace_all_str_1lo2(v, str1, str1_l, str2, str2_l );
  }
}

static inline void
string_replace_all(string_t v, const string_t str1, const string_t str2)
{
  size_t str1_l = string_size(str1);
  size_t str2_l = string_size(str2);
  (void)( (!!(str1_l > 0)) || (_wassert(L"str1_l > 0", L"./.\\m-string.h", (unsigned)(907)), 0) );
  (void)( (!!(str2_l > 0)) || (_wassert(L"str2_l > 0", L"./.\\m-string.h", (unsigned)(908)), 0) );
  if (str1_l >= str2_l) {
    stringi_replace_all_str_1ge2(v, string_get_cstr(str1), str1_l, string_get_cstr(str2), str2_l );
  } else {
    stringi_replace_all_str_1lo2(v, string_get_cstr(str1), str1_l, string_get_cstr(str2), str2_l );
  }
}


static inline int
string_vprintf(string_t v, const char format[], va_list args)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(920)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(920)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(920)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(920)), 0) ); } while(0);
  (void)( (!!(format != ((void*)0))) || (_wassert(L"format != ((void*)0)", L"./.\\m-string.h", (unsigned)(921)), 0) );
  int size;
  va_list args_org;
  __builtin_va_copy(args_org, args);
  char *ptr = stringi_get_cstr(v);
  size_t alloc = string_capacity(v);
  size = vsnprintf (ptr, alloc, format, args);
  if (size > 0 && ((size_t) size+1 >= alloc) ) {

    ptr = stringi_fit2size (v, (size_t) size + 1);
    alloc = string_capacity(v);

    __builtin_va_copy(args, args_org);
    size = vsnprintf (ptr, alloc, format, args);
    (void)( (!!(size > 0 && (size_t)size < alloc)) || (_wassert(L"size > 0 && (size_t)size < alloc", L"./.\\m-string.h", (unsigned)(935)), 0) );
  }
  if ((size >= 0)) {
    stringi_set_size(v, (size_t) size);
  } else {

    stringi_set_size(v, 0);
    ptr[0] = 0;
  }
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(944)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(944)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(944)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(944)), 0) ); } while(0);
  return size;
}


static inline int
string_printf (string_t v, const char format[], ...)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(952)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(952)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(952)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(952)), 0) ); } while(0);
  (void)( (!!(format != ((void*)0))) || (_wassert(L"format != ((void*)0)", L"./.\\m-string.h", (unsigned)(953)), 0) );
  va_list args;
  __builtin_va_start(args, format);
  int ret = string_vprintf(v, format, args);
  __builtin_va_end(args);
  return ret;
}


static inline int
string_cat_printf(string_t v, const char format[], ...)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(965)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(965)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(965)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(965)), 0) ); } while(0);
  (void)( (!!(format != ((void*)0))) || (_wassert(L"format != ((void*)0)", L"./.\\m-string.h", (unsigned)(966)), 0) );
  va_list args;
  int size;
  size_t old_size = string_size(v);
  char *ptr = stringi_get_cstr(v);
  size_t alloc = string_capacity(v);
  __builtin_va_start(args, format);
  size = vsnprintf(&ptr[old_size], alloc - old_size, format, args);
  if (size > 0 && (old_size+(size_t)size+1 >= alloc) ) {

    ptr = stringi_fit2size(v, old_size + (size_t) size + 1);
    alloc = string_capacity(v);

    __builtin_va_end(args);
    __builtin_va_start(args, format);
    size = vsnprintf(&ptr[old_size], alloc - old_size, format, args);
    (void)( (!!(size >= 0)) || (_wassert(L"size >= 0", L"./.\\m-string.h", (unsigned)(982)), 0) );
  }
  if (size >= 0) {
    stringi_set_size(v, old_size + (size_t) size);
  } else {


    ptr[old_size] = 0;
  }
  __builtin_va_end(args);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(992)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(992)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(992)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(992)), 0) ); } while(0);
  return size;
}


static inline _Bool
string_fgets(string_t v, FILE *f, string_fgets_t arg)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1000)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1000)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1000)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1000)), 0) ); } while(0);
  (void)( (!!(f != ((void*)0))) || (_wassert(L"f != ((void*)0)", L"./.\\m-string.h", (unsigned)(1001)), 0) );
  char *ptr = stringi_fit2size(v, 100);
  size_t size = 0;
  size_t alloc = string_capacity(v);
  ptr[0] = 0;
  _Bool retcode = 0;


  while (fgets(&ptr[size], (int) (((alloc - size)) < ((size_t) 2147483647) ? ((alloc - size)) : ((size_t) 2147483647)), f) != ((void*)0)) {
    retcode = 1;

    size += strlen(&ptr[size]);
    if (arg != STRING_READ_FILE && ptr[size-1] == '\n') {
      if (arg == STRING_READ_PURE_LINE) {
        size --;
        ptr[size] = 0;
      }
      stringi_set_size(v, size);
      do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1019)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1019)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1019)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1019)), 0) ); } while(0);
      return retcode;
    } else if (ptr[size-1] != '\n' && !feof(f)) {



      ptr = stringi_fit2size(v, alloc + alloc/2);
      alloc = string_capacity(v);
    }
  }
  stringi_set_size(v, size);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1030)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1030)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1030)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1030)), 0) ); } while(0);
  return retcode;
}





static inline _Bool
string_fget_word(string_t v, const char separator[], FILE *f)
{
  char buffer[128];
  char c = 0;
  int d;
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1044)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1044)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1044)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1044)), 0) ); } while(0);
  (void)( (!!(f != ((void*)0))) || (_wassert(L"f != ((void*)0)", L"./.\\m-string.h", (unsigned)(1045)), 0) );
  do { (void)( (!!((1+20+2+strlen(separator)+3) < (sizeof buffer))) || (_wassert(L"(1+20+2+strlen(separator)+3) < (sizeof buffer)", L"./.\\m-string.h", (unsigned)(1046)), 0) ); } while (0);
  size_t size = 0;
  _Bool retcode = 0;


  do {
    d = fgetc(f);
    if (d == (-1)) {
      return 0;
    }
  } while (strchr(separator, d) != ((void*)0));
  ungetc(d, f);

  size_t alloc = string_capacity(v);
  char *ptr = stringi_get_cstr(v);
  ptr[0] = 0;
# 1072 "./.\\m-string.h"
  while (snprintf(buffer, sizeof buffer -1, " %%%zu[^%s]%%c", (size_t) alloc-1-size, separator) > 0

         && fscanf_s(f, buffer, &ptr[size], (unsigned) alloc-size, &c) >= 1) {
    retcode = 1;
    size += strlen(&ptr[size]);


    if (c == 0 || strchr(separator, c) != ((void*)0))
      break;

    stringi_set_size(v, size);
    ptr = stringi_fit2size(v, alloc + alloc/2);
    alloc = string_capacity(v);
    (void)( (!!(alloc > size + 1)) || (_wassert(L"alloc > size + 1", L"./.\\m-string.h", (unsigned)(1085)), 0) );
    ptr[size++] = c;
    ptr[size] = 0;

    c= 0;
  }
  stringi_set_size(v, size);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1092)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1092)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1092)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1092)), 0) ); } while(0);
  return retcode;
}


static inline _Bool
string_fputs(FILE *f, const string_t v)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1100)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1100)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1100)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1100)), 0) ); } while(0);
  (void)( (!!(f != ((void*)0))) || (_wassert(L"f != ((void*)0)", L"./.\\m-string.h", (unsigned)(1101)), 0) );
  return fputs(string_get_cstr(v), f) >= 0;
}


static inline _Bool
string_start_with_cstr_p(const string_t v, const char str[])
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1109)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1109)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1109)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1109)), 0) ); } while(0);
  (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(1110)), 0) );
  const char *v_str = string_get_cstr(v);
  while (*str){
    if (*str != *v_str)
      return 0;
    str++;
    v_str++;
  }
  return 1;
}


static inline _Bool
string_start_with_string_p(const string_t v, const string_t v2)
{
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(1125)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(1125)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(1125)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(1125)), 0) ); } while(0);
  return string_start_with_cstr_p (v, string_get_cstr(v2));
}


static inline _Bool
string_end_with_cstr_p(const string_t v, const char str[])
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1133)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1133)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1133)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1133)), 0) ); } while(0);
  (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(1134)), 0) );
  const char *v_str = string_get_cstr(v);
  const size_t v_l = string_size(v);
  const size_t str_l = strlen(str);
  if (v_l < str_l)
    return 0;
  return (memcmp(str, &v_str[v_l - str_l], str_l) == 0);
}


static inline _Bool
string_end_with_string_p(const string_t v, const string_t v2)
{
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(1147)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(1147)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(1147)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(1147)), 0) ); } while(0);
  return string_end_with_cstr_p (v, string_get_cstr(v2));
}


static inline size_t
string_hash(const string_t v)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1155)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1155)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1155)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1155)), 0) ); } while(0);
  return m_core_hash(string_get_cstr(v), string_size(v));
}


static _Bool
stringi_strim_char(char c, const char charac[])
{
  for(const char *s = charac; *s; s++) {
    if (c == *s)
      return 1;
  }
  return 0;
}



static inline void
string_strim(string_t v, const char charac[])
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1175)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1175)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1175)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1175)), 0) ); } while(0);
  char *ptr = stringi_get_cstr(v);
  char *b = ptr;
  size_t size = string_size(v);
  while (size > 0 && stringi_strim_char(b[size-1], charac))
    size --;
  if (size > 0) {
    while (stringi_strim_char(*b, charac))
      b++;
    (void)( (!!(b >= ptr && size >= (size_t) (b - ptr))) || (_wassert(L"b >= ptr && size >= (size_t) (b - ptr)", L"./.\\m-string.h", (unsigned)(1184)), 0) );
    size -= (size_t) (b - ptr);
    memmove (ptr, b, size);
  }
  ptr[size] = 0;
  stringi_set_size(v, size);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1190)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1190)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1190)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1190)), 0) ); } while(0);
}


static inline _Bool
string_oor_equal_p(const string_t s, unsigned char n)
{
  return (s->ptr == ((void*)0)) & (s->u.heap.alloc == ~(size_t)n);
}


static inline void
string_oor_set(string_t s, unsigned char n)
{
  s->ptr = ((void*)0);
  s->u.heap.alloc = ~(size_t)n;
}
# 1216 "./.\\m-string.h"
static inline void
string_get_str(string_t v, const string_t v2, _Bool append)
{
  do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(1219)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v2)[string_size(v2)] == 0)) || (_wassert(L"string_get_cstr(v2)[string_size(v2)] == 0", L"./.\\m-string.h", (unsigned)(1219)), 0) ); (void)( (!!(string_size(v2) < string_capacity(v2))) || (_wassert(L"string_size(v2) < string_capacity(v2)", L"./.\\m-string.h", (unsigned)(1219)), 0) ); (void)( (!!(string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2))) || (_wassert(L"string_capacity(v2) < sizeof(string_heap_ct) || !stringi_stack_p(v2)", L"./.\\m-string.h", (unsigned)(1219)), 0) ); } while(0);
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1220)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1220)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1220)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1220)), 0) ); } while(0);
  (void)( (!!(v != v2)) || (_wassert(L"v != v2", L"./.\\m-string.h", (unsigned)(1221)), 0) );
  size_t size = append ? string_size(v) : 0;
  size_t v2_size = string_size(v2);
  size_t targetSize = size + v2_size + 3;
  char *ptr = stringi_fit2size(v, targetSize);
  ptr[size ++] = '"';
  for(size_t i = 0 ; i < v2_size; i++) {
    const char c = string_get_char(v2,i);
    switch (c) {
    case '\\':
    case '"':
    case '\n':
    case '\t':
    case '\r':

      stringi_set_size(v, size);
      ptr = stringi_fit2size(v, ++targetSize);
      ptr[size ++] = '\\';


      ptr[size ++] = " tn\" r\\"[(c ^ (c >>5)) & 0x07];
      break;
    default:
      if ((!isprint(c))) {
        targetSize += 3;
        stringi_set_size(v, size);
        ptr = stringi_fit2size(v, targetSize);
        int d1 = c & 0x07, d2 = (c>>3) & 0x07, d3 = (c>>6) & 0x07;
        ptr[size ++] = '\\';
        ptr[size ++] = (char) ('0' + d3);
        ptr[size ++] = (char) ('0' + d2);
        ptr[size ++] = (char) ('0' + d1);
      } else {
        ptr[size ++] = c;
      }
      break;
    }
  }
  ptr[size ++] = '"';
  ptr[size] = 0;
  stringi_set_size(v, size);
  (void)( (!!(size <= targetSize)) || (_wassert(L"size <= targetSize", L"./.\\m-string.h", (unsigned)(1262)), 0) );
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1263)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1263)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1263)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1263)), 0) ); } while(0);
}



static inline void
string_out_str(FILE *f, const string_t v)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1271)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1271)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1271)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1271)), 0) ); } while(0);
  (void)( (!!(f != ((void*)0))) || (_wassert(L"f != ((void*)0)", L"./.\\m-string.h", (unsigned)(1272)), 0) );
  fputc('"', f);
  size_t size = string_size(v);
  for(size_t i = 0 ; i < size; i++) {
    const char c = string_get_char(v, i);
    switch (c) {
    case '\\':
    case '"':
    case '\n':
    case '\t':
    case '\r':
      fputc('\\', f);
      fputc(" tn\" r\\"[(c ^ c >>5) & 0x07], f);
      break;
    default:
      if ((!isprint(c))) {
        int d1 = c & 0x07, d2 = (c>>3) & 0x07, d3 = (c>>6) & 0x07;
        fputc('\\', f);
        fputc('0' + d3, f);
        fputc('0' + d2, f);
        fputc('0' + d1, f);
      } else {
        fputc(c, f);
      }
      break;
    }
  }
  fputc('"', f);
}




static inline _Bool
string_in_str(string_t v, FILE *f)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1308)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1308)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1308)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1308)), 0) ); } while(0);
  (void)( (!!(f != ((void*)0))) || (_wassert(L"f != ((void*)0)", L"./.\\m-string.h", (unsigned)(1309)), 0) );
  int c = fgetc(f);
  if (c != '"') return 0;
  string_clean(v);
  c = fgetc(f);
  while (c != '"' && c != (-1)) {
    if ((c == '\\')) {
      c = fgetc(f);
      switch (c) {
      case 'n':
      case 't':
      case 'r':
      case '\\':
      case '\"':


        c = " \r \" \n\\\t"[(c^(c>>5))& 0x07];
        break;
      default:
        if (!(c >= '0' && c <= '7'))
          return 0;
        int d1 = c - '0';
        c = fgetc(f);
        if (!(c >= '0' && c <= '7'))
          return 0;
        int d2 = c - '0';
        c = fgetc(f);
        if (!(c >= '0' && c <= '7'))
          return 0;
        int d3 = c - '0';
        c = (d1 << 6) + (d2 << 3) + d3;
        break;
      }
    }
    string_push_back(v, (char) c);
    c = fgetc(f);
  }
  return c == '"';
}






static inline _Bool
string_parse_str(string_t v, const char str[], const char **endptr)
{
  do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"./.\\m-string.h", (unsigned)(1357)), 0) ); (void) 0; (void)( (!!(string_get_cstr(v)[string_size(v)] == 0)) || (_wassert(L"string_get_cstr(v)[string_size(v)] == 0", L"./.\\m-string.h", (unsigned)(1357)), 0) ); (void)( (!!(string_size(v) < string_capacity(v))) || (_wassert(L"string_size(v) < string_capacity(v)", L"./.\\m-string.h", (unsigned)(1357)), 0) ); (void)( (!!(string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v))) || (_wassert(L"string_capacity(v) < sizeof(string_heap_ct) || !stringi_stack_p(v)", L"./.\\m-string.h", (unsigned)(1357)), 0) ); } while(0);
  (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(1358)), 0) );
  _Bool success = 0;
  int c = *str++;
  if (c != '"') goto exit;
  string_clean(v);
  c = *str++;
  while (c != '"' && c != 0) {
    if ((c == '\\')) {
      c = *str++;
      switch (c) {
      case 'n':
      case 't':
      case 'r':
      case '\\':
      case '\"':


        c = " \r \" \n\\\t"[(c^(c>>5))& 0x07];
        break;
      default:
        if (!(c >= '0' && c <= '7'))
          goto exit;
        int d1 = c - '0';
        c = *str++;
        if (!(c >= '0' && c <= '7'))
          goto exit;
        int d2 = c - '0';
        c = *str++;
        if (!(c >= '0' && c <= '7'))
          goto exit;
        int d3 = c - '0';
        c = (d1 << 6) + (d2 << 3) + d3;
        break;
      }
    }
    string_push_back (v, (char) c);
    c = *str++;
  }
  success = (c == '"');
 exit:
  if (endptr != ((void*)0)) *endptr = str;
  return success;
}





static inline m_serial_return_code_t
string_out_serial(m_serial_write_t serial, const string_t v)
{
  (void)( (!!(serial != ((void*)0) && serial->m_interface != ((void*)0))) || (_wassert(L"serial != ((void*)0) && serial->m_interface != ((void*)0)", L"./.\\m-string.h", (unsigned)(1409)), 0) );
  return serial->m_interface->write_string(serial, string_get_cstr(v), string_size(v) );
}





static inline m_serial_return_code_t
string_in_serial(string_t v, m_serial_read_t serial)
{
  (void)( (!!(serial != ((void*)0) && serial->m_interface != ((void*)0))) || (_wassert(L"serial != ((void*)0) && serial->m_interface != ((void*)0)", L"./.\\m-string.h", (unsigned)(1420)), 0) );
  return serial->m_interface->read_string(serial, v);
}


typedef enum {
  STRINGI_UTF8_STARTING = 0,
  STRINGI_UTF8_DECODING_1 = 8,
  STRINGI_UTF8_DECODING_2 = 16,
  STRINGI_UTF8_DOCODING_3 = 24,
  STRINGI_UTF8_ERROR = 32
} stringi_utf8_state_e;


typedef unsigned int string_unicode_t;
# 1472 "./.\\m-string.h"
static inline void
stringi_utf8_decode(char c, stringi_utf8_state_e *state,
                    string_unicode_t *unicode)
{
  const unsigned int type = m_core_clz32((unsigned char)~c) - (unsigned) (sizeof(uint32_t) - 1) * 8;
  const string_unicode_t mask1 = ((2147483647 *2U +1U) - (string_unicode_t)(*state != STRINGI_UTF8_STARTING) + 1);
  const string_unicode_t mask2 = (0xFFU >> type);
  *unicode = ((*unicode << 6) & mask1) | ((unsigned int) c & mask2);
  *state = (stringi_utf8_state_e) "\000\040\010\020\030\040\040\040" "\040\000\040\040\040\040\040\040" "\040\010\040\040\040\040\040\040" "\040\020\040\040\040\040\040\040" "\040\040\040\040\040\040\040\040"[(unsigned int) *state + type];
}



static inline _Bool
stringi_utf8_valid_str_p(const char str[])
{
  stringi_utf8_state_e s = STRINGI_UTF8_STARTING;
  string_unicode_t u = 0;
  while (*str) {
    stringi_utf8_decode(*str, &s, &u);
    if ((s == STRINGI_UTF8_ERROR)
        ||(s == STRINGI_UTF8_STARTING
           &&(u > 0x10FFFF
              ||(u >= 0xD800 && u <= 0xDFFF) )))
      return 0;
    str++;
  }
  return 1;
}




static inline size_t
stringi_utf8_length(const char str[])
{
  size_t size = 0;
  stringi_utf8_state_e s = STRINGI_UTF8_STARTING;
  string_unicode_t u = 0;
  while (*str) {
    stringi_utf8_decode(*str, &s, &u);
    if ((s == STRINGI_UTF8_ERROR)) return 0xffffffffffffffffui64;
    size += (s == STRINGI_UTF8_STARTING);
    str++;
  }
  return size;
}


static inline int
stringi_utf8_encode(char buffer[5], string_unicode_t u)
{
  if ((u <= 0x7Fu)) {
    buffer[0] = (char) u;
    buffer[1] = 0;
    return 1;
  } else if (u <= 0x7FFu) {
    buffer[0] = (char) (0xC0u | (u >> 6));
    buffer[1] = (char) (0x80 | (u & 0x3Fu));
    buffer[2] = 0;
    return 2;
  } else if (u <= 0xFFFFu) {
    buffer[0] = (char) (0xE0u | (u >> 12));
    buffer[1] = (char) (0x80u | ((u >> 6) & 0x3Fu));
    buffer[2] = (char) (0x80u | (u & 0x3Fu));
    buffer[3] = 0;
    return 3;
  } else {
    buffer[0] = (char) (0xF0u | (u >> 18));
    buffer[1] = (char) (0x80u | ((u >> 12) & 0x3Fu));
    buffer[2] = (char) (0x80u | ((u >> 6) & 0x3Fu));
    buffer[3] = (char) (0x80u | (u & 0x3F));
    buffer[4] = 0;
    return 4;
  }
}


typedef struct string_it_s {
  string_unicode_t u;
  const char *ptr;
  const char *next_ptr;
} string_it_t[1];


static inline void
string_it(string_it_t it, const string_t str)
{
  do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(1560)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"./.\\m-string.h", (unsigned)(1560)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"./.\\m-string.h", (unsigned)(1560)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"./.\\m-string.h", (unsigned)(1560)), 0) ); } while(0);
  (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"./.\\m-string.h", (unsigned)(1561)), 0) );
  it->ptr = string_get_cstr(str);
  it->next_ptr = it->ptr;
  it->u = 0;
}




static inline void
string_it_end(string_it_t it, const string_t str)
{
  do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(1573)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"./.\\m-string.h", (unsigned)(1573)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"./.\\m-string.h", (unsigned)(1573)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"./.\\m-string.h", (unsigned)(1573)), 0) ); } while(0);
  (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"./.\\m-string.h", (unsigned)(1574)), 0) );
  it->ptr = &string_get_cstr(str)[string_size(str)];
  it->next_ptr = 0;
  it->u = 0;
}


static inline void
string_it_set(string_it_t it, const string_it_t itsrc)
{
  (void)( (!!(it != ((void*)0) && itsrc != ((void*)0))) || (_wassert(L"it != ((void*)0) && itsrc != ((void*)0)", L"./.\\m-string.h", (unsigned)(1584)), 0) );
  it->ptr = itsrc->ptr;
  it->next_ptr = itsrc->next_ptr;
  it->u = itsrc->u;
}


static inline _Bool
string_end_p(string_it_t it)
{
  (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"./.\\m-string.h", (unsigned)(1594)), 0) );
  if ((*it->ptr == 0))
    return 1;
  stringi_utf8_state_e state = STRINGI_UTF8_STARTING;
  string_unicode_t u = 0;
  const char *str = it->ptr;
  do {
    stringi_utf8_decode(*str, &state, &u);
    str++;
  } while (state != STRINGI_UTF8_STARTING && state != STRINGI_UTF8_ERROR && *str != 0);
  it->next_ptr = str;
  it->u = (state == STRINGI_UTF8_ERROR) ? ((2147483647 *2U +1U)) : u;
  return 0;
}


static inline _Bool
stringit_equal_p(const string_it_t it1, const string_it_t it2)
{
  (void)( (!!(it1 != ((void*)0) && it2 != ((void*)0))) || (_wassert(L"it1 != ((void*)0) && it2 != ((void*)0)", L"./.\\m-string.h", (unsigned)(1613)), 0) );

  (void)( (!!(it1->ptr != it2->ptr || (it1->next_ptr == it2->next_ptr && it1->u == it2->u))) || (_wassert(L"it1->ptr != it2->ptr || (it1->next_ptr == it2->next_ptr && it1->u == it2->u)", L"./.\\m-string.h", (unsigned)(1615)), 0) );
  return it1->ptr == it2->ptr;
}


static inline void
string_next(string_it_t it)
{
  (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"./.\\m-string.h", (unsigned)(1623)), 0) );
  it->ptr = it->next_ptr;
}


static inline string_unicode_t
string_get_cref(const string_it_t it)
{
  (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"./.\\m-string.h", (unsigned)(1631)), 0) );
  return it->u;
}


static inline const string_unicode_t *
string_cref(const string_it_t it)
{
  (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"./.\\m-string.h", (unsigned)(1639)), 0) );
  return &it->u;
}


static inline void
string_push_u(string_t str, string_unicode_t u)
{
  do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(1647)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"./.\\m-string.h", (unsigned)(1647)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"./.\\m-string.h", (unsigned)(1647)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"./.\\m-string.h", (unsigned)(1647)), 0) ); } while(0);
  char buffer[4+1];
  stringi_utf8_encode(buffer, u);
  string_cat_cstr(str, buffer);
}


static inline size_t
string_length_u(string_t str)
{
  do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(1657)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"./.\\m-string.h", (unsigned)(1657)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"./.\\m-string.h", (unsigned)(1657)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"./.\\m-string.h", (unsigned)(1657)), 0) ); } while(0);
  return stringi_utf8_length(string_get_cstr(str));
}


static inline _Bool
string_utf8_p(string_t str)
{
  do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"./.\\m-string.h", (unsigned)(1665)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"./.\\m-string.h", (unsigned)(1665)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"./.\\m-string.h", (unsigned)(1665)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"./.\\m-string.h", (unsigned)(1665)), 0) ); } while(0);
  return stringi_utf8_valid_str_p(string_get_cstr(str));
}
# 2335 "./.\\m-string.h"
#pragma clang diagnostic pop
# 30 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h" 2

#pragma clang diagnostic push
# 31 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h"
#pragma clang diagnostic ignored "-Wunused-function"
# 31 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h"
#pragma clang diagnostic ignored "-Wformat-nonliteral"



typedef struct testobj_s {
  unsigned int n;
  unsigned int a;
  _Bool allocated;
  unsigned int *ptr;
} testobj_t[1];

static inline void testobj_init(testobj_t z)
{
  z->n = 1;
  z->a = 1;
  z->ptr = (unsigned int*) calloc(1, sizeof(unsigned int));
  (void)( (!!(z->ptr != ((void*)0))) || (_wassert(L"z->ptr != NULL", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h", (unsigned)(47)), 0) );
  z->allocated = 1;
}

static inline void testobj_clear(testobj_t z)
{
  (void)( (!!(z->allocated)) || (_wassert(L"z->allocated", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h", (unsigned)(53)), 0) );
  (void)( (!!(z->ptr != ((void*)0))) || (_wassert(L"z->ptr != NULL", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h", (unsigned)(54)), 0) );
  free(z->ptr);
  z->ptr = ((void*)0);
  z->allocated = 0;
}

static inline void testobj_init_set(testobj_t d, const testobj_t s)
{
  d->n = s->n;
  d->a = s->a;
  d->ptr = (unsigned int *) calloc (s->n, sizeof(unsigned int));
  (void)( (!!(d->ptr != ((void*)0))) || (_wassert(L"d->ptr != NULL", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h", (unsigned)(65)), 0) );
  memcpy(d->ptr, s->ptr, sizeof(unsigned int) * s->n);
  d->allocated = 1;
}

static inline void testobj_set(testobj_t d, const testobj_t s)
{
  if (d != s) {
    testobj_clear(d);
    testobj_init_set(d, s);
  }
}

static inline void testobj_set_ui(testobj_t d, unsigned int v)
{
  d->n = 1;
  d->ptr[0] = v;
}

static inline void testobj_set_id(testobj_t d, unsigned int id)
{
  d->a = id;
}

static inline void testobj_init_set_ui(testobj_t d, unsigned int v)
{
  testobj_init(d);
  testobj_set_ui(d, v);
}

static inline unsigned int testobj_get_ui(const testobj_t z)
{
  return z->ptr[0];
}

static inline void testobj_add(testobj_t d, const testobj_t a, const testobj_t b)
{
  d->ptr[0] = a->ptr[0] + b->ptr[0];
}

static inline void testobj_out_str(FILE *f, const testobj_t z)
{
  (void)( (!!(z->n == 1)) || (_wassert(L"z->n == 1", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h", (unsigned)(107)), 0) );
  fprintf(f, "%u", z->ptr[0]);
}

static inline _Bool testobj_in_str(testobj_t z, FILE *f)
{
  z->n = 1;
  return fscanf_s(f, "%u", &z->ptr[0]) == 1;
}

static inline _Bool testobj_parse_str(testobj_t z, const char str[], const char **endptr)
{
  z->n = 1;
  char *end;
  z->ptr[0] = (unsigned int) strtol(str, &end, 0);
  if (endptr) { *endptr = (const char*) end; }
  return (uintptr_t) end != (uintptr_t) str;
}

static inline _Bool testobj_equal_p(const testobj_t z1, const testobj_t z2)
{
  if (z1->n != z2->n) return 0;
  return memcmp(z1->ptr, z2->ptr, z1->n*sizeof(unsigned int)) == 0;
}

static inline int testobj_cmp(const testobj_t z1, const testobj_t z2)
{
  if (z1->n != z2->n) return z1-> n < z2->n ? -1 : 1;
  for(unsigned int i = 0; i < z1->n; i++) {
    if (z1->ptr[i] != z2->ptr[i])
      return z1->ptr[i] < z2->ptr[i] ? -1 : 1;
  }
  return 0;
}

static inline int testobj_cmp_ui(const testobj_t z1, unsigned int z2)
{
  if (z1->n != 1) return z1-> n < 1 ? -1 : 1;
  return z1->ptr[0] < z2 ? -1 : z1->ptr[0] > z2;
}

static inline void testobj_str(string_t str, const testobj_t z, _Bool append)
{
  if (append) string_cat_printf (str, "%u", z->ptr[0]);
  else string_printf (str, "%u", z->ptr[0]);
}
# 181 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/test-obj.h"
#pragma clang diagnostic pop
# 25 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c" 2
# 1 "./.\\m-array.h" 1
# 26 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c" 2
# 1 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests/coverage.h" 1
# 27 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c" 2



#pragma clang diagnostic push
# 30 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wunused-function"
# 30 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wformat-nonliteral"
# 30 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
 typedef struct array_uint_s { size_t size; size_t alloc; unsigned int *ptr; } array_uint_t[1]; typedef struct array_uint_it_s { size_t index; const struct array_uint_s *array; } array_uint_it_t[1]; typedef struct array_uint_s *array_uint_ptr; typedef const struct array_uint_s *array_uint_srcptr; typedef array_uint_t array_uint_ct; typedef array_uint_it_t array_uint_it_ct; typedef unsigned int array_uint_subtype_ct; static inline void array_uint_init(array_uint_t v) { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); v->size = 0; v->alloc = 0; v->ptr = ((void*)0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_clean(array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); for(size_t i = 0; i < v->size; i++) ((void)(v->ptr[i])); v->size = 0; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_clear(array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); array_uint_clean(v); free(v->ptr); v->alloc = 0; v->ptr = ((void*)0); } static inline void array_uint_set(array_uint_t d, const array_uint_t s) { do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); if ((d == s)) return; if (s->size > d->alloc) { const size_t alloc = s->size; unsigned int *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(unsigned int)) ? ((void*)0) : realloc ((d->ptr), (alloc)*sizeof (unsigned int))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return ; } d->ptr = ptr; d->alloc = alloc; } size_t i; size_t step1 = ((s->size) < (d->size) ? (s->size) : (d->size)); for(i = 0; i < step1; i++) (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (d->ptr[i]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (d->ptr[i]) = (s->ptr[i])); for( ; i < s->size; i++) (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (d->ptr[i]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (d->ptr[i]) = (s->ptr[i])); for( ; i < d->size; i++) ((void)(d->ptr[i])); d->size = s->size; do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_init_set(array_uint_t d, const array_uint_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); array_uint_init(d); array_uint_set(d, s); } static inline void array_uint_init_move(array_uint_t d, array_uint_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); d->size = s->size; d->alloc = s->alloc; d->ptr = s->ptr; s->alloc = 0; s->ptr = ((void*)0); do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_move(array_uint_t d, array_uint_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); array_uint_clear(d); array_uint_init_move(d, s); } static inline void array_uint_set_at(array_uint_t v, size_t i, unsigned int const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (v->ptr[i]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (v->ptr[i]) = (x)); } static inline unsigned int const * array_uint_back(array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return (((union { unsigned int *ptr; unsigned int const *cptr; }){&v->ptr[v->size-1]}).cptr); } static inline unsigned int * array_uint_push_raw(array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); if ((v->size >= v->alloc)) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return ((void*)0); } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); unsigned int *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(unsigned int)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (unsigned int))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); unsigned int *ret = &v->ptr[v->size]; v->size++; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(ret != ((void*)0))) || (_wassert(L"ret != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); return ret; } static inline void array_uint_push_back(array_uint_t v, unsigned int const x) { unsigned int *data = array_uint_push_raw(v); if ((data == ((void*)0)) ) return; (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (*data) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (*data) = (x)); } static inline unsigned int * array_uint_push_new(array_uint_t v) { unsigned int *data = array_uint_push_raw(v); if ((data == ((void*)0)) ) return ((void*)0); ((*data) = 0); return data; } static inline void array_uint_push_move(array_uint_t v, unsigned int *x) { (void)( (!!(x != ((void*)0))) || (_wassert(L"x != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); unsigned int *data = array_uint_push_raw(v); if ((data == ((void*)0)) ) return; do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*data)) == sizeof((*x)));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*data)) == sizeof((*x)));})), memcpy(&((*data)), &((*x)), sizeof ((*data)))), memset(&((*x)), 0, sizeof ((*data)))); } while (0); } static inline void array_uint_push_at(array_uint_t v, size_t key, unsigned int const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!((key) < (v->size+1))) || (_wassert(L"(key) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); if ((v->size >= v->alloc) ) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return; } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); unsigned int *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(unsigned int)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (unsigned int))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); memmove(&v->ptr[key+1], &v->ptr[key], (v->size-key)*sizeof(unsigned int)); v->size++; (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (v->ptr[key]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (v->ptr[key]) = (x)); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_resize(array_uint_t v, size_t size) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); if (v->size > size) { for(size_t i = size ; i < v->size; i++) ((void)(v->ptr[i])); v->size = size; } else if (v->size < size) { if (size > v->alloc) { size_t alloc = size ; unsigned int *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(unsigned int)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (unsigned int))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) ((v->ptr[i]) = 0); v->size = size; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_reserve(array_uint_t v, size_t alloc) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); if (v->size > alloc) { alloc = v->size; } if ((alloc == 0)) { free(v->ptr); v->size = v->alloc = 0; v->ptr = ((void*)0); } else { unsigned int *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(unsigned int)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (unsigned int))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline unsigned int * array_uint_get_at(array_uint_t v, size_t idx) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); const size_t size = idx + 1; if (v->size <= size) { if ((size > v->alloc) ) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return ((void*)0); } unsigned int *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(unsigned int)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (unsigned int))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) ((v->ptr[i]) = 0); v->size = size; } (void)( (!!(idx < v->size)) || (_wassert(L"idx < v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return &v->ptr[idx]; } static inline void array_uint_pop_back(unsigned int *dest, array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); v->size--; if (dest) { do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), memcpy(&((*dest)), &((v->ptr[v->size])), sizeof ((*dest)))), memset(&((v->ptr[v->size])), 0, sizeof ((*dest)))); } while (0); } else { ((void)(v->ptr[v->size])); } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_pop_move(unsigned int *dest, array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(dest != ((void*)0))) || (_wassert(L"dest != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); v->size--; do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), memcpy(&((*dest)), &((v->ptr[v->size])), sizeof ((*dest)))), memset(&((v->ptr[v->size])), 0, sizeof ((*dest)))); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_pop_until(array_uint_t v, array_uint_it_t pos) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(v == pos->array)) || (_wassert(L"v == pos->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((pos->index) < (v->size + 1))) || (_wassert(L"(pos->index) < (v->size + 1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); array_uint_resize(v, pos->index); } static inline _Bool array_uint_empty_p(const array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return v->size == 0; } static inline size_t array_uint_size(const array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return v->size; } static inline size_t array_uint_capacity(const array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return v->alloc; } static inline void array_uint_pop_at(unsigned int *dest, array_uint_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); if (dest) do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[i])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[i])));})), memcpy(&((*dest)), &((v->ptr[i])), sizeof ((*dest)))), memset(&((v->ptr[i])), 0, sizeof ((*dest)))); } while (0); else ((void)(v->ptr[i])); memmove(&v->ptr[i], &v->ptr[i+1], sizeof(unsigned int)*(v->size - i) ); v->size--; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline _Bool array_uint_erase(array_uint_t a, size_t i) { do { (void)( (!!(a != ((void*)0))) || (_wassert(L"a != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(a->size <= a->alloc)) || (_wassert(L"a->size <= a->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(a->size == 0 || a->ptr != ((void*)0))) || (_wassert(L"a->size == 0 || a->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); if (i >= a->size) return 0; array_uint_pop_at(((void*)0), a, i); return 1; } static inline void array_uint_insert_v(array_uint_t v, size_t i, size_t num) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!((i) < (v->size+1))) || (_wassert(L"(i) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); size_t size = v->size + num; if ((size <= v->size)) { if (num == 0) return; do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * v->size), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return ; } if (size > v->alloc) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return ; } unsigned int *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(unsigned int)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (unsigned int))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } memmove(&v->ptr[i+num], &v->ptr[i], sizeof(unsigned int)*(v->size - i) ); for(size_t k = i ; k < i+num; k++) ((v->ptr[k]) = 0); v->size = size; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_remove_v(array_uint_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(i < j && v->ptr != ((void*)0))) || (_wassert(L"i < j && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!((j) < (v->size+1))) || (_wassert(L"(j) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); for(size_t k = i ; k < j; k++) ((void)(v->ptr[k])); memmove(&v->ptr[i], &v->ptr[j], sizeof(unsigned int)*(v->size - j) ); v->size -= (j-i); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_swap(array_uint_t v1, array_uint_t v2) { do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); size_t tmp = v1->size; v1->size = v2->size; v2->size = tmp; tmp = v1->alloc; v1->alloc = v2->alloc; v2->alloc = tmp; unsigned int *p = v1->ptr; v1->ptr = v2->ptr; v2->ptr = p; do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline void array_uint_swap_at(array_uint_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!((j) < (v->size))) || (_wassert(L"(j) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); unsigned int tmp; do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((tmp)) == sizeof((v->ptr[i])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((tmp)) == sizeof((v->ptr[i])));})), memcpy(&((tmp)), &((v->ptr[i])), sizeof ((tmp)))), memset(&((v->ptr[i])), 0, sizeof ((tmp)))); } while (0); do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[i])) == sizeof((v->ptr[j])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[i])) == sizeof((v->ptr[j])));})), memcpy(&((v->ptr[i])), &((v->ptr[j])), sizeof ((v->ptr[i])))), memset(&((v->ptr[j])), 0, sizeof ((v->ptr[i])))); } while (0); do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[j])) == sizeof((tmp)));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[j])) == sizeof((tmp)));})), memcpy(&((v->ptr[j])), &((tmp)), sizeof ((v->ptr[j])))), memset(&((tmp)), 0, sizeof ((v->ptr[j])))); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline unsigned int * array_uint_get(const array_uint_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return &v->ptr[i]; } static inline unsigned int const * array_uint_cget(const array_uint_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return (((union { unsigned int *ptr; unsigned int const *cptr; }){&v->ptr[i]}).cptr); } static inline unsigned int const * array_uint_front(const array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return array_uint_cget(v, 0); } static inline void array_uint_it(array_uint_it_t it, const array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); it->index = 0; it->array = v; } static inline void array_uint_it_last(array_uint_it_t it, const array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); it->index = v->size - 1; it->array = v; } static inline void array_uint_it_end(array_uint_it_t it, const array_uint_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); it->index = v->size; it->array = v; } static inline void array_uint_it_set(array_uint_it_t it, const array_uint_it_t org) { (void)( (!!(it != ((void*)0) && org != ((void*)0))) || (_wassert(L"it != ((void*)0) && org != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); it->index = org->index; it->array = org->array; do { (void)( (!!(it->array != ((void*)0))) || (_wassert(L"it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(it->array->size <= it->array->alloc)) || (_wassert(L"it->array->size <= it->array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(it->array->size == 0 || it->array->ptr != ((void*)0))) || (_wassert(L"it->array->size == 0 || it->array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); } static inline _Bool array_uint_end_p(const array_uint_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); return it->index >= it->array->size; } static inline _Bool array_uint_last_p(const array_uint_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); return it->index + 1 >= it->array->size; } static inline _Bool array_uint_it_equal_p(const array_uint_it_t it1, const array_uint_it_t it2) { (void)( (!!(it1 != ((void*)0) && it2 != ((void*)0))) || (_wassert(L"it1 != ((void*)0) && it2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); return it1->array == it2->array && it1->index == it2->index; } static inline void array_uint_next(array_uint_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); it->index++; } static inline void array_uint_previous(array_uint_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); it->index--; } static inline unsigned int * array_uint_ref(const array_uint_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); return array_uint_get(it->array, it->index); } static inline unsigned int const * array_uint_cref(const array_uint_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); return array_uint_cget(it->array, it->index); } static inline void array_uint_insert(array_uint_t a, array_uint_it_t it, unsigned int const x) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); array_uint_push_at(a, it->index + 1, x); it->index++; } static inline void array_uint_remove(array_uint_t a, array_uint_it_t it) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); array_uint_pop_at(((void*)0), a, it->index); } static inline void array_uint_special_sort(array_uint_t l, int (*func_type) (unsigned int const *a, unsigned int const *b)) { int (*func_void)(const void*, const void*); func_void = (int (*)(const void*, const void*))func_type; qsort(l->ptr, l->size, sizeof(unsigned int), func_void); } static inline void array_uint_special_stable_sort_noalloc (unsigned int tab[], size_t size, unsigned int tmp[]) { size_t th = 4; unsigned int *org_tab = tab; (void)( (!!(size > 1)) || (_wassert(L"size > 1", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); if (m_core_clz64(size-1) & 1) th += th; for(size_t k = 0 ; k < size; ) { size_t max = size - k < 2*th ? size - k : th; (void)( (!!(max >= th)) || (_wassert(L"max >= th", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); for(size_t i = 1; i < max; i++) { size_t j = i; while (j > 0 && ((tab[k+j-1]) < (tab[k+j]) ? -1 : (tab[k+j-1]) > (tab[k+j])) > 0) { do { char _tmp[sizeof (tab[k+j-1])]; ((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof(tab[k+j-1]) == sizeof(tab[k+j]));})); memcpy(&_tmp, &(tab[k+j-1]), sizeof (tab[k+j-1])); memcpy(&(tab[k+j-1]), &(tab[k+j]), sizeof (tab[k+j-1])); memcpy(&(tab[k+j]), &_tmp, sizeof (tab[k+j-1])); } while (0); j = j - 1; } } k += max; } while (th < size) { unsigned int *dest = tmp; for(size_t k = 0 ; k < size; ) { unsigned int *el1 = &tab[k]; unsigned int *el2 = &tab[k+th]; size_t n1 = th; size_t n2 = size-k <= 3*th ? size-k-th : th; (void)( (!!(size-k > th)) || (_wassert(L"size-k > th", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(0 < n1 && n1 <= size)) || (_wassert(L"0 < n1 && n1 <= size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(0 < n2 && n2 <= size)) || (_wassert(L"0 < n2 && n2 <= size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); k += n1+n2; for (;;) { if (((*el1) < (*el2) ? -1 : (*el1) > (*el2)) <= 0) { (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (*dest) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (*dest) = (*el1)); dest++; el1++; if (-- n1 == 0) { if (n2 > 0) { memcpy(dest, el2, n2 * sizeof (unsigned int)); dest += n2; } break; } } else { (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (*dest) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (*dest) = (*el2)); dest++; el2++; if (-- n2 == 0) { if (n1 > 0) { memcpy (dest, el1, n1 * sizeof (unsigned int)); dest += n1; } break; } } } } do { unsigned int * _tmp = (tab); (tab) = (tmp); (tmp) = _tmp; } while (0); th += th; } (void)( (!!(org_tab == tab)) || (_wassert(L"org_tab == tab", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } static inline void array_uint_special_stable_sort(array_uint_t l) { if ((l->size < 2)) return; unsigned int *temp = (((l->size) > 0xffffffffffffffffui64 / sizeof(unsigned int)) ? ((void*)0) : realloc ((((void*)0)), (l->size)*sizeof (unsigned int))); if (temp == ((void*)0)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * l->size), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); return; } array_uint_special_stable_sort_noalloc(l->ptr, l->size, temp); free(temp); } static inline void array_uint_get_str(string_t str, array_uint_t const array, _Bool append) { do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while(0); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (append ? string_cat_cstr : string_set_cstr) (str, "["); array_uint_it_t it; for (array_uint_it(it, array); !array_uint_end_p(it); array_uint_next(it)){ unsigned int const *item = array_uint_cref(it); (1 ? string_cat_printf : string_printf) (str, _Generic(((void)0,(*item)), char: "%c", _Bool: "%d", signed char: "%hhd", unsigned char: "%hhu", signed short: "%hd", unsigned short: "%hu", signed int: "%d", unsigned int: "%u", long int: "%ld", unsigned long int: "%lu", long long int: "%lld", unsigned long long int: "%llu", float: "%f", double: "%f", long double: "%Lf", const char *: "%s", char *: "%s", const void *: "%p", void *: "%p"), *item); if (!array_uint_last_p(it)) string_push_back (str, ','); } string_push_back (str, ']'); do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while(0); } static inline void array_uint_out_str(FILE *file, const array_uint_t array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(file != ((void*)0))) || (_wassert(L"file != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); fputc ('[', file); for (size_t i = 0; i < array->size; i++) { unsigned int const *item = array_uint_cget(array, i); fprintf(file, _Generic(((void)0,(*item)), char: "%c", _Bool: "%d", signed char: "%hhd", unsigned char: "%hhu", signed short: "%hd", unsigned short: "%hu", signed int: "%d", unsigned int: "%u", long int: "%ld", unsigned long int: "%lu", long long int: "%lld", unsigned long long int: "%llu", float: "%f", double: "%f", long double: "%Lf", const char *: "%s", char *: "%s", const void *: "%p", void *: "%p"), *item); if (i != array->size-1) fputc (',', file); } fputc (']', file); } static inline _Bool array_uint_parse_str(array_uint_t array, const char str[], const char**endp) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); array_uint_clean(array); _Bool success = 0; int c = *str++; if ((c != '[')) goto exit; c = *str++; if ((c == ']')) { success = 1; goto exit; } if ((c == 0)) goto exit; str--; unsigned int item; ((item) = 0); do { _Bool b = _Generic(((void)0,*(& item)), char: m_core_parse_char(_Generic(((void)0,(& item)), char*: (& item), default: (char*) 0),str,&str), _Bool: m_core_parse_bool(_Generic(((void)0,(& item)), _Bool*: (& item), default: (_Bool*) 0),str,&str), signed char: m_core_parse_schar(_Generic(((void)0,(& item)), signed char*: (& item), default: (signed char*) 0),str,&str), unsigned char: m_core_parse_uchar(_Generic(((void)0,(& item)), unsigned char*: (& item), default: (unsigned char*) 0),str,&str), signed short: m_core_parse_sshort(_Generic(((void)0,(& item)), signed short*: (& item), default: (signed short*) 0),str,&str), unsigned short: m_core_parse_ushort(_Generic(((void)0,(& item)), unsigned short*: (& item), default: (unsigned short*) 0),str,&str), signed int: m_core_parse_sint(_Generic(((void)0,(& item)), signed int*: (& item), default: (signed int*) 0),str,&str), unsigned int: m_core_parse_uint(_Generic(((void)0,(& item)), unsigned int*: (& item), default: (unsigned int*) 0),str,&str), signed long: m_core_parse_slong(_Generic(((void)0,(& item)), signed long *: (& item), default: (signed long *) 0),str,&str), unsigned long: m_core_parse_ulong(_Generic(((void)0,(& item)), unsigned long*: (& item), default: (unsigned long*) 0),str,&str), signed long long: m_core_parse_sllong(_Generic(((void)0,(& item)), signed long long*: (& item), default: (signed long long*) 0),str,&str), unsigned long long: m_core_parse_ullong(_Generic(((void)0,(& item)), unsigned long long*: (& item), default: (unsigned long long*) 0),str,&str), float: m_core_parse_float(_Generic(((void)0,(& item)), float*: (& item), default: (float*) 0),str,&str), double: m_core_parse_double(_Generic(((void)0,(& item)), double*: (& item), default: (double*) 0),str,&str), long double: m_core_parse_ldouble(_Generic(((void)0,(& item)), long double*: (& item), default: (long double*) 0),str,&str), const char *: 0 , char *: 0 , const void *: 0 , void *: 0 ); do { c = *str++; } while (isspace(c)); if (b == 0 || c == 0) { goto exit_clear; } array_uint_push_back(array, item); } while (c == ','); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); success = (c == ']'); exit_clear: ((void)(item)); exit: if (endp) *endp = str; return success; } static inline _Bool array_uint_in_str(array_uint_t array, FILE *file) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(file != ((void*)0))) || (_wassert(L"file != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); array_uint_clean(array); int c = fgetc(file); if ((c != '[')) return 0; c = fgetc(file); if ((c == ']')) return 1; if ((c == (-1))) return 0; ungetc(c, file); unsigned int item; ((item) = 0); do { _Bool b = _Generic(((void)0,*(& item)), _Bool: m_core_fscan_bool(_Generic(((void)0,(& item)), _Bool*: (& item), default: (_Bool*) 0), file), char: m_core_fscan_char(_Generic(((void)0,(& item)), char*: (& item), default: (char*) 0), file), signed char: m_core_fscan_schar(_Generic(((void)0,(& item)), signed char*: (& item), default: (signed char*) 0),file), unsigned char: m_core_fscan_uchar(_Generic(((void)0,(& item)), unsigned char*: (& item), default: (unsigned char*) 0),file), signed short: m_core_fscan_sshort(_Generic(((void)0,(& item)), signed short*: (& item), default: (signed short*) 0),file), unsigned short: m_core_fscan_ushort(_Generic(((void)0,(& item)), unsigned short*: (& item), default: (unsigned short*) 0), file), signed int: m_core_fscan_sint(_Generic(((void)0,(& item)), signed int*: (& item), default: (signed int*) 0), file), unsigned int: m_core_fscan_uint(_Generic(((void)0,(& item)), unsigned int*: (& item), default: (unsigned int*) 0), file), long int: m_core_fscan_slong(_Generic(((void)0,(& item)), long*: (& item), default: (long*) 0), file), unsigned long int: m_core_fscan_ulong(_Generic(((void)0,(& item)), unsigned long*: (& item), default: (unsigned long*) 0), file), long long int: m_core_fscan_sllong(_Generic(((void)0,(& item)), long long*: (& item), default: (long long*) 0), file), unsigned long long int: m_core_fscan_ullong(_Generic(((void)0,(& item)), unsigned long long*: (& item), default: (unsigned long long*) 0),file), float: m_core_fscan_float(_Generic(((void)0,(& item)), float*: (& item), default: (float*) 0), file), double: m_core_fscan_double(_Generic(((void)0,(& item)), double*: (& item), default: (double*) 0), file), long double: m_core_fscan_ldouble(_Generic(((void)0,(& item)), long double*: (& item), default: (long double*) 0),file), const char *: 0 , char *: 0 , const void *: 0 , void *: 0 ); do { c = fgetc(file); } while (isspace(c)); if (b == 0 || c == (-1)) { break; } array_uint_push_back(array, item); } while (c == ','); ((void)(item)); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return c == ']'; } static inline m_serial_return_code_t array_uint_out_serial(m_serial_write_t f, const array_uint_t array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(f != ((void*)0) && f->m_interface != ((void*)0))) || (_wassert(L"f != ((void*)0) && f->m_interface != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); m_serial_return_code_t ret; m_serial_local_t local; ret = f->m_interface->write_array_start(local, f, array->size); for (size_t i = 0; i < array->size; i++) { unsigned int const *item = array_uint_cget(array, i); if (i != 0) { ret |= f->m_interface->write_array_next(local, f); } ret |= _Generic(((void)0,(*item)), _Bool: (f)->m_interface->write_boolean (f, _Generic(((void)0,((*item))), _Bool: ((*item)), default: (_Bool) 0)), char: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), char: ((*item)), default: (char) 0), sizeof (*item)), signed char: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), signed char: ((*item)), default: (signed char) 0), sizeof (*item)), unsigned char: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned char: ((*item)), default: (unsigned char) 0), sizeof (*item)), signed short: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), signed short: ((*item)), default: (signed short) 0), sizeof (*item)), unsigned short: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned short: ((*item)), default: (unsigned short) 0), sizeof (*item)), signed int: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), signed int: ((*item)), default: (signed int) 0), sizeof (*item)), unsigned int: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned int: ((*item)), default: (unsigned int) 0), sizeof (*item)), long int: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), long: ((*item)), default: (long) 0), sizeof (*item)), unsigned long int: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned long: ((*item)), default: (unsigned long) 0), sizeof (*item)), long long int: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), long long: ((*item)), default: (long long) 0), sizeof (*item)), unsigned long long int: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned long long: ((*item)), default: (unsigned long long) 0), sizeof (*item)), float: (f)->m_interface->write_float (f, _Generic(((void)0,((*item))), float: ((*item)), default: (float) 0), sizeof (*item)), double: (f)->m_interface->write_float (f, _Generic(((void)0,((*item))), double: ((*item)), default: (double) 0), sizeof (*item)), long double: (f)->m_interface->write_float (f, _Generic(((void)0,((*item))), long double: ((*item)), default: (long double) 0), sizeof (*item)), const char *: (f)->m_interface->write_string (f, _Generic(((void)0,((*item))), const char *: ((*item)), default: (const char *) 0), m_core_out_serial_strlen(_Generic(((void)0,((*item))), const char *: ((*item)), default: (const char *) 0)) ), char *: (f)->m_interface->write_string (f, _Generic(((void)0,((*item))), char *: ((*item)), default: (char *) 0), m_core_out_serial_strlen(_Generic(((void)0,((*item))), const char *: ((*item)), default: (const char *) 0)) ), const void *: M_SERIAL_FAIL , void *: M_SERIAL_FAIL ); } ret |= f->m_interface->write_array_end(local, f); return ret & M_SERIAL_FAIL; } static inline m_serial_return_code_t array_uint_in_serial(array_uint_t array, m_serial_read_t f) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); (void)( (!!(f != ((void*)0) && f->m_interface != ((void*)0))) || (_wassert(L"f != ((void*)0) && f->m_interface != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); m_serial_return_code_t ret; m_serial_local_t local; size_t estimated_size = 0; array_uint_clean(array); ret = f->m_interface->read_array_start(local, f, &estimated_size); if ((ret != M_SERIAL_OK_CONTINUE)) { return ret; } if (estimated_size != 0) { array_uint_reserve(array, estimated_size); } unsigned int item; ((item) = 0); do { ret = _Generic(((void)0,*(& item)), _Bool: (f)->m_interface->read_boolean (f, _Generic(((void)0,(& item)), _Bool *: (& item), default: (_Bool *) 0)), char: m_core_in_serial_char(f, _Generic(((void)0,(& item)), char*: (& item), default: (char*) 0)), signed char: m_core_in_serial_schar (f, _Generic(((void)0,(& item)), signed char*: (& item), default: (signed char*) 0)), unsigned char: m_core_in_serial_uchar (f, _Generic(((void)0,(& item)), unsigned char*: (& item), default: (unsigned char*) 0)), signed short: m_core_in_serial_sshort (f, _Generic(((void)0,(& item)), signed short*: (& item), default: (signed short*) 0)), unsigned short: m_core_in_serial_ushort (f, _Generic(((void)0,(& item)), unsigned short*: (& item), default: (unsigned short*) 0)), signed int: m_core_in_serial_sint (f, _Generic(((void)0,(& item)), signed int*: (& item), default: (signed int*) 0)), unsigned int: m_core_in_serial_uint (f, _Generic(((void)0,(& item)), unsigned int*: (& item), default: (unsigned int*) 0)), long int: m_core_in_serial_slong(f, _Generic(((void)0,(& item)), long*: (& item), default: (long*) 0)), unsigned long int: m_core_in_serial_ulong (f, _Generic(((void)0,(& item)), unsigned long*: (& item), default: (unsigned long*) 0)), long long int: m_core_in_serial_sllong (f, _Generic(((void)0,(& item)), long long*: (& item), default: (long long*) 0)), unsigned long long int: m_core_in_serial_ullong (f, _Generic(((void)0,(& item)), unsigned long long*: (& item), default: (unsigned long long*) 0)), float: m_core_in_serial_float(f, _Generic(((void)0,(& item)), float*: (& item), default: (float*) 0)), double: m_core_in_serial_double(f, _Generic(((void)0,(& item)), double*: (& item), default: (double*) 0)), long double: m_core_in_serial_ldouble (f, _Generic(((void)0,(& item)), long double*: (& item), default: (long double*) 0)), const char *: M_SERIAL_FAIL , char *: M_SERIAL_FAIL , const void *: M_SERIAL_FAIL , void *: M_SERIAL_FAIL ); if (ret != M_SERIAL_OK_DONE) { break; } array_uint_push_back(array, item); ret = f->m_interface->read_array_next(local, f); } while (ret == M_SERIAL_OK_CONTINUE); ((void)(item)); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); return ret; } static inline _Bool array_uint_equal_p(const array_uint_t array1, const array_uint_t array2) { do { (void)( (!!(array1 != ((void*)0))) || (_wassert(L"array1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array1->size <= array1->alloc)) || (_wassert(L"array1->size <= array1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array1->size == 0 || array1->ptr != ((void*)0))) || (_wassert(L"array1->size == 0 || array1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!(array2 != ((void*)0))) || (_wassert(L"array2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array2->size <= array2->alloc)) || (_wassert(L"array2->size <= array2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array2->size == 0 || array2->ptr != ((void*)0))) || (_wassert(L"array2->size == 0 || array2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); if (array1->size != array2->size) return 0; size_t i; for(i = 0; i < array1->size; i++) { unsigned int const *item1 = array_uint_cget(array1, i); unsigned int const *item2 = array_uint_cget(array2, i); _Bool b = ((*item1) == (*item2)); if (!b) return 0; } return i == array1->size; } static inline size_t array_uint_hash(const array_uint_t array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); size_t hash = 0UL ^ 0UL; for(size_t i = 0 ; i < array->size; i++) { size_t hi = (size_t) _Generic((array->ptr[i])+0, int32_t: ( ((uint32_t) _Generic(((void)0,(array->ptr[i])), int32_t: (array->ptr[i]), default: (int32_t) 0)) ^ (((uint32_t) _Generic(((void)0,(array->ptr[i])), int32_t: (array->ptr[i]), default: (int32_t) 0)) << 11) ^ 0UL ), uint32_t: ( (_Generic(((void)0,(array->ptr[i])), uint32_t: (array->ptr[i]), default: (uint32_t) 0)) ^ ((_Generic(((void)0,(array->ptr[i])), uint32_t: (array->ptr[i]), default: (uint32_t) 0)) << 11) ^ 0UL ), int64_t: ( ( ((uint64_t) _Generic(((void)0,(array->ptr[i])), int64_t: (array->ptr[i]), default: (int64_t) 0)) >> 33 ) ^ ((uint64_t) _Generic(((void)0,(array->ptr[i])), int64_t: (array->ptr[i]), default: (int64_t) 0)) ^ (((uint64_t) _Generic(((void)0,(array->ptr[i])), int64_t: (array->ptr[i]), default: (int64_t) 0)) << 11) ^ 0UL ), uint64_t: ( ( (_Generic(((void)0,(array->ptr[i])), uint64_t: (array->ptr[i]), default: (uint64_t) 0)) >> 33 ) ^ (_Generic(((void)0,(array->ptr[i])), uint64_t: (array->ptr[i]), default: (uint64_t) 0)) ^ ((_Generic(((void)0,(array->ptr[i])), uint64_t: (array->ptr[i]), default: (uint64_t) 0)) << 11) ^ 0UL ), default: m_core_hash((const void*) &(array->ptr[i]), sizeof (array->ptr[i])) ); do { hash = (size_t) (((hash) * 0x811C9DC5UL) ^ ((hi))); } while (0); } return ( (hash) >> (sizeof(size_t)*8/2) | (hash) ); } static inline void array_uint_splice(array_uint_t a1, array_uint_t a2) { do { (void)( (!!(a1 != ((void*)0))) || (_wassert(L"a1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(a1->size <= a1->alloc)) || (_wassert(L"a1->size <= a1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(a1->size == 0 || a1->ptr != ((void*)0))) || (_wassert(L"a1->size == 0 || a1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); do { (void)( (!!(a2 != ((void*)0))) || (_wassert(L"a2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(a2->size <= a2->alloc)) || (_wassert(L"a2->size <= a2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); (void)( (!!(a2->size == 0 || a2->ptr != ((void*)0))) || (_wassert(L"a2->size == 0 || a2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(30)), 0) ); } while (0); if ((a2->size > 0)) { size_t newSize = a1->size + a2->size; if (newSize > a1->alloc) { unsigned int *ptr = (((newSize) > 0xffffffffffffffffui64 / sizeof(unsigned int)) ? ((void*)0) : realloc ((a1->ptr), (newSize)*sizeof (unsigned int))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (unsigned int) * newSize), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 30); abort(); } while (0); } a1->ptr = ptr; a1->alloc = newSize; } memcpy(&a1->ptr[a1->size], &a2->ptr[0], a2->size * sizeof (unsigned int)); a2->size = 0; a1->size = newSize; } }
# 30 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic pop
#pragma clang diagnostic push
# 31 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wunused-function"
# 31 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wformat-nonliteral"
# 31 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
 typedef struct array_mpz_s { size_t size; size_t alloc; testobj_t *ptr; } array_mpz_t[1]; typedef struct array_mpz_it_s { size_t index; const struct array_mpz_s *array; } array_mpz_it_t[1]; typedef struct array_mpz_s *array_mpz_ptr; typedef const struct array_mpz_s *array_mpz_srcptr; typedef array_mpz_t array_mpz_ct; typedef array_mpz_it_t array_mpz_it_ct; typedef testobj_t array_mpz_subtype_ct; static inline void array_mpz_int_control_type1(void) { testobj_t x; ((void) sizeof(struct { int M_LIB_TYPE_MISTMACH : !!(_Generic(&x, testobj_t *: 1 , default: 0 ));})); } static inline void array_mpz_init(array_mpz_t v) { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); v->size = 0; v->alloc = 0; v->ptr = ((void*)0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_clean(array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); for(size_t i = 0; i < v->size; i++) testobj_clear(v->ptr[i]); v->size = 0; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_clear(array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); array_mpz_clean(v); free(v->ptr); v->alloc = 0; v->ptr = ((void*)0); } static inline void array_mpz_set(array_mpz_t d, const array_mpz_t s) { do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); if ((d == s)) return; if (s->size > d->alloc) { const size_t alloc = s->size; testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((d->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return ; } d->ptr = ptr; d->alloc = alloc; } size_t i; size_t step1 = ((s->size) < (d->size) ? (s->size) : (d->size)); for(i = 0; i < step1; i++) testobj_set(d->ptr[i], s->ptr[i]); for( ; i < s->size; i++) testobj_init_set(d->ptr[i], s->ptr[i]); for( ; i < d->size; i++) testobj_clear(d->ptr[i]); d->size = s->size; do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_init_set(array_mpz_t d, const array_mpz_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); array_mpz_init(d); array_mpz_set(d, s); } static inline void array_mpz_init_move(array_mpz_t d, array_mpz_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); d->size = s->size; d->alloc = s->alloc; d->ptr = s->ptr; s->alloc = 0; s->ptr = ((void*)0); do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_move(array_mpz_t d, array_mpz_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); array_mpz_clear(d); array_mpz_init_move(d, s); } static inline void array_mpz_set_at(array_mpz_t v, size_t i, testobj_t const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); testobj_set(v->ptr[i], x); } static inline testobj_t const * array_mpz_back(array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); return (((union { testobj_t *ptr; testobj_t const *cptr; }){&v->ptr[v->size-1]}).cptr); } static inline testobj_t * array_mpz_push_raw(array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); if ((v->size >= v->alloc)) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return ((void*)0); } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); testobj_t *ret = &v->ptr[v->size]; v->size++; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(ret != ((void*)0))) || (_wassert(L"ret != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); return ret; } static inline void array_mpz_push_back(array_mpz_t v, testobj_t const x) { testobj_t *data = array_mpz_push_raw(v); if ((data == ((void*)0)) ) return; testobj_init_set(*data, x); } static inline testobj_t * array_mpz_push_new(array_mpz_t v) { testobj_t *data = array_mpz_push_raw(v); if ((data == ((void*)0)) ) return ((void*)0); testobj_init(*data); return data; } static inline void array_mpz_push_move(array_mpz_t v, testobj_t *x) { (void)( (!!(x != ((void*)0))) || (_wassert(L"x != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); testobj_t *data = array_mpz_push_raw(v); if ((data == ((void*)0)) ) return; do { testobj_init_set((*data), (*x)) ; testobj_clear((*x)); } while (0); } static inline void array_mpz_push_at(array_mpz_t v, size_t key, testobj_t const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!((key) < (v->size+1))) || (_wassert(L"(key) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); if ((v->size >= v->alloc) ) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return; } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); memmove(&v->ptr[key+1], &v->ptr[key], (v->size-key)*sizeof(testobj_t)); v->size++; testobj_init_set(v->ptr[key], x); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_resize(array_mpz_t v, size_t size) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); if (v->size > size) { for(size_t i = size ; i < v->size; i++) testobj_clear(v->ptr[i]); v->size = size; } else if (v->size < size) { if (size > v->alloc) { size_t alloc = size ; testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) testobj_init(v->ptr[i]); v->size = size; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_reserve(array_mpz_t v, size_t alloc) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); if (v->size > alloc) { alloc = v->size; } if ((alloc == 0)) { free(v->ptr); v->size = v->alloc = 0; v->ptr = ((void*)0); } else { testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline testobj_t * array_mpz_get_at(array_mpz_t v, size_t idx) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); const size_t size = idx + 1; if (v->size <= size) { if ((size > v->alloc) ) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return ((void*)0); } testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) testobj_init(v->ptr[i]); v->size = size; } (void)( (!!(idx < v->size)) || (_wassert(L"idx < v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); return &v->ptr[idx]; } static inline void array_mpz_pop_back(testobj_t *dest, array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); v->size--; if (dest) { do { testobj_set((*dest), (v->ptr[v->size])); testobj_clear((v->ptr[v->size])); } while (0); } else { testobj_clear(v->ptr[v->size]); } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_pop_move(testobj_t *dest, array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(dest != ((void*)0))) || (_wassert(L"dest != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); v->size--; do { testobj_init_set((*dest), (v->ptr[v->size])) ; testobj_clear((v->ptr[v->size])); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_pop_until(array_mpz_t v, array_mpz_it_t pos) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(v == pos->array)) || (_wassert(L"v == pos->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((pos->index) < (v->size + 1))) || (_wassert(L"(pos->index) < (v->size + 1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); array_mpz_resize(v, pos->index); } static inline _Bool array_mpz_empty_p(const array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); return v->size == 0; } static inline size_t array_mpz_size(const array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); return v->size; } static inline size_t array_mpz_capacity(const array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); return v->alloc; } static inline void array_mpz_pop_at(testobj_t *dest, array_mpz_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); if (dest) do { testobj_set((*dest), (v->ptr[i])); testobj_clear((v->ptr[i])); } while (0); else testobj_clear(v->ptr[i]); memmove(&v->ptr[i], &v->ptr[i+1], sizeof(testobj_t)*(v->size - i) ); v->size--; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline _Bool array_mpz_erase(array_mpz_t a, size_t i) { do { (void)( (!!(a != ((void*)0))) || (_wassert(L"a != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(a->size <= a->alloc)) || (_wassert(L"a->size <= a->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(a->size == 0 || a->ptr != ((void*)0))) || (_wassert(L"a->size == 0 || a->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); if (i >= a->size) return 0; array_mpz_pop_at(((void*)0), a, i); return 1; } static inline void array_mpz_insert_v(array_mpz_t v, size_t i, size_t num) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!((i) < (v->size+1))) || (_wassert(L"(i) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); size_t size = v->size + num; if ((size <= v->size)) { if (num == 0) return; do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * v->size), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return ; } if (size > v->alloc) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return ; } testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } memmove(&v->ptr[i+num], &v->ptr[i], sizeof(testobj_t)*(v->size - i) ); for(size_t k = i ; k < i+num; k++) testobj_init(v->ptr[k]); v->size = size; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_remove_v(array_mpz_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(i < j && v->ptr != ((void*)0))) || (_wassert(L"i < j && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!((j) < (v->size+1))) || (_wassert(L"(j) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); for(size_t k = i ; k < j; k++) testobj_clear(v->ptr[k]); memmove(&v->ptr[i], &v->ptr[j], sizeof(testobj_t)*(v->size - j) ); v->size -= (j-i); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_swap(array_mpz_t v1, array_mpz_t v2) { do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); size_t tmp = v1->size; v1->size = v2->size; v2->size = tmp; tmp = v1->alloc; v1->alloc = v2->alloc; v2->alloc = tmp; testobj_t *p = v1->ptr; v1->ptr = v2->ptr; v2->ptr = p; do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline void array_mpz_swap_at(array_mpz_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!((j) < (v->size))) || (_wassert(L"(j) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); testobj_t tmp; do { testobj_init_set((tmp), (v->ptr[i])) ; testobj_clear((v->ptr[i])); } while (0); do { testobj_init_set((v->ptr[i]), (v->ptr[j])) ; testobj_clear((v->ptr[j])); } while (0); do { testobj_init_set((v->ptr[j]), (tmp)) ; testobj_clear((tmp)); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline testobj_t * array_mpz_get(const array_mpz_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); return &v->ptr[i]; } static inline testobj_t const * array_mpz_cget(const array_mpz_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); return (((union { testobj_t *ptr; testobj_t const *cptr; }){&v->ptr[i]}).cptr); } static inline testobj_t const * array_mpz_front(const array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); return array_mpz_cget(v, 0); } static inline void array_mpz_it(array_mpz_it_t it, const array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); it->index = 0; it->array = v; } static inline void array_mpz_it_last(array_mpz_it_t it, const array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); it->index = v->size - 1; it->array = v; } static inline void array_mpz_it_end(array_mpz_it_t it, const array_mpz_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); it->index = v->size; it->array = v; } static inline void array_mpz_it_set(array_mpz_it_t it, const array_mpz_it_t org) { (void)( (!!(it != ((void*)0) && org != ((void*)0))) || (_wassert(L"it != ((void*)0) && org != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); it->index = org->index; it->array = org->array; do { (void)( (!!(it->array != ((void*)0))) || (_wassert(L"it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(it->array->size <= it->array->alloc)) || (_wassert(L"it->array->size <= it->array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(it->array->size == 0 || it->array->ptr != ((void*)0))) || (_wassert(L"it->array->size == 0 || it->array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); } static inline _Bool array_mpz_end_p(const array_mpz_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); return it->index >= it->array->size; } static inline _Bool array_mpz_last_p(const array_mpz_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); return it->index + 1 >= it->array->size; } static inline _Bool array_mpz_it_equal_p(const array_mpz_it_t it1, const array_mpz_it_t it2) { (void)( (!!(it1 != ((void*)0) && it2 != ((void*)0))) || (_wassert(L"it1 != ((void*)0) && it2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); return it1->array == it2->array && it1->index == it2->index; } static inline void array_mpz_next(array_mpz_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); it->index++; } static inline void array_mpz_previous(array_mpz_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); it->index--; } static inline testobj_t * array_mpz_ref(const array_mpz_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); return array_mpz_get(it->array, it->index); } static inline testobj_t const * array_mpz_cref(const array_mpz_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); return array_mpz_cget(it->array, it->index); } static inline void array_mpz_insert(array_mpz_t a, array_mpz_it_t it, testobj_t const x) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); array_mpz_push_at(a, it->index + 1, x); it->index++; } static inline void array_mpz_remove(array_mpz_t a, array_mpz_it_t it) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); array_mpz_pop_at(((void*)0), a, it->index); } static inline void array_mpz_get_str(string_t str, array_mpz_t const array, _Bool append) { do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while(0); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (append ? string_cat_cstr : string_set_cstr) (str, "["); array_mpz_it_t it; for (array_mpz_it(it, array); !array_mpz_end_p(it); array_mpz_next(it)){ testobj_t const *item = array_mpz_cref(it); testobj_str(str, *item, 1); if (!array_mpz_last_p(it)) string_push_back (str, ','); } string_push_back (str, ']'); do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while(0); } static inline void array_mpz_out_str(FILE *file, const array_mpz_t array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(file != ((void*)0))) || (_wassert(L"file != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); fputc ('[', file); for (size_t i = 0; i < array->size; i++) { testobj_t const *item = array_mpz_cget(array, i); testobj_out_str(file, *item); if (i != array->size-1) fputc (',', file); } fputc (']', file); } static inline _Bool array_mpz_parse_str(array_mpz_t array, const char str[], const char**endp) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); array_mpz_clean(array); _Bool success = 0; int c = *str++; if ((c != '[')) goto exit; c = *str++; if ((c == ']')) { success = 1; goto exit; } if ((c == 0)) goto exit; str--; testobj_t item; testobj_init(item); do { _Bool b = testobj_parse_str(item, str, &str); do { c = *str++; } while (isspace(c)); if (b == 0 || c == 0) { goto exit_clear; } array_mpz_push_back(array, item); } while (c == ','); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); success = (c == ']'); exit_clear: testobj_clear(item); exit: if (endp) *endp = str; return success; } static inline _Bool array_mpz_in_str(array_mpz_t array, FILE *file) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); (void)( (!!(file != ((void*)0))) || (_wassert(L"file != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); array_mpz_clean(array); int c = fgetc(file); if ((c != '[')) return 0; c = fgetc(file); if ((c == ']')) return 1; if ((c == (-1))) return 0; ungetc(c, file); testobj_t item; testobj_init(item); do { _Bool b = testobj_in_str(item, file); do { c = fgetc(file); } while (isspace(c)); if (b == 0 || c == (-1)) { break; } array_mpz_push_back(array, item); } while (c == ','); testobj_clear(item); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); return c == ']'; } static inline _Bool array_mpz_equal_p(const array_mpz_t array1, const array_mpz_t array2) { do { (void)( (!!(array1 != ((void*)0))) || (_wassert(L"array1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array1->size <= array1->alloc)) || (_wassert(L"array1->size <= array1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array1->size == 0 || array1->ptr != ((void*)0))) || (_wassert(L"array1->size == 0 || array1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!(array2 != ((void*)0))) || (_wassert(L"array2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array2->size <= array2->alloc)) || (_wassert(L"array2->size <= array2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(array2->size == 0 || array2->ptr != ((void*)0))) || (_wassert(L"array2->size == 0 || array2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); if (array1->size != array2->size) return 0; size_t i; for(i = 0; i < array1->size; i++) { testobj_t const *item1 = array_mpz_cget(array1, i); testobj_t const *item2 = array_mpz_cget(array2, i); _Bool b = testobj_equal_p(*item1, *item2); if (!b) return 0; } return i == array1->size; } static inline void array_mpz_splice(array_mpz_t a1, array_mpz_t a2) { do { (void)( (!!(a1 != ((void*)0))) || (_wassert(L"a1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(a1->size <= a1->alloc)) || (_wassert(L"a1->size <= a1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(a1->size == 0 || a1->ptr != ((void*)0))) || (_wassert(L"a1->size == 0 || a1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); do { (void)( (!!(a2 != ((void*)0))) || (_wassert(L"a2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(a2->size <= a2->alloc)) || (_wassert(L"a2->size <= a2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); (void)( (!!(a2->size == 0 || a2->ptr != ((void*)0))) || (_wassert(L"a2->size == 0 || a2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(31)), 0) ); } while (0); if ((a2->size > 0)) { size_t newSize = a1->size + a2->size; if (newSize > a1->alloc) { testobj_t *ptr = (((newSize) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((a1->ptr), (newSize)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * newSize), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 31); abort(); } while (0); } a1->ptr = ptr; a1->alloc = newSize; } memcpy(&a1->ptr[a1->size], &a2->ptr[0], a2->size * sizeof (testobj_t)); a2->size = 0; a1->size = newSize; } }
# 31 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic pop




#pragma clang diagnostic push
# 36 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wunused-function"
# 36 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wformat-nonliteral"
# 36 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
 typedef struct array_min_z_s { size_t size; size_t alloc; testobj_t *ptr; } array_min_z_t[1]; typedef struct array_min_z_it_s { size_t index; const struct array_min_z_s *array; } array_min_z_it_t[1]; typedef struct array_min_z_s *array_min_z_ptr; typedef const struct array_min_z_s *array_min_z_srcptr; typedef array_min_z_t array_min_z_ct; typedef array_min_z_it_t array_min_z_it_ct; typedef testobj_t array_min_z_subtype_ct; static inline void array_min_z_init(array_min_z_t v) { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); v->size = 0; v->alloc = 0; v->ptr = ((void*)0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline void array_min_z_clean(array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); for(size_t i = 0; i < v->size; i++) testobj_clear(v->ptr[i]); v->size = 0; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline void array_min_z_clear(array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); array_min_z_clean(v); free(v->ptr); v->alloc = 0; v->ptr = ((void*)0); } static inline void array_min_z_set(array_min_z_t d, const array_min_z_t s) { do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); if ((d == s)) return; if (s->size > d->alloc) { const size_t alloc = s->size; testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((d->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 36); abort(); } while (0); return ; } d->ptr = ptr; d->alloc = alloc; } size_t i; size_t step1 = ((s->size) < (d->size) ? (s->size) : (d->size)); for(i = 0; i < step1; i++) testobj_set(d->ptr[i], s->ptr[i]); for( ; i < s->size; i++) testobj_init_set(d->ptr[i], s->ptr[i]); for( ; i < d->size; i++) testobj_clear(d->ptr[i]); d->size = s->size; do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline void array_min_z_init_set(array_min_z_t d, const array_min_z_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); array_min_z_init(d); array_min_z_set(d, s); } static inline void array_min_z_init_move(array_min_z_t d, array_min_z_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); d->size = s->size; d->alloc = s->alloc; d->ptr = s->ptr; s->alloc = 0; s->ptr = ((void*)0); do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline void array_min_z_move(array_min_z_t d, array_min_z_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); array_min_z_clear(d); array_min_z_init_move(d, s); } static inline void array_min_z_set_at(array_min_z_t v, size_t i, testobj_t const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); testobj_set(v->ptr[i], x); } static inline testobj_t const * array_min_z_back(array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); return (((union { testobj_t *ptr; testobj_t const *cptr; }){&v->ptr[v->size-1]}).cptr); } static inline testobj_t * array_min_z_push_raw(array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); if ((v->size >= v->alloc)) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 36); abort(); } while (0); return ((void*)0); } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 36); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); testobj_t *ret = &v->ptr[v->size]; v->size++; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(ret != ((void*)0))) || (_wassert(L"ret != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); return ret; } static inline void array_min_z_push_back(array_min_z_t v, testobj_t const x) { testobj_t *data = array_min_z_push_raw(v); if ((data == ((void*)0)) ) return; testobj_init_set(*data, x); } static inline void array_min_z_push_move(array_min_z_t v, testobj_t *x) { (void)( (!!(x != ((void*)0))) || (_wassert(L"x != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); testobj_t *data = array_min_z_push_raw(v); if ((data == ((void*)0)) ) return; do { testobj_init_set((*data), (*x)) ; testobj_clear((*x)); } while (0); } static inline void array_min_z_push_at(array_min_z_t v, size_t key, testobj_t const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); do { (void)( (!!((key) < (v->size+1))) || (_wassert(L"(key) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); if ((v->size >= v->alloc) ) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 36); abort(); } while (0); return; } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 36); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); memmove(&v->ptr[key+1], &v->ptr[key], (v->size-key)*sizeof(testobj_t)); v->size++; testobj_init_set(v->ptr[key], x); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline void array_min_z_reserve(array_min_z_t v, size_t alloc) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); if (v->size > alloc) { alloc = v->size; } if ((alloc == 0)) { free(v->ptr); v->size = v->alloc = 0; v->ptr = ((void*)0); } else { testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 36); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline void array_min_z_pop_back(testobj_t *dest, array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); v->size--; if (dest) { do { testobj_set((*dest), (v->ptr[v->size])); testobj_clear((v->ptr[v->size])); } while (0); } else { testobj_clear(v->ptr[v->size]); } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline void array_min_z_pop_move(testobj_t *dest, array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(dest != ((void*)0))) || (_wassert(L"dest != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); v->size--; do { testobj_init_set((*dest), (v->ptr[v->size])) ; testobj_clear((v->ptr[v->size])); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline _Bool array_min_z_empty_p(const array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); return v->size == 0; } static inline size_t array_min_z_size(const array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); return v->size; } static inline size_t array_min_z_capacity(const array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); return v->alloc; } static inline void array_min_z_pop_at(testobj_t *dest, array_min_z_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); if (dest) do { testobj_set((*dest), (v->ptr[i])); testobj_clear((v->ptr[i])); } while (0); else testobj_clear(v->ptr[i]); memmove(&v->ptr[i], &v->ptr[i+1], sizeof(testobj_t)*(v->size - i) ); v->size--; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline _Bool array_min_z_erase(array_min_z_t a, size_t i) { do { (void)( (!!(a != ((void*)0))) || (_wassert(L"a != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(a->size <= a->alloc)) || (_wassert(L"a->size <= a->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(a->size == 0 || a->ptr != ((void*)0))) || (_wassert(L"a->size == 0 || a->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); if (i >= a->size) return 0; array_min_z_pop_at(((void*)0), a, i); return 1; } static inline void array_min_z_remove_v(array_min_z_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(i < j && v->ptr != ((void*)0))) || (_wassert(L"i < j && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); do { (void)( (!!((j) < (v->size+1))) || (_wassert(L"(j) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); for(size_t k = i ; k < j; k++) testobj_clear(v->ptr[k]); memmove(&v->ptr[i], &v->ptr[j], sizeof(testobj_t)*(v->size - j) ); v->size -= (j-i); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline void array_min_z_swap(array_min_z_t v1, array_min_z_t v2) { do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); size_t tmp = v1->size; v1->size = v2->size; v2->size = tmp; tmp = v1->alloc; v1->alloc = v2->alloc; v2->alloc = tmp; testobj_t *p = v1->ptr; v1->ptr = v2->ptr; v2->ptr = p; do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline void array_min_z_swap_at(array_min_z_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); do { (void)( (!!((j) < (v->size))) || (_wassert(L"(j) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); testobj_t tmp; do { testobj_init_set((tmp), (v->ptr[i])) ; testobj_clear((v->ptr[i])); } while (0); do { testobj_init_set((v->ptr[i]), (v->ptr[j])) ; testobj_clear((v->ptr[j])); } while (0); do { testobj_init_set((v->ptr[j]), (tmp)) ; testobj_clear((tmp)); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline testobj_t * array_min_z_get(const array_min_z_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); return &v->ptr[i]; } static inline testobj_t const * array_min_z_cget(const array_min_z_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); return (((union { testobj_t *ptr; testobj_t const *cptr; }){&v->ptr[i]}).cptr); } static inline testobj_t const * array_min_z_front(const array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); return array_min_z_cget(v, 0); } static inline void array_min_z_it(array_min_z_it_t it, const array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); it->index = 0; it->array = v; } static inline void array_min_z_it_last(array_min_z_it_t it, const array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); it->index = v->size - 1; it->array = v; } static inline void array_min_z_it_end(array_min_z_it_t it, const array_min_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); it->index = v->size; it->array = v; } static inline void array_min_z_it_set(array_min_z_it_t it, const array_min_z_it_t org) { (void)( (!!(it != ((void*)0) && org != ((void*)0))) || (_wassert(L"it != ((void*)0) && org != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); it->index = org->index; it->array = org->array; do { (void)( (!!(it->array != ((void*)0))) || (_wassert(L"it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(it->array->size <= it->array->alloc)) || (_wassert(L"it->array->size <= it->array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(it->array->size == 0 || it->array->ptr != ((void*)0))) || (_wassert(L"it->array->size == 0 || it->array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); } static inline _Bool array_min_z_end_p(const array_min_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); return it->index >= it->array->size; } static inline _Bool array_min_z_last_p(const array_min_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); return it->index + 1 >= it->array->size; } static inline _Bool array_min_z_it_equal_p(const array_min_z_it_t it1, const array_min_z_it_t it2) { (void)( (!!(it1 != ((void*)0) && it2 != ((void*)0))) || (_wassert(L"it1 != ((void*)0) && it2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); return it1->array == it2->array && it1->index == it2->index; } static inline void array_min_z_next(array_min_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); it->index++; } static inline void array_min_z_previous(array_min_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); it->index--; } static inline testobj_t * array_min_z_ref(const array_min_z_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); return array_min_z_get(it->array, it->index); } static inline testobj_t const * array_min_z_cref(const array_min_z_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); return array_min_z_cget(it->array, it->index); } static inline void array_min_z_insert(array_min_z_t a, array_min_z_it_t it, testobj_t const x) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); array_min_z_push_at(a, it->index + 1, x); it->index++; } static inline void array_min_z_remove(array_min_z_t a, array_min_z_it_t it) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); array_min_z_pop_at(((void*)0), a, it->index); } static inline void array_min_z_splice(array_min_z_t a1, array_min_z_t a2) { do { (void)( (!!(a1 != ((void*)0))) || (_wassert(L"a1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(a1->size <= a1->alloc)) || (_wassert(L"a1->size <= a1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(a1->size == 0 || a1->ptr != ((void*)0))) || (_wassert(L"a1->size == 0 || a1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); do { (void)( (!!(a2 != ((void*)0))) || (_wassert(L"a2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(a2->size <= a2->alloc)) || (_wassert(L"a2->size <= a2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); (void)( (!!(a2->size == 0 || a2->ptr != ((void*)0))) || (_wassert(L"a2->size == 0 || a2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(36)), 0) ); } while (0); if ((a2->size > 0)) { size_t newSize = a1->size + a2->size; if (newSize > a1->alloc) { testobj_t *ptr = (((newSize) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((a1->ptr), (newSize)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * newSize), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 36); abort(); } while (0); } a1->ptr = ptr; a1->alloc = newSize; } memcpy(&a1->ptr[a1->size], &a2->ptr[0], a2->size * sizeof (testobj_t)); a2->size = 0; a1->size = newSize; } }
# 36 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic pop
#pragma clang diagnostic push
# 37 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wunused-function"
# 37 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wformat-nonliteral"
# 37 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
 typedef struct array_min2_z_s { size_t size; size_t alloc; testobj_t *ptr; } array_min2_z_t[1]; typedef struct array_min2_z_it_s { size_t index; const struct array_min2_z_s *array; } array_min2_z_it_t[1]; typedef struct array_min2_z_s *array_min2_z_ptr; typedef const struct array_min2_z_s *array_min2_z_srcptr; typedef array_min2_z_t array_min2_z_ct; typedef array_min2_z_it_t array_min2_z_it_ct; typedef testobj_t array_min2_z_subtype_ct; static inline void array_min2_z_init(array_min2_z_t v) { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); v->size = 0; v->alloc = 0; v->ptr = ((void*)0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); } static inline void array_min2_z_clean(array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); for(size_t i = 0; i < v->size; i++) testobj_clear(v->ptr[i]); v->size = 0; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); } static inline void array_min2_z_clear(array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); array_min2_z_clean(v); free(v->ptr); v->alloc = 0; v->ptr = ((void*)0); } static inline void array_min2_z_init_move(array_min2_z_t d, array_min2_z_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); d->size = s->size; d->alloc = s->alloc; d->ptr = s->ptr; s->alloc = 0; s->ptr = ((void*)0); do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); } static inline void array_min2_z_move(array_min2_z_t d, array_min2_z_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); array_min2_z_clear(d); array_min2_z_init_move(d, s); } static inline testobj_t const * array_min2_z_back(array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); return (((union { testobj_t *ptr; testobj_t const *cptr; }){&v->ptr[v->size-1]}).cptr); } static inline testobj_t * array_min2_z_push_raw(array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); if ((v->size >= v->alloc)) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); return ((void*)0); } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); testobj_t *ret = &v->ptr[v->size]; v->size++; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); (void)( (!!(ret != ((void*)0))) || (_wassert(L"ret != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); return ret; } static inline testobj_t * array_min2_z_push_new(array_min2_z_t v) { testobj_t *data = array_min2_z_push_raw(v); if ((data == ((void*)0)) ) return ((void*)0); testobj_init(*data); return data; } static inline void array_min2_z_resize(array_min2_z_t v, size_t size) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); if (v->size > size) { for(size_t i = size ; i < v->size; i++) testobj_clear(v->ptr[i]); v->size = size; } else if (v->size < size) { if (size > v->alloc) { size_t alloc = size ; testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) testobj_init(v->ptr[i]); v->size = size; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); } static inline void array_min2_z_reserve(array_min2_z_t v, size_t alloc) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); if (v->size > alloc) { alloc = v->size; } if ((alloc == 0)) { free(v->ptr); v->size = v->alloc = 0; v->ptr = ((void*)0); } else { testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); } static inline testobj_t * array_min2_z_get_at(array_min2_z_t v, size_t idx) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); const size_t size = idx + 1; if (v->size <= size) { if ((size > v->alloc) ) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); return ((void*)0); } testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) testobj_init(v->ptr[i]); v->size = size; } (void)( (!!(idx < v->size)) || (_wassert(L"idx < v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); return &v->ptr[idx]; } static inline void array_min2_z_pop_until(array_min2_z_t v, array_min2_z_it_t pos) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); (void)( (!!(v == pos->array)) || (_wassert(L"v == pos->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); do { (void)( (!!((pos->index) < (v->size + 1))) || (_wassert(L"(pos->index) < (v->size + 1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); array_min2_z_resize(v, pos->index); } static inline _Bool array_min2_z_empty_p(const array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); return v->size == 0; } static inline size_t array_min2_z_size(const array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); return v->size; } static inline size_t array_min2_z_capacity(const array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); return v->alloc; } static inline void array_min2_z_insert_v(array_min2_z_t v, size_t i, size_t num) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); do { (void)( (!!((i) < (v->size+1))) || (_wassert(L"(i) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); size_t size = v->size + num; if ((size <= v->size)) { if (num == 0) return; do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * v->size), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); return ; } if (size > v->alloc) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); return ; } testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } memmove(&v->ptr[i+num], &v->ptr[i], sizeof(testobj_t)*(v->size - i) ); for(size_t k = i ; k < i+num; k++) testobj_init(v->ptr[k]); v->size = size; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); } static inline void array_min2_z_remove_v(array_min2_z_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); (void)( (!!(i < j && v->ptr != ((void*)0))) || (_wassert(L"i < j && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); do { (void)( (!!((j) < (v->size+1))) || (_wassert(L"(j) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); for(size_t k = i ; k < j; k++) testobj_clear(v->ptr[k]); memmove(&v->ptr[i], &v->ptr[j], sizeof(testobj_t)*(v->size - j) ); v->size -= (j-i); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); } static inline void array_min2_z_swap(array_min2_z_t v1, array_min2_z_t v2) { do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); size_t tmp = v1->size; v1->size = v2->size; v2->size = tmp; tmp = v1->alloc; v1->alloc = v2->alloc; v2->alloc = tmp; testobj_t *p = v1->ptr; v1->ptr = v2->ptr; v2->ptr = p; do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); } static inline testobj_t * array_min2_z_get(const array_min2_z_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); return &v->ptr[i]; } static inline testobj_t const * array_min2_z_cget(const array_min2_z_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); return (((union { testobj_t *ptr; testobj_t const *cptr; }){&v->ptr[i]}).cptr); } static inline testobj_t const * array_min2_z_front(const array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); return array_min2_z_cget(v, 0); } static inline void array_min2_z_it(array_min2_z_it_t it, const array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); it->index = 0; it->array = v; } static inline void array_min2_z_it_last(array_min2_z_it_t it, const array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); it->index = v->size - 1; it->array = v; } static inline void array_min2_z_it_end(array_min2_z_it_t it, const array_min2_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); it->index = v->size; it->array = v; } static inline void array_min2_z_it_set(array_min2_z_it_t it, const array_min2_z_it_t org) { (void)( (!!(it != ((void*)0) && org != ((void*)0))) || (_wassert(L"it != ((void*)0) && org != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); it->index = org->index; it->array = org->array; do { (void)( (!!(it->array != ((void*)0))) || (_wassert(L"it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(it->array->size <= it->array->alloc)) || (_wassert(L"it->array->size <= it->array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(it->array->size == 0 || it->array->ptr != ((void*)0))) || (_wassert(L"it->array->size == 0 || it->array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); } static inline _Bool array_min2_z_end_p(const array_min2_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); return it->index >= it->array->size; } static inline _Bool array_min2_z_last_p(const array_min2_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); return it->index + 1 >= it->array->size; } static inline _Bool array_min2_z_it_equal_p(const array_min2_z_it_t it1, const array_min2_z_it_t it2) { (void)( (!!(it1 != ((void*)0) && it2 != ((void*)0))) || (_wassert(L"it1 != ((void*)0) && it2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); return it1->array == it2->array && it1->index == it2->index; } static inline void array_min2_z_next(array_min2_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); it->index++; } static inline void array_min2_z_previous(array_min2_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); it->index--; } static inline testobj_t * array_min2_z_ref(const array_min2_z_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); return array_min2_z_get(it->array, it->index); } static inline testobj_t const * array_min2_z_cref(const array_min2_z_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); return array_min2_z_cget(it->array, it->index); } static inline void array_min2_z_splice(array_min2_z_t a1, array_min2_z_t a2) { do { (void)( (!!(a1 != ((void*)0))) || (_wassert(L"a1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(a1->size <= a1->alloc)) || (_wassert(L"a1->size <= a1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(a1->size == 0 || a1->ptr != ((void*)0))) || (_wassert(L"a1->size == 0 || a1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); do { (void)( (!!(a2 != ((void*)0))) || (_wassert(L"a2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(a2->size <= a2->alloc)) || (_wassert(L"a2->size <= a2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); (void)( (!!(a2->size == 0 || a2->ptr != ((void*)0))) || (_wassert(L"a2->size == 0 || a2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(37)), 0) ); } while (0); if ((a2->size > 0)) { size_t newSize = a1->size + a2->size; if (newSize > a1->alloc) { testobj_t *ptr = (((newSize) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((a1->ptr), (newSize)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * newSize), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 37); abort(); } while (0); } a1->ptr = ptr; a1->alloc = newSize; } memcpy(&a1->ptr[a1->size], &a2->ptr[0], a2->size * sizeof (testobj_t)); a2->size = 0; a1->size = newSize; } }
# 37 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic pop
#pragma clang diagnostic push
# 38 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wunused-function"
# 38 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wformat-nonliteral"
# 38 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
 typedef struct array_min3_z_s { size_t size; size_t alloc; testobj_t *ptr; } array_min3_z_t[1]; typedef struct array_min3_z_it_s { size_t index; const struct array_min3_z_s *array; } array_min3_z_it_t[1]; typedef struct array_min3_z_s *array_min3_z_ptr; typedef const struct array_min3_z_s *array_min3_z_srcptr; typedef array_min3_z_t array_min3_z_ct; typedef array_min3_z_it_t array_min3_z_it_ct; typedef testobj_t array_min3_z_subtype_ct; static inline void array_min3_z_init(array_min3_z_t v) { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); v->size = 0; v->alloc = 0; v->ptr = ((void*)0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); } static inline void array_min3_z_clean(array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); for(size_t i = 0; i < v->size; i++) testobj_clear(v->ptr[i]); v->size = 0; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); } static inline void array_min3_z_clear(array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); array_min3_z_clean(v); free(v->ptr); v->alloc = 0; v->ptr = ((void*)0); } static inline void array_min3_z_init_move(array_min3_z_t d, array_min3_z_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); d->size = s->size; d->alloc = s->alloc; d->ptr = s->ptr; s->alloc = 0; s->ptr = ((void*)0); do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); } static inline void array_min3_z_move(array_min3_z_t d, array_min3_z_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); array_min3_z_clear(d); array_min3_z_init_move(d, s); } static inline testobj_t const * array_min3_z_back(array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); return (((union { testobj_t *ptr; testobj_t const *cptr; }){&v->ptr[v->size-1]}).cptr); } static inline testobj_t * array_min3_z_push_raw(array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); if ((v->size >= v->alloc)) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 38); abort(); } while (0); return ((void*)0); } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 38); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); testobj_t *ret = &v->ptr[v->size]; v->size++; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); (void)( (!!(ret != ((void*)0))) || (_wassert(L"ret != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); return ret; } static inline void array_min3_z_reserve(array_min3_z_t v, size_t alloc) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); if (v->size > alloc) { alloc = v->size; } if ((alloc == 0)) { free(v->ptr); v->size = v->alloc = 0; v->ptr = ((void*)0); } else { testobj_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 38); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); } static inline _Bool array_min3_z_empty_p(const array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); return v->size == 0; } static inline size_t array_min3_z_size(const array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); return v->size; } static inline size_t array_min3_z_capacity(const array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); return v->alloc; } static inline void array_min3_z_remove_v(array_min3_z_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); (void)( (!!(i < j && v->ptr != ((void*)0))) || (_wassert(L"i < j && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); do { (void)( (!!((j) < (v->size+1))) || (_wassert(L"(j) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); for(size_t k = i ; k < j; k++) testobj_clear(v->ptr[k]); memmove(&v->ptr[i], &v->ptr[j], sizeof(testobj_t)*(v->size - j) ); v->size -= (j-i); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); } static inline void array_min3_z_swap(array_min3_z_t v1, array_min3_z_t v2) { do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); size_t tmp = v1->size; v1->size = v2->size; v2->size = tmp; tmp = v1->alloc; v1->alloc = v2->alloc; v2->alloc = tmp; testobj_t *p = v1->ptr; v1->ptr = v2->ptr; v2->ptr = p; do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); } static inline testobj_t * array_min3_z_get(const array_min3_z_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); return &v->ptr[i]; } static inline testobj_t const * array_min3_z_cget(const array_min3_z_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); return (((union { testobj_t *ptr; testobj_t const *cptr; }){&v->ptr[i]}).cptr); } static inline testobj_t const * array_min3_z_front(const array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); return array_min3_z_cget(v, 0); } static inline void array_min3_z_it(array_min3_z_it_t it, const array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); it->index = 0; it->array = v; } static inline void array_min3_z_it_last(array_min3_z_it_t it, const array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); it->index = v->size - 1; it->array = v; } static inline void array_min3_z_it_end(array_min3_z_it_t it, const array_min3_z_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); it->index = v->size; it->array = v; } static inline void array_min3_z_it_set(array_min3_z_it_t it, const array_min3_z_it_t org) { (void)( (!!(it != ((void*)0) && org != ((void*)0))) || (_wassert(L"it != ((void*)0) && org != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); it->index = org->index; it->array = org->array; do { (void)( (!!(it->array != ((void*)0))) || (_wassert(L"it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(it->array->size <= it->array->alloc)) || (_wassert(L"it->array->size <= it->array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(it->array->size == 0 || it->array->ptr != ((void*)0))) || (_wassert(L"it->array->size == 0 || it->array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); } static inline _Bool array_min3_z_end_p(const array_min3_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); return it->index >= it->array->size; } static inline _Bool array_min3_z_last_p(const array_min3_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); return it->index + 1 >= it->array->size; } static inline _Bool array_min3_z_it_equal_p(const array_min3_z_it_t it1, const array_min3_z_it_t it2) { (void)( (!!(it1 != ((void*)0) && it2 != ((void*)0))) || (_wassert(L"it1 != ((void*)0) && it2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); return it1->array == it2->array && it1->index == it2->index; } static inline void array_min3_z_next(array_min3_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); it->index++; } static inline void array_min3_z_previous(array_min3_z_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); it->index--; } static inline testobj_t * array_min3_z_ref(const array_min3_z_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); return array_min3_z_get(it->array, it->index); } static inline testobj_t const * array_min3_z_cref(const array_min3_z_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); return array_min3_z_cget(it->array, it->index); } static inline void array_min3_z_splice(array_min3_z_t a1, array_min3_z_t a2) { do { (void)( (!!(a1 != ((void*)0))) || (_wassert(L"a1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(a1->size <= a1->alloc)) || (_wassert(L"a1->size <= a1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(a1->size == 0 || a1->ptr != ((void*)0))) || (_wassert(L"a1->size == 0 || a1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); do { (void)( (!!(a2 != ((void*)0))) || (_wassert(L"a2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(a2->size <= a2->alloc)) || (_wassert(L"a2->size <= a2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); (void)( (!!(a2->size == 0 || a2->ptr != ((void*)0))) || (_wassert(L"a2->size == 0 || a2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(38)), 0) ); } while (0); if ((a2->size > 0)) { size_t newSize = a1->size + a2->size; if (newSize > a1->alloc) { testobj_t *ptr = (((newSize) > 0xffffffffffffffffui64 / sizeof(testobj_t)) ? ((void*)0) : realloc ((a1->ptr), (newSize)*sizeof (testobj_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (testobj_t) * newSize), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 38); abort(); } while (0); } a1->ptr = ptr; a1->alloc = newSize; } memcpy(&a1->ptr[a1->size], &a2->ptr[0], a2->size * sizeof (testobj_t)); a2->size = 0; a1->size = newSize; } }
# 38 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic pop

#pragma clang diagnostic push
# 40 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wunused-function"
# 40 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wformat-nonliteral"
# 40 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
 typedef struct array_ulong_s { size_t size; size_t alloc; uint64_t *ptr; } array_ulong_t[1]; typedef struct array_ulong_it_s { size_t index; const struct array_ulong_s *array; } array_ulong_it_t[1]; typedef struct array_ulong_s *array_ulong_ptr; typedef const struct array_ulong_s *array_ulong_srcptr; typedef array_ulong_t array_ulong_ct; typedef array_ulong_it_t array_ulong_it_ct; typedef uint64_t array_ulong_subtype_ct; static inline void array_ulong_init(array_ulong_t v) { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); v->size = 0; v->alloc = 0; v->ptr = ((void*)0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_clean(array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); for(size_t i = 0; i < v->size; i++) ((void)(v->ptr[i])); v->size = 0; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_clear(array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); array_ulong_clean(v); free(v->ptr); v->alloc = 0; v->ptr = ((void*)0); } static inline void array_ulong_set(array_ulong_t d, const array_ulong_t s) { do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); if ((d == s)) return; if (s->size > d->alloc) { const size_t alloc = s->size; uint64_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(uint64_t)) ? ((void*)0) : realloc ((d->ptr), (alloc)*sizeof (uint64_t))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return ; } d->ptr = ptr; d->alloc = alloc; } size_t i; size_t step1 = ((s->size) < (d->size) ? (s->size) : (d->size)); for(i = 0; i < step1; i++) (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (d->ptr[i]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (d->ptr[i]) = (s->ptr[i])); for( ; i < s->size; i++) (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (d->ptr[i]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (d->ptr[i]) = (s->ptr[i])); for( ; i < d->size; i++) ((void)(d->ptr[i])); d->size = s->size; do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_init_set(array_ulong_t d, const array_ulong_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); array_ulong_init(d); array_ulong_set(d, s); } static inline void array_ulong_init_move(array_ulong_t d, array_ulong_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); d->size = s->size; d->alloc = s->alloc; d->ptr = s->ptr; s->alloc = 0; s->ptr = ((void*)0); do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_move(array_ulong_t d, array_ulong_t s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); array_ulong_clear(d); array_ulong_init_move(d, s); } static inline void array_ulong_set_at(array_ulong_t v, size_t i, uint64_t const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (v->ptr[i]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (v->ptr[i]) = (x)); } static inline uint64_t const * array_ulong_back(array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return (((union { uint64_t *ptr; uint64_t const *cptr; }){&v->ptr[v->size-1]}).cptr); } static inline uint64_t * array_ulong_push_raw(array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); if ((v->size >= v->alloc)) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return ((void*)0); } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); uint64_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(uint64_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (uint64_t))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); uint64_t *ret = &v->ptr[v->size]; v->size++; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(ret != ((void*)0))) || (_wassert(L"ret != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); return ret; } static inline void array_ulong_push_back(array_ulong_t v, uint64_t const x) { uint64_t *data = array_ulong_push_raw(v); if ((data == ((void*)0)) ) return; (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (*data) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (*data) = (x)); } static inline uint64_t * array_ulong_push_new(array_ulong_t v) { uint64_t *data = array_ulong_push_raw(v); if ((data == ((void*)0)) ) return ((void*)0); ((*data) = 0); return data; } static inline void array_ulong_push_move(array_ulong_t v, uint64_t *x) { (void)( (!!(x != ((void*)0))) || (_wassert(L"x != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); uint64_t *data = array_ulong_push_raw(v); if ((data == ((void*)0)) ) return; do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*data)) == sizeof((*x)));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*data)) == sizeof((*x)));})), memcpy(&((*data)), &((*x)), sizeof ((*data)))), memset(&((*x)), 0, sizeof ((*data)))); } while (0); } static inline void array_ulong_push_at(array_ulong_t v, size_t key, uint64_t const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!((key) < (v->size+1))) || (_wassert(L"(key) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); if ((v->size >= v->alloc) ) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return; } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); uint64_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(uint64_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (uint64_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); memmove(&v->ptr[key+1], &v->ptr[key], (v->size-key)*sizeof(uint64_t)); v->size++; (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (v->ptr[key]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (v->ptr[key]) = (x)); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_resize(array_ulong_t v, size_t size) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); if (v->size > size) { for(size_t i = size ; i < v->size; i++) ((void)(v->ptr[i])); v->size = size; } else if (v->size < size) { if (size > v->alloc) { size_t alloc = size ; uint64_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(uint64_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (uint64_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) ((v->ptr[i]) = 0); v->size = size; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_reserve(array_ulong_t v, size_t alloc) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); if (v->size > alloc) { alloc = v->size; } if ((alloc == 0)) { free(v->ptr); v->size = v->alloc = 0; v->ptr = ((void*)0); } else { uint64_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(uint64_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (uint64_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline uint64_t * array_ulong_get_at(array_ulong_t v, size_t idx) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); const size_t size = idx + 1; if (v->size <= size) { if ((size > v->alloc) ) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return ((void*)0); } uint64_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(uint64_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (uint64_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) ((v->ptr[i]) = 0); v->size = size; } (void)( (!!(idx < v->size)) || (_wassert(L"idx < v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return &v->ptr[idx]; } static inline void array_ulong_pop_back(uint64_t *dest, array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); v->size--; if (dest) { do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), memcpy(&((*dest)), &((v->ptr[v->size])), sizeof ((*dest)))), memset(&((v->ptr[v->size])), 0, sizeof ((*dest)))); } while (0); } else { ((void)(v->ptr[v->size])); } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_pop_move(uint64_t *dest, array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(dest != ((void*)0))) || (_wassert(L"dest != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); v->size--; do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), memcpy(&((*dest)), &((v->ptr[v->size])), sizeof ((*dest)))), memset(&((v->ptr[v->size])), 0, sizeof ((*dest)))); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_pop_until(array_ulong_t v, array_ulong_it_t pos) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(v == pos->array)) || (_wassert(L"v == pos->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((pos->index) < (v->size + 1))) || (_wassert(L"(pos->index) < (v->size + 1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); array_ulong_resize(v, pos->index); } static inline _Bool array_ulong_empty_p(const array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return v->size == 0; } static inline size_t array_ulong_size(const array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return v->size; } static inline size_t array_ulong_capacity(const array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return v->alloc; } static inline void array_ulong_pop_at(uint64_t *dest, array_ulong_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); if (dest) do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[i])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[i])));})), memcpy(&((*dest)), &((v->ptr[i])), sizeof ((*dest)))), memset(&((v->ptr[i])), 0, sizeof ((*dest)))); } while (0); else ((void)(v->ptr[i])); memmove(&v->ptr[i], &v->ptr[i+1], sizeof(uint64_t)*(v->size - i) ); v->size--; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline _Bool array_ulong_erase(array_ulong_t a, size_t i) { do { (void)( (!!(a != ((void*)0))) || (_wassert(L"a != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(a->size <= a->alloc)) || (_wassert(L"a->size <= a->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(a->size == 0 || a->ptr != ((void*)0))) || (_wassert(L"a->size == 0 || a->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); if (i >= a->size) return 0; array_ulong_pop_at(((void*)0), a, i); return 1; } static inline void array_ulong_insert_v(array_ulong_t v, size_t i, size_t num) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!((i) < (v->size+1))) || (_wassert(L"(i) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); size_t size = v->size + num; if ((size <= v->size)) { if (num == 0) return; do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * v->size), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return ; } if (size > v->alloc) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return ; } uint64_t *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(uint64_t)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (uint64_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } memmove(&v->ptr[i+num], &v->ptr[i], sizeof(uint64_t)*(v->size - i) ); for(size_t k = i ; k < i+num; k++) ((v->ptr[k]) = 0); v->size = size; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_remove_v(array_ulong_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(i < j && v->ptr != ((void*)0))) || (_wassert(L"i < j && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!((j) < (v->size+1))) || (_wassert(L"(j) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); for(size_t k = i ; k < j; k++) ((void)(v->ptr[k])); memmove(&v->ptr[i], &v->ptr[j], sizeof(uint64_t)*(v->size - j) ); v->size -= (j-i); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_swap(array_ulong_t v1, array_ulong_t v2) { do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); size_t tmp = v1->size; v1->size = v2->size; v2->size = tmp; tmp = v1->alloc; v1->alloc = v2->alloc; v2->alloc = tmp; uint64_t *p = v1->ptr; v1->ptr = v2->ptr; v2->ptr = p; do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline void array_ulong_swap_at(array_ulong_t v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!((j) < (v->size))) || (_wassert(L"(j) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); uint64_t tmp; do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((tmp)) == sizeof((v->ptr[i])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((tmp)) == sizeof((v->ptr[i])));})), memcpy(&((tmp)), &((v->ptr[i])), sizeof ((tmp)))), memset(&((v->ptr[i])), 0, sizeof ((tmp)))); } while (0); do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[i])) == sizeof((v->ptr[j])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[i])) == sizeof((v->ptr[j])));})), memcpy(&((v->ptr[i])), &((v->ptr[j])), sizeof ((v->ptr[i])))), memset(&((v->ptr[j])), 0, sizeof ((v->ptr[i])))); } while (0); do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[j])) == sizeof((tmp)));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[j])) == sizeof((tmp)));})), memcpy(&((v->ptr[j])), &((tmp)), sizeof ((v->ptr[j])))), memset(&((tmp)), 0, sizeof ((v->ptr[j])))); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline uint64_t * array_ulong_get(const array_ulong_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return &v->ptr[i]; } static inline uint64_t const * array_ulong_cget(const array_ulong_t v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return (((union { uint64_t *ptr; uint64_t const *cptr; }){&v->ptr[i]}).cptr); } static inline uint64_t const * array_ulong_front(const array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return array_ulong_cget(v, 0); } static inline void array_ulong_it(array_ulong_it_t it, const array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); it->index = 0; it->array = v; } static inline void array_ulong_it_last(array_ulong_it_t it, const array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); it->index = v->size - 1; it->array = v; } static inline void array_ulong_it_end(array_ulong_it_t it, const array_ulong_t v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); it->index = v->size; it->array = v; } static inline void array_ulong_it_set(array_ulong_it_t it, const array_ulong_it_t org) { (void)( (!!(it != ((void*)0) && org != ((void*)0))) || (_wassert(L"it != ((void*)0) && org != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); it->index = org->index; it->array = org->array; do { (void)( (!!(it->array != ((void*)0))) || (_wassert(L"it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(it->array->size <= it->array->alloc)) || (_wassert(L"it->array->size <= it->array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(it->array->size == 0 || it->array->ptr != ((void*)0))) || (_wassert(L"it->array->size == 0 || it->array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); } static inline _Bool array_ulong_end_p(const array_ulong_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); return it->index >= it->array->size; } static inline _Bool array_ulong_last_p(const array_ulong_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); return it->index + 1 >= it->array->size; } static inline _Bool array_ulong_it_equal_p(const array_ulong_it_t it1, const array_ulong_it_t it2) { (void)( (!!(it1 != ((void*)0) && it2 != ((void*)0))) || (_wassert(L"it1 != ((void*)0) && it2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); return it1->array == it2->array && it1->index == it2->index; } static inline void array_ulong_next(array_ulong_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); it->index++; } static inline void array_ulong_previous(array_ulong_it_t it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); it->index--; } static inline uint64_t * array_ulong_ref(const array_ulong_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); return array_ulong_get(it->array, it->index); } static inline uint64_t const * array_ulong_cref(const array_ulong_it_t it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); return array_ulong_cget(it->array, it->index); } static inline void array_ulong_insert(array_ulong_t a, array_ulong_it_t it, uint64_t const x) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); array_ulong_push_at(a, it->index + 1, x); it->index++; } static inline void array_ulong_remove(array_ulong_t a, array_ulong_it_t it) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); array_ulong_pop_at(((void*)0), a, it->index); } static inline void array_ulong_special_sort(array_ulong_t l, int (*func_type) (uint64_t const *a, uint64_t const *b)) { int (*func_void)(const void*, const void*); func_void = (int (*)(const void*, const void*))func_type; qsort(l->ptr, l->size, sizeof(uint64_t), func_void); } static inline void array_ulong_special_stable_sort_noalloc (uint64_t tab[], size_t size, uint64_t tmp[]) { size_t th = 4; uint64_t *org_tab = tab; (void)( (!!(size > 1)) || (_wassert(L"size > 1", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); if (m_core_clz64(size-1) & 1) th += th; for(size_t k = 0 ; k < size; ) { size_t max = size - k < 2*th ? size - k : th; (void)( (!!(max >= th)) || (_wassert(L"max >= th", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); for(size_t i = 1; i < max; i++) { size_t j = i; while (j > 0 && ((tab[k+j-1]) < (tab[k+j]) ? -1 : (tab[k+j-1]) > (tab[k+j])) > 0) { do { char _tmp[sizeof (tab[k+j-1])]; ((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof(tab[k+j-1]) == sizeof(tab[k+j]));})); memcpy(&_tmp, &(tab[k+j-1]), sizeof (tab[k+j-1])); memcpy(&(tab[k+j-1]), &(tab[k+j]), sizeof (tab[k+j-1])); memcpy(&(tab[k+j]), &_tmp, sizeof (tab[k+j-1])); } while (0); j = j - 1; } } k += max; } while (th < size) { uint64_t *dest = tmp; for(size_t k = 0 ; k < size; ) { uint64_t *el1 = &tab[k]; uint64_t *el2 = &tab[k+th]; size_t n1 = th; size_t n2 = size-k <= 3*th ? size-k-th : th; (void)( (!!(size-k > th)) || (_wassert(L"size-k > th", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(0 < n1 && n1 <= size)) || (_wassert(L"0 < n1 && n1 <= size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(0 < n2 && n2 <= size)) || (_wassert(L"0 < n2 && n2 <= size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); k += n1+n2; for (;;) { if (((*el1) < (*el2) ? -1 : (*el1) > (*el2)) <= 0) { (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (*dest) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (*dest) = (*el1)); dest++; el1++; if (-- n1 == 0) { if (n2 > 0) { memcpy(dest, el2, n2 * sizeof (uint64_t)); dest += n2; } break; } } else { (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (*dest) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (*dest) = (*el2)); dest++; el2++; if (-- n2 == 0) { if (n1 > 0) { memcpy (dest, el1, n1 * sizeof (uint64_t)); dest += n1; } break; } } } } do { uint64_t * _tmp = (tab); (tab) = (tmp); (tmp) = _tmp; } while (0); th += th; } (void)( (!!(org_tab == tab)) || (_wassert(L"org_tab == tab", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } static inline void array_ulong_special_stable_sort(array_ulong_t l) { if ((l->size < 2)) return; uint64_t *temp = (((l->size) > 0xffffffffffffffffui64 / sizeof(uint64_t)) ? ((void*)0) : realloc ((((void*)0)), (l->size)*sizeof (uint64_t))); if (temp == ((void*)0)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * l->size), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); return; } array_ulong_special_stable_sort_noalloc(l->ptr, l->size, temp); free(temp); } static inline void array_ulong_get_str(string_t str, array_ulong_t const array, _Bool append) { do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while(0); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (append ? string_cat_cstr : string_set_cstr) (str, "["); array_ulong_it_t it; for (array_ulong_it(it, array); !array_ulong_end_p(it); array_ulong_next(it)){ uint64_t const *item = array_ulong_cref(it); (1 ? string_cat_printf : string_printf) (str, _Generic(((void)0,(*item)), char: "%c", _Bool: "%d", signed char: "%hhd", unsigned char: "%hhu", signed short: "%hd", unsigned short: "%hu", signed int: "%d", unsigned int: "%u", long int: "%ld", unsigned long int: "%lu", long long int: "%lld", unsigned long long int: "%llu", float: "%f", double: "%f", long double: "%Lf", const char *: "%s", char *: "%s", const void *: "%p", void *: "%p"), *item); if (!array_ulong_last_p(it)) string_push_back (str, ','); } string_push_back (str, ']'); do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while(0); } static inline void array_ulong_out_str(FILE *file, const array_ulong_t array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(file != ((void*)0))) || (_wassert(L"file != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); fputc ('[', file); for (size_t i = 0; i < array->size; i++) { uint64_t const *item = array_ulong_cget(array, i); fprintf(file, _Generic(((void)0,(*item)), char: "%c", _Bool: "%d", signed char: "%hhd", unsigned char: "%hhu", signed short: "%hd", unsigned short: "%hu", signed int: "%d", unsigned int: "%u", long int: "%ld", unsigned long int: "%lu", long long int: "%lld", unsigned long long int: "%llu", float: "%f", double: "%f", long double: "%Lf", const char *: "%s", char *: "%s", const void *: "%p", void *: "%p"), *item); if (i != array->size-1) fputc (',', file); } fputc (']', file); } static inline _Bool array_ulong_parse_str(array_ulong_t array, const char str[], const char**endp) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); array_ulong_clean(array); _Bool success = 0; int c = *str++; if ((c != '[')) goto exit; c = *str++; if ((c == ']')) { success = 1; goto exit; } if ((c == 0)) goto exit; str--; uint64_t item; ((item) = 0); do { _Bool b = _Generic(((void)0,*(& item)), char: m_core_parse_char(_Generic(((void)0,(& item)), char*: (& item), default: (char*) 0),str,&str), _Bool: m_core_parse_bool(_Generic(((void)0,(& item)), _Bool*: (& item), default: (_Bool*) 0),str,&str), signed char: m_core_parse_schar(_Generic(((void)0,(& item)), signed char*: (& item), default: (signed char*) 0),str,&str), unsigned char: m_core_parse_uchar(_Generic(((void)0,(& item)), unsigned char*: (& item), default: (unsigned char*) 0),str,&str), signed short: m_core_parse_sshort(_Generic(((void)0,(& item)), signed short*: (& item), default: (signed short*) 0),str,&str), unsigned short: m_core_parse_ushort(_Generic(((void)0,(& item)), unsigned short*: (& item), default: (unsigned short*) 0),str,&str), signed int: m_core_parse_sint(_Generic(((void)0,(& item)), signed int*: (& item), default: (signed int*) 0),str,&str), unsigned int: m_core_parse_uint(_Generic(((void)0,(& item)), unsigned int*: (& item), default: (unsigned int*) 0),str,&str), signed long: m_core_parse_slong(_Generic(((void)0,(& item)), signed long *: (& item), default: (signed long *) 0),str,&str), unsigned long: m_core_parse_ulong(_Generic(((void)0,(& item)), unsigned long*: (& item), default: (unsigned long*) 0),str,&str), signed long long: m_core_parse_sllong(_Generic(((void)0,(& item)), signed long long*: (& item), default: (signed long long*) 0),str,&str), unsigned long long: m_core_parse_ullong(_Generic(((void)0,(& item)), unsigned long long*: (& item), default: (unsigned long long*) 0),str,&str), float: m_core_parse_float(_Generic(((void)0,(& item)), float*: (& item), default: (float*) 0),str,&str), double: m_core_parse_double(_Generic(((void)0,(& item)), double*: (& item), default: (double*) 0),str,&str), long double: m_core_parse_ldouble(_Generic(((void)0,(& item)), long double*: (& item), default: (long double*) 0),str,&str), const char *: 0 , char *: 0 , const void *: 0 , void *: 0 ); do { c = *str++; } while (isspace(c)); if (b == 0 || c == 0) { goto exit_clear; } array_ulong_push_back(array, item); } while (c == ','); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); success = (c == ']'); exit_clear: ((void)(item)); exit: if (endp) *endp = str; return success; } static inline _Bool array_ulong_in_str(array_ulong_t array, FILE *file) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(file != ((void*)0))) || (_wassert(L"file != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); array_ulong_clean(array); int c = fgetc(file); if ((c != '[')) return 0; c = fgetc(file); if ((c == ']')) return 1; if ((c == (-1))) return 0; ungetc(c, file); uint64_t item; ((item) = 0); do { _Bool b = _Generic(((void)0,*(& item)), _Bool: m_core_fscan_bool(_Generic(((void)0,(& item)), _Bool*: (& item), default: (_Bool*) 0), file), char: m_core_fscan_char(_Generic(((void)0,(& item)), char*: (& item), default: (char*) 0), file), signed char: m_core_fscan_schar(_Generic(((void)0,(& item)), signed char*: (& item), default: (signed char*) 0),file), unsigned char: m_core_fscan_uchar(_Generic(((void)0,(& item)), unsigned char*: (& item), default: (unsigned char*) 0),file), signed short: m_core_fscan_sshort(_Generic(((void)0,(& item)), signed short*: (& item), default: (signed short*) 0),file), unsigned short: m_core_fscan_ushort(_Generic(((void)0,(& item)), unsigned short*: (& item), default: (unsigned short*) 0), file), signed int: m_core_fscan_sint(_Generic(((void)0,(& item)), signed int*: (& item), default: (signed int*) 0), file), unsigned int: m_core_fscan_uint(_Generic(((void)0,(& item)), unsigned int*: (& item), default: (unsigned int*) 0), file), long int: m_core_fscan_slong(_Generic(((void)0,(& item)), long*: (& item), default: (long*) 0), file), unsigned long int: m_core_fscan_ulong(_Generic(((void)0,(& item)), unsigned long*: (& item), default: (unsigned long*) 0), file), long long int: m_core_fscan_sllong(_Generic(((void)0,(& item)), long long*: (& item), default: (long long*) 0), file), unsigned long long int: m_core_fscan_ullong(_Generic(((void)0,(& item)), unsigned long long*: (& item), default: (unsigned long long*) 0),file), float: m_core_fscan_float(_Generic(((void)0,(& item)), float*: (& item), default: (float*) 0), file), double: m_core_fscan_double(_Generic(((void)0,(& item)), double*: (& item), default: (double*) 0), file), long double: m_core_fscan_ldouble(_Generic(((void)0,(& item)), long double*: (& item), default: (long double*) 0),file), const char *: 0 , char *: 0 , const void *: 0 , void *: 0 ); do { c = fgetc(file); } while (isspace(c)); if (b == 0 || c == (-1)) { break; } array_ulong_push_back(array, item); } while (c == ','); ((void)(item)); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return c == ']'; } static inline m_serial_return_code_t array_ulong_out_serial(m_serial_write_t f, const array_ulong_t array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(f != ((void*)0) && f->m_interface != ((void*)0))) || (_wassert(L"f != ((void*)0) && f->m_interface != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); m_serial_return_code_t ret; m_serial_local_t local; ret = f->m_interface->write_array_start(local, f, array->size); for (size_t i = 0; i < array->size; i++) { uint64_t const *item = array_ulong_cget(array, i); if (i != 0) { ret |= f->m_interface->write_array_next(local, f); } ret |= _Generic(((void)0,(*item)), _Bool: (f)->m_interface->write_boolean (f, _Generic(((void)0,((*item))), _Bool: ((*item)), default: (_Bool) 0)), char: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), char: ((*item)), default: (char) 0), sizeof (*item)), signed char: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), signed char: ((*item)), default: (signed char) 0), sizeof (*item)), unsigned char: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned char: ((*item)), default: (unsigned char) 0), sizeof (*item)), signed short: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), signed short: ((*item)), default: (signed short) 0), sizeof (*item)), unsigned short: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned short: ((*item)), default: (unsigned short) 0), sizeof (*item)), signed int: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), signed int: ((*item)), default: (signed int) 0), sizeof (*item)), unsigned int: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned int: ((*item)), default: (unsigned int) 0), sizeof (*item)), long int: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), long: ((*item)), default: (long) 0), sizeof (*item)), unsigned long int: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned long: ((*item)), default: (unsigned long) 0), sizeof (*item)), long long int: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), long long: ((*item)), default: (long long) 0), sizeof (*item)), unsigned long long int: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned long long: ((*item)), default: (unsigned long long) 0), sizeof (*item)), float: (f)->m_interface->write_float (f, _Generic(((void)0,((*item))), float: ((*item)), default: (float) 0), sizeof (*item)), double: (f)->m_interface->write_float (f, _Generic(((void)0,((*item))), double: ((*item)), default: (double) 0), sizeof (*item)), long double: (f)->m_interface->write_float (f, _Generic(((void)0,((*item))), long double: ((*item)), default: (long double) 0), sizeof (*item)), const char *: (f)->m_interface->write_string (f, _Generic(((void)0,((*item))), const char *: ((*item)), default: (const char *) 0), m_core_out_serial_strlen(_Generic(((void)0,((*item))), const char *: ((*item)), default: (const char *) 0)) ), char *: (f)->m_interface->write_string (f, _Generic(((void)0,((*item))), char *: ((*item)), default: (char *) 0), m_core_out_serial_strlen(_Generic(((void)0,((*item))), const char *: ((*item)), default: (const char *) 0)) ), const void *: M_SERIAL_FAIL , void *: M_SERIAL_FAIL ); } ret |= f->m_interface->write_array_end(local, f); return ret & M_SERIAL_FAIL; } static inline m_serial_return_code_t array_ulong_in_serial(array_ulong_t array, m_serial_read_t f) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); (void)( (!!(f != ((void*)0) && f->m_interface != ((void*)0))) || (_wassert(L"f != ((void*)0) && f->m_interface != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); m_serial_return_code_t ret; m_serial_local_t local; size_t estimated_size = 0; array_ulong_clean(array); ret = f->m_interface->read_array_start(local, f, &estimated_size); if ((ret != M_SERIAL_OK_CONTINUE)) { return ret; } if (estimated_size != 0) { array_ulong_reserve(array, estimated_size); } uint64_t item; ((item) = 0); do { ret = _Generic(((void)0,*(& item)), _Bool: (f)->m_interface->read_boolean (f, _Generic(((void)0,(& item)), _Bool *: (& item), default: (_Bool *) 0)), char: m_core_in_serial_char(f, _Generic(((void)0,(& item)), char*: (& item), default: (char*) 0)), signed char: m_core_in_serial_schar (f, _Generic(((void)0,(& item)), signed char*: (& item), default: (signed char*) 0)), unsigned char: m_core_in_serial_uchar (f, _Generic(((void)0,(& item)), unsigned char*: (& item), default: (unsigned char*) 0)), signed short: m_core_in_serial_sshort (f, _Generic(((void)0,(& item)), signed short*: (& item), default: (signed short*) 0)), unsigned short: m_core_in_serial_ushort (f, _Generic(((void)0,(& item)), unsigned short*: (& item), default: (unsigned short*) 0)), signed int: m_core_in_serial_sint (f, _Generic(((void)0,(& item)), signed int*: (& item), default: (signed int*) 0)), unsigned int: m_core_in_serial_uint (f, _Generic(((void)0,(& item)), unsigned int*: (& item), default: (unsigned int*) 0)), long int: m_core_in_serial_slong(f, _Generic(((void)0,(& item)), long*: (& item), default: (long*) 0)), unsigned long int: m_core_in_serial_ulong (f, _Generic(((void)0,(& item)), unsigned long*: (& item), default: (unsigned long*) 0)), long long int: m_core_in_serial_sllong (f, _Generic(((void)0,(& item)), long long*: (& item), default: (long long*) 0)), unsigned long long int: m_core_in_serial_ullong (f, _Generic(((void)0,(& item)), unsigned long long*: (& item), default: (unsigned long long*) 0)), float: m_core_in_serial_float(f, _Generic(((void)0,(& item)), float*: (& item), default: (float*) 0)), double: m_core_in_serial_double(f, _Generic(((void)0,(& item)), double*: (& item), default: (double*) 0)), long double: m_core_in_serial_ldouble (f, _Generic(((void)0,(& item)), long double*: (& item), default: (long double*) 0)), const char *: M_SERIAL_FAIL , char *: M_SERIAL_FAIL , const void *: M_SERIAL_FAIL , void *: M_SERIAL_FAIL ); if (ret != M_SERIAL_OK_DONE) { break; } array_ulong_push_back(array, item); ret = f->m_interface->read_array_next(local, f); } while (ret == M_SERIAL_OK_CONTINUE); ((void)(item)); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); return ret; } static inline _Bool array_ulong_equal_p(const array_ulong_t array1, const array_ulong_t array2) { do { (void)( (!!(array1 != ((void*)0))) || (_wassert(L"array1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array1->size <= array1->alloc)) || (_wassert(L"array1->size <= array1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array1->size == 0 || array1->ptr != ((void*)0))) || (_wassert(L"array1->size == 0 || array1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!(array2 != ((void*)0))) || (_wassert(L"array2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array2->size <= array2->alloc)) || (_wassert(L"array2->size <= array2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array2->size == 0 || array2->ptr != ((void*)0))) || (_wassert(L"array2->size == 0 || array2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); if (array1->size != array2->size) return 0; size_t i; for(i = 0; i < array1->size; i++) { uint64_t const *item1 = array_ulong_cget(array1, i); uint64_t const *item2 = array_ulong_cget(array2, i); _Bool b = ((*item1) == (*item2)); if (!b) return 0; } return i == array1->size; } static inline size_t array_ulong_hash(const array_ulong_t array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); size_t hash = 0UL ^ 0UL; for(size_t i = 0 ; i < array->size; i++) { size_t hi = (size_t) _Generic((array->ptr[i])+0, int32_t: ( ((uint32_t) _Generic(((void)0,(array->ptr[i])), int32_t: (array->ptr[i]), default: (int32_t) 0)) ^ (((uint32_t) _Generic(((void)0,(array->ptr[i])), int32_t: (array->ptr[i]), default: (int32_t) 0)) << 11) ^ 0UL ), uint32_t: ( (_Generic(((void)0,(array->ptr[i])), uint32_t: (array->ptr[i]), default: (uint32_t) 0)) ^ ((_Generic(((void)0,(array->ptr[i])), uint32_t: (array->ptr[i]), default: (uint32_t) 0)) << 11) ^ 0UL ), int64_t: ( ( ((uint64_t) _Generic(((void)0,(array->ptr[i])), int64_t: (array->ptr[i]), default: (int64_t) 0)) >> 33 ) ^ ((uint64_t) _Generic(((void)0,(array->ptr[i])), int64_t: (array->ptr[i]), default: (int64_t) 0)) ^ (((uint64_t) _Generic(((void)0,(array->ptr[i])), int64_t: (array->ptr[i]), default: (int64_t) 0)) << 11) ^ 0UL ), uint64_t: ( ( (_Generic(((void)0,(array->ptr[i])), uint64_t: (array->ptr[i]), default: (uint64_t) 0)) >> 33 ) ^ (_Generic(((void)0,(array->ptr[i])), uint64_t: (array->ptr[i]), default: (uint64_t) 0)) ^ ((_Generic(((void)0,(array->ptr[i])), uint64_t: (array->ptr[i]), default: (uint64_t) 0)) << 11) ^ 0UL ), default: m_core_hash((const void*) &(array->ptr[i]), sizeof (array->ptr[i])) ); do { hash = (size_t) (((hash) * 0x811C9DC5UL) ^ ((hi))); } while (0); } return ( (hash) >> (sizeof(size_t)*8/2) | (hash) ); } static inline void array_ulong_splice(array_ulong_t a1, array_ulong_t a2) { do { (void)( (!!(a1 != ((void*)0))) || (_wassert(L"a1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(a1->size <= a1->alloc)) || (_wassert(L"a1->size <= a1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(a1->size == 0 || a1->ptr != ((void*)0))) || (_wassert(L"a1->size == 0 || a1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); do { (void)( (!!(a2 != ((void*)0))) || (_wassert(L"a2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(a2->size <= a2->alloc)) || (_wassert(L"a2->size <= a2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); (void)( (!!(a2->size == 0 || a2->ptr != ((void*)0))) || (_wassert(L"a2->size == 0 || a2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(40)), 0) ); } while (0); if ((a2->size > 0)) { size_t newSize = a1->size + a2->size; if (newSize > a1->alloc) { uint64_t *ptr = (((newSize) > 0xffffffffffffffffui64 / sizeof(uint64_t)) ? ((void*)0) : realloc ((a1->ptr), (newSize)*sizeof (uint64_t))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (uint64_t) * newSize), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 40); abort(); } while (0); } a1->ptr = ptr; a1->alloc = newSize; } memcpy(&a1->ptr[a1->size], &a2->ptr[0], a2->size * sizeof (uint64_t)); a2->size = 0; a1->size = newSize; } }
# 40 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic pop

#pragma clang diagnostic push
# 42 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wunused-function"
# 42 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic ignored "-Wformat-nonliteral"
# 42 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
 typedef struct array_double_s { size_t size; size_t alloc; double *ptr; } ArrayDouble[1]; typedef struct array_double_it_s { size_t index; const struct array_double_s *array; } ArrayDoubleIt[1]; typedef struct array_double_s *array_double_ptr; typedef const struct array_double_s *array_double_srcptr; typedef ArrayDouble array_double_ct; typedef ArrayDoubleIt array_double_it_ct; typedef double array_double_subtype_ct; static inline void array_double_init(ArrayDouble v) { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); v->size = 0; v->alloc = 0; v->ptr = ((void*)0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_clean(ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); for(size_t i = 0; i < v->size; i++) ((void)(v->ptr[i])); v->size = 0; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_clear(ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); array_double_clean(v); free(v->ptr); v->alloc = 0; v->ptr = ((void*)0); } static inline void array_double_set(ArrayDouble d, const ArrayDouble s) { do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); if ((d == s)) return; if (s->size > d->alloc) { const size_t alloc = s->size; double *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(double)) ? ((void*)0) : realloc ((d->ptr), (alloc)*sizeof (double))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return ; } d->ptr = ptr; d->alloc = alloc; } size_t i; size_t step1 = ((s->size) < (d->size) ? (s->size) : (d->size)); for(i = 0; i < step1; i++) (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (d->ptr[i]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (d->ptr[i]) = (s->ptr[i])); for( ; i < s->size; i++) (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (d->ptr[i]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (d->ptr[i]) = (s->ptr[i])); for( ; i < d->size; i++) ((void)(d->ptr[i])); d->size = s->size; do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_init_set(ArrayDouble d, const ArrayDouble s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); array_double_init(d); array_double_set(d, s); } static inline void array_double_init_move(ArrayDouble d, ArrayDouble s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!(s != ((void*)0))) || (_wassert(L"s != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(s->size <= s->alloc)) || (_wassert(L"s->size <= s->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(s->size == 0 || s->ptr != ((void*)0))) || (_wassert(L"s->size == 0 || s->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); d->size = s->size; d->alloc = s->alloc; d->ptr = s->ptr; s->alloc = 0; s->ptr = ((void*)0); do { (void)( (!!(d != ((void*)0))) || (_wassert(L"d != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(d->size <= d->alloc)) || (_wassert(L"d->size <= d->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(d->size == 0 || d->ptr != ((void*)0))) || (_wassert(L"d->size == 0 || d->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_move(ArrayDouble d, ArrayDouble s) { (void)( (!!(d != s)) || (_wassert(L"d != s", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); array_double_clear(d); array_double_init_move(d, s); } static inline void array_double_set_at(ArrayDouble v, size_t i, double const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (v->ptr[i]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (v->ptr[i]) = (x)); } static inline double const * array_double_back(ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return (((union { double *ptr; double const *cptr; }){&v->ptr[v->size-1]}).cptr); } static inline double * array_double_push_raw(ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); if ((v->size >= v->alloc)) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return ((void*)0); } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); double *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(double)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (double))); if ((ptr == ((void*)0))) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); double *ret = &v->ptr[v->size]; v->size++; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(ret != ((void*)0))) || (_wassert(L"ret != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); return ret; } static inline void array_double_push_back(ArrayDouble v, double const x) { double *data = array_double_push_raw(v); if ((data == ((void*)0)) ) return; (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (*data) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (*data) = (x)); } static inline double * array_double_push_new(ArrayDouble v) { double *data = array_double_push_raw(v); if ((data == ((void*)0)) ) return ((void*)0); ((*data) = 0); return data; } static inline void array_double_push_move(ArrayDouble v, double *x) { (void)( (!!(x != ((void*)0))) || (_wassert(L"x != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); double *data = array_double_push_raw(v); if ((data == ((void*)0)) ) return; do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*data)) == sizeof((*x)));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*data)) == sizeof((*x)));})), memcpy(&((*data)), &((*x)), sizeof ((*data)))), memset(&((*x)), 0, sizeof ((*data)))); } while (0); } static inline void array_double_push_at(ArrayDouble v, size_t key, double const x) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!((key) < (v->size+1))) || (_wassert(L"(key) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); if ((v->size >= v->alloc) ) { (void)( (!!(v->size == v->alloc)) || (_wassert(L"v->size == v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); size_t alloc = (((8) > ((v->alloc)) ? (8) : ((v->alloc)))*2); if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return; } (void)( (!!(alloc > v->size)) || (_wassert(L"alloc > v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); double *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(double)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (double))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); memmove(&v->ptr[key+1], &v->ptr[key], (v->size-key)*sizeof(double)); v->size++; (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (v->ptr[key]) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (v->ptr[key]) = (x)); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_resize(ArrayDouble v, size_t size) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); if (v->size > size) { for(size_t i = size ; i < v->size; i++) ((void)(v->ptr[i])); v->size = size; } else if (v->size < size) { if (size > v->alloc) { size_t alloc = size ; double *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(double)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (double))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) ((v->ptr[i]) = 0); v->size = size; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_reserve(ArrayDouble v, size_t alloc) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); if (v->size > alloc) { alloc = v->size; } if ((alloc == 0)) { free(v->ptr); v->size = v->alloc = 0; v->ptr = ((void*)0); } else { double *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(double)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (double))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline double * array_double_get_at(ArrayDouble v, size_t idx) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); const size_t size = idx + 1; if (v->size <= size) { if ((size > v->alloc) ) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return ((void*)0); } double *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(double)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (double))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return ((void*)0); } v->ptr = ptr; v->alloc = alloc; } for(size_t i = v->size ; i < size; i++) ((v->ptr[i]) = 0); v->size = size; } (void)( (!!(idx < v->size)) || (_wassert(L"idx < v->size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return &v->ptr[idx]; } static inline void array_double_pop_back(double *dest, ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); v->size--; if (dest) { do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), memcpy(&((*dest)), &((v->ptr[v->size])), sizeof ((*dest)))), memset(&((v->ptr[v->size])), 0, sizeof ((*dest)))); } while (0); } else { ((void)(v->ptr[v->size])); } do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_pop_move(double *dest, ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(dest != ((void*)0))) || (_wassert(L"dest != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); v->size--; do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[v->size])));})), memcpy(&((*dest)), &((v->ptr[v->size])), sizeof ((*dest)))), memset(&((v->ptr[v->size])), 0, sizeof ((*dest)))); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_pop_until(ArrayDouble v, ArrayDoubleIt pos) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(v == pos->array)) || (_wassert(L"v == pos->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((pos->index) < (v->size + 1))) || (_wassert(L"(pos->index) < (v->size + 1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); array_double_resize(v, pos->index); } static inline _Bool array_double_empty_p(const ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return v->size == 0; } static inline size_t array_double_size(const ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return v->size; } static inline size_t array_double_capacity(const ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return v->alloc; } static inline void array_double_pop_at(double *dest, ArrayDouble v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(v->size > 0 && v->ptr != ((void*)0))) || (_wassert(L"v->size > 0 && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); if (dest) do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[i])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((*dest)) == sizeof((v->ptr[i])));})), memcpy(&((*dest)), &((v->ptr[i])), sizeof ((*dest)))), memset(&((v->ptr[i])), 0, sizeof ((*dest)))); } while (0); else ((void)(v->ptr[i])); memmove(&v->ptr[i], &v->ptr[i+1], sizeof(double)*(v->size - i) ); v->size--; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline _Bool array_double_erase(ArrayDouble a, size_t i) { do { (void)( (!!(a != ((void*)0))) || (_wassert(L"a != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(a->size <= a->alloc)) || (_wassert(L"a->size <= a->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(a->size == 0 || a->ptr != ((void*)0))) || (_wassert(L"a->size == 0 || a->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); if (i >= a->size) return 0; array_double_pop_at(((void*)0), a, i); return 1; } static inline void array_double_insert_v(ArrayDouble v, size_t i, size_t num) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!((i) < (v->size+1))) || (_wassert(L"(i) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); size_t size = v->size + num; if ((size <= v->size)) { if (num == 0) return; do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * v->size), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return ; } if (size > v->alloc) { size_t alloc = (((8) > ((size)) ? (8) : ((size)))*2) ; if ((alloc <= v->alloc)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return ; } double *ptr = (((alloc) > 0xffffffffffffffffui64 / sizeof(double)) ? ((void*)0) : realloc ((v->ptr), (alloc)*sizeof (double))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * alloc), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return; } v->ptr = ptr; v->alloc = alloc; } memmove(&v->ptr[i+num], &v->ptr[i], sizeof(double)*(v->size - i) ); for(size_t k = i ; k < i+num; k++) ((v->ptr[k]) = 0); v->size = size; do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_remove_v(ArrayDouble v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(i < j && v->ptr != ((void*)0))) || (_wassert(L"i < j && v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!((j) < (v->size+1))) || (_wassert(L"(j) < (v->size+1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); for(size_t k = i ; k < j; k++) ((void)(v->ptr[k])); memmove(&v->ptr[i], &v->ptr[j], sizeof(double)*(v->size - j) ); v->size -= (j-i); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_swap(ArrayDouble v1, ArrayDouble v2) { do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); size_t tmp = v1->size; v1->size = v2->size; v2->size = tmp; tmp = v1->alloc; v1->alloc = v2->alloc; v2->alloc = tmp; double *p = v1->ptr; v1->ptr = v2->ptr; v2->ptr = p; do { (void)( (!!(v1 != ((void*)0))) || (_wassert(L"v1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v1->size <= v1->alloc)) || (_wassert(L"v1->size <= v1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v1->size == 0 || v1->ptr != ((void*)0))) || (_wassert(L"v1->size == 0 || v1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!(v2 != ((void*)0))) || (_wassert(L"v2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v2->size <= v2->alloc)) || (_wassert(L"v2->size <= v2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v2->size == 0 || v2->ptr != ((void*)0))) || (_wassert(L"v2->size == 0 || v2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline void array_double_swap_at(ArrayDouble v, size_t i, size_t j) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!((j) < (v->size))) || (_wassert(L"(j) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); double tmp; do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((tmp)) == sizeof((v->ptr[i])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((tmp)) == sizeof((v->ptr[i])));})), memcpy(&((tmp)), &((v->ptr[i])), sizeof ((tmp)))), memset(&((v->ptr[i])), 0, sizeof ((tmp)))); } while (0); do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[i])) == sizeof((v->ptr[j])));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[i])) == sizeof((v->ptr[j])));})), memcpy(&((v->ptr[i])), &((v->ptr[j])), sizeof ((v->ptr[i])))), memset(&((v->ptr[j])), 0, sizeof ((v->ptr[i])))); } while (0); do { (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[j])) == sizeof((tmp)));})), (((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof((v->ptr[j])) == sizeof((tmp)));})), memcpy(&((v->ptr[j])), &((tmp)), sizeof ((v->ptr[j])))), memset(&((tmp)), 0, sizeof ((v->ptr[j])))); } while (0); do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline double * array_double_get(const ArrayDouble v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return &v->ptr[i]; } static inline double const * array_double_cget(const ArrayDouble v, size_t i) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(v->ptr != ((void*)0))) || (_wassert(L"v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); do { (void)( (!!((i) < (v->size))) || (_wassert(L"(i) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return (((union { double *ptr; double const *cptr; }){&v->ptr[i]}).cptr); } static inline double const * array_double_front(const ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!((0) < (v->size))) || (_wassert(L"(0) < (v->size)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return array_double_cget(v, 0); } static inline void array_double_it(ArrayDoubleIt it, const ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); it->index = 0; it->array = v; } static inline void array_double_it_last(ArrayDoubleIt it, const ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); it->index = v->size - 1; it->array = v; } static inline void array_double_it_end(ArrayDoubleIt it, const ArrayDouble v) { do { (void)( (!!(v != ((void*)0))) || (_wassert(L"v != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size <= v->alloc)) || (_wassert(L"v->size <= v->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(v->size == 0 || v->ptr != ((void*)0))) || (_wassert(L"v->size == 0 || v->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); it->index = v->size; it->array = v; } static inline void array_double_it_set(ArrayDoubleIt it, const ArrayDoubleIt org) { (void)( (!!(it != ((void*)0) && org != ((void*)0))) || (_wassert(L"it != ((void*)0) && org != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); it->index = org->index; it->array = org->array; do { (void)( (!!(it->array != ((void*)0))) || (_wassert(L"it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(it->array->size <= it->array->alloc)) || (_wassert(L"it->array->size <= it->array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(it->array->size == 0 || it->array->ptr != ((void*)0))) || (_wassert(L"it->array->size == 0 || it->array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); } static inline _Bool array_double_end_p(const ArrayDoubleIt it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); return it->index >= it->array->size; } static inline _Bool array_double_last_p(const ArrayDoubleIt it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); return it->index + 1 >= it->array->size; } static inline _Bool array_double_it_equal_p(const ArrayDoubleIt it1, const ArrayDoubleIt it2) { (void)( (!!(it1 != ((void*)0) && it2 != ((void*)0))) || (_wassert(L"it1 != ((void*)0) && it2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); return it1->array == it2->array && it1->index == it2->index; } static inline void array_double_next(ArrayDoubleIt it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); it->index++; } static inline void array_double_previous(ArrayDoubleIt it) { (void)( (!!(it != ((void*)0) && it->array != ((void*)0))) || (_wassert(L"it != ((void*)0) && it->array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); it->index--; } static inline double * array_double_ref(const ArrayDoubleIt it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); return array_double_get(it->array, it->index); } static inline double const * array_double_cref(const ArrayDoubleIt it) { (void)( (!!(it != ((void*)0))) || (_wassert(L"it != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); return array_double_cget(it->array, it->index); } static inline void array_double_insert(ArrayDouble a, ArrayDoubleIt it, double const x) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); array_double_push_at(a, it->index + 1, x); it->index++; } static inline void array_double_remove(ArrayDouble a, ArrayDoubleIt it) { (void)( (!!(it != ((void*)0) && a == it->array)) || (_wassert(L"it != ((void*)0) && a == it->array", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); array_double_pop_at(((void*)0), a, it->index); } static inline void array_double_special_sort(ArrayDouble l, int (*func_type) (double const *a, double const *b)) { int (*func_void)(const void*, const void*); func_void = (int (*)(const void*, const void*))func_type; qsort(l->ptr, l->size, sizeof(double), func_void); } static inline void array_double_special_stable_sort_noalloc (double tab[], size_t size, double tmp[]) { size_t th = 4; double *org_tab = tab; (void)( (!!(size > 1)) || (_wassert(L"size > 1", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); if (m_core_clz64(size-1) & 1) th += th; for(size_t k = 0 ; k < size; ) { size_t max = size - k < 2*th ? size - k : th; (void)( (!!(max >= th)) || (_wassert(L"max >= th", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); for(size_t i = 1; i < max; i++) { size_t j = i; while (j > 0 && ((tab[k+j-1]) < (tab[k+j]) ? -1 : (tab[k+j-1]) > (tab[k+j])) > 0) { do { char _tmp[sizeof (tab[k+j-1])]; ((void) sizeof(struct { int M_LIB_NOT_SAME_TYPE : !!(sizeof(tab[k+j-1]) == sizeof(tab[k+j]));})); memcpy(&_tmp, &(tab[k+j-1]), sizeof (tab[k+j-1])); memcpy(&(tab[k+j-1]), &(tab[k+j]), sizeof (tab[k+j-1])); memcpy(&(tab[k+j]), &_tmp, sizeof (tab[k+j-1])); } while (0); j = j - 1; } } k += max; } while (th < size) { double *dest = tmp; for(size_t k = 0 ; k < size; ) { double *el1 = &tab[k]; double *el2 = &tab[k+th]; size_t n1 = th; size_t n2 = size-k <= 3*th ? size-k-th : th; (void)( (!!(size-k > th)) || (_wassert(L"size-k > th", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(0 < n1 && n1 <= size)) || (_wassert(L"0 < n1 && n1 <= size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(0 < n2 && n2 <= size)) || (_wassert(L"0 < n2 && n2 <= size", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); k += n1+n2; for (;;) { if (((*el1) < (*el2) ? -1 : (*el1) > (*el2)) <= 0) { (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (*dest) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (*dest) = (*el1)); dest++; el1++; if (-- n1 == 0) { if (n2 > 0) { memcpy(dest, el2, n2 * sizeof (double)); dest += n2; } break; } } else { (((void) sizeof(struct { int M_LIB_NOT_A_DEFAULT_TYPE : !!(sizeof (*dest) <= ((sizeof(long long)) > (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t)))) ? (sizeof(long long)) : (((sizeof (long double)) > (sizeof (uintmax_t)) ? (sizeof (long double)) : (sizeof (uintmax_t))))));})), (*dest) = (*el2)); dest++; el2++; if (-- n2 == 0) { if (n1 > 0) { memcpy (dest, el1, n1 * sizeof (double)); dest += n1; } break; } } } } do { double * _tmp = (tab); (tab) = (tmp); (tmp) = _tmp; } while (0); th += th; } (void)( (!!(org_tab == tab)) || (_wassert(L"org_tab == tab", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } static inline void array_double_special_stable_sort(ArrayDouble l) { if ((l->size < 2)) return; double *temp = (((l->size) > 0xffffffffffffffffui64 / sizeof(double)) ? ((void*)0) : realloc ((((void*)0)), (l->size)*sizeof (double))); if (temp == ((void*)0)) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * l->size), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); return; } array_double_special_stable_sort_noalloc(l->ptr, l->size, temp); free(temp); } static inline void array_double_get_str(string_t str, ArrayDouble const array, _Bool append) { do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while(0); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (append ? string_cat_cstr : string_set_cstr) (str, "["); ArrayDoubleIt it; for (array_double_it(it, array); !array_double_end_p(it); array_double_next(it)){ double const *item = array_double_cref(it); (1 ? string_cat_printf : string_printf) (str, _Generic(((void)0,(*item)), char: "%c", _Bool: "%d", signed char: "%hhd", unsigned char: "%hhu", signed short: "%hd", unsigned short: "%hu", signed int: "%d", unsigned int: "%u", long int: "%ld", unsigned long int: "%lu", long long int: "%lld", unsigned long long int: "%llu", float: "%f", double: "%f", long double: "%Lf", const char *: "%s", char *: "%s", const void *: "%p", void *: "%p"), *item); if (!array_double_last_p(it)) string_push_back (str, ','); } string_push_back (str, ']'); do { (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void) 0; (void)( (!!(string_get_cstr(str)[string_size(str)] == 0)) || (_wassert(L"string_get_cstr(str)[string_size(str)] == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(string_size(str) < string_capacity(str))) || (_wassert(L"string_size(str) < string_capacity(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str))) || (_wassert(L"string_capacity(str) < sizeof(string_heap_ct) || !stringi_stack_p(str)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while(0); } static inline void array_double_out_str(FILE *file, const ArrayDouble array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(file != ((void*)0))) || (_wassert(L"file != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); fputc ('[', file); for (size_t i = 0; i < array->size; i++) { double const *item = array_double_cget(array, i); fprintf(file, _Generic(((void)0,(*item)), char: "%c", _Bool: "%d", signed char: "%hhd", unsigned char: "%hhu", signed short: "%hd", unsigned short: "%hu", signed int: "%d", unsigned int: "%u", long int: "%ld", unsigned long int: "%lu", long long int: "%lld", unsigned long long int: "%llu", float: "%f", double: "%f", long double: "%Lf", const char *: "%s", char *: "%s", const void *: "%p", void *: "%p"), *item); if (i != array->size-1) fputc (',', file); } fputc (']', file); } static inline _Bool array_double_parse_str(ArrayDouble array, const char str[], const char**endp) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(str != ((void*)0))) || (_wassert(L"str != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); array_double_clean(array); _Bool success = 0; int c = *str++; if ((c != '[')) goto exit; c = *str++; if ((c == ']')) { success = 1; goto exit; } if ((c == 0)) goto exit; str--; double item; ((item) = 0); do { _Bool b = _Generic(((void)0,*(& item)), char: m_core_parse_char(_Generic(((void)0,(& item)), char*: (& item), default: (char*) 0),str,&str), _Bool: m_core_parse_bool(_Generic(((void)0,(& item)), _Bool*: (& item), default: (_Bool*) 0),str,&str), signed char: m_core_parse_schar(_Generic(((void)0,(& item)), signed char*: (& item), default: (signed char*) 0),str,&str), unsigned char: m_core_parse_uchar(_Generic(((void)0,(& item)), unsigned char*: (& item), default: (unsigned char*) 0),str,&str), signed short: m_core_parse_sshort(_Generic(((void)0,(& item)), signed short*: (& item), default: (signed short*) 0),str,&str), unsigned short: m_core_parse_ushort(_Generic(((void)0,(& item)), unsigned short*: (& item), default: (unsigned short*) 0),str,&str), signed int: m_core_parse_sint(_Generic(((void)0,(& item)), signed int*: (& item), default: (signed int*) 0),str,&str), unsigned int: m_core_parse_uint(_Generic(((void)0,(& item)), unsigned int*: (& item), default: (unsigned int*) 0),str,&str), signed long: m_core_parse_slong(_Generic(((void)0,(& item)), signed long *: (& item), default: (signed long *) 0),str,&str), unsigned long: m_core_parse_ulong(_Generic(((void)0,(& item)), unsigned long*: (& item), default: (unsigned long*) 0),str,&str), signed long long: m_core_parse_sllong(_Generic(((void)0,(& item)), signed long long*: (& item), default: (signed long long*) 0),str,&str), unsigned long long: m_core_parse_ullong(_Generic(((void)0,(& item)), unsigned long long*: (& item), default: (unsigned long long*) 0),str,&str), float: m_core_parse_float(_Generic(((void)0,(& item)), float*: (& item), default: (float*) 0),str,&str), double: m_core_parse_double(_Generic(((void)0,(& item)), double*: (& item), default: (double*) 0),str,&str), long double: m_core_parse_ldouble(_Generic(((void)0,(& item)), long double*: (& item), default: (long double*) 0),str,&str), const char *: 0 , char *: 0 , const void *: 0 , void *: 0 ); do { c = *str++; } while (isspace(c)); if (b == 0 || c == 0) { goto exit_clear; } array_double_push_back(array, item); } while (c == ','); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); success = (c == ']'); exit_clear: ((void)(item)); exit: if (endp) *endp = str; return success; } static inline _Bool array_double_in_str(ArrayDouble array, FILE *file) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(file != ((void*)0))) || (_wassert(L"file != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); array_double_clean(array); int c = fgetc(file); if ((c != '[')) return 0; c = fgetc(file); if ((c == ']')) return 1; if ((c == (-1))) return 0; ungetc(c, file); double item; ((item) = 0); do { _Bool b = _Generic(((void)0,*(& item)), _Bool: m_core_fscan_bool(_Generic(((void)0,(& item)), _Bool*: (& item), default: (_Bool*) 0), file), char: m_core_fscan_char(_Generic(((void)0,(& item)), char*: (& item), default: (char*) 0), file), signed char: m_core_fscan_schar(_Generic(((void)0,(& item)), signed char*: (& item), default: (signed char*) 0),file), unsigned char: m_core_fscan_uchar(_Generic(((void)0,(& item)), unsigned char*: (& item), default: (unsigned char*) 0),file), signed short: m_core_fscan_sshort(_Generic(((void)0,(& item)), signed short*: (& item), default: (signed short*) 0),file), unsigned short: m_core_fscan_ushort(_Generic(((void)0,(& item)), unsigned short*: (& item), default: (unsigned short*) 0), file), signed int: m_core_fscan_sint(_Generic(((void)0,(& item)), signed int*: (& item), default: (signed int*) 0), file), unsigned int: m_core_fscan_uint(_Generic(((void)0,(& item)), unsigned int*: (& item), default: (unsigned int*) 0), file), long int: m_core_fscan_slong(_Generic(((void)0,(& item)), long*: (& item), default: (long*) 0), file), unsigned long int: m_core_fscan_ulong(_Generic(((void)0,(& item)), unsigned long*: (& item), default: (unsigned long*) 0), file), long long int: m_core_fscan_sllong(_Generic(((void)0,(& item)), long long*: (& item), default: (long long*) 0), file), unsigned long long int: m_core_fscan_ullong(_Generic(((void)0,(& item)), unsigned long long*: (& item), default: (unsigned long long*) 0),file), float: m_core_fscan_float(_Generic(((void)0,(& item)), float*: (& item), default: (float*) 0), file), double: m_core_fscan_double(_Generic(((void)0,(& item)), double*: (& item), default: (double*) 0), file), long double: m_core_fscan_ldouble(_Generic(((void)0,(& item)), long double*: (& item), default: (long double*) 0),file), const char *: 0 , char *: 0 , const void *: 0 , void *: 0 ); do { c = fgetc(file); } while (isspace(c)); if (b == 0 || c == (-1)) { break; } array_double_push_back(array, item); } while (c == ','); ((void)(item)); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return c == ']'; } static inline m_serial_return_code_t array_double_out_serial(m_serial_write_t f, const ArrayDouble array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(f != ((void*)0) && f->m_interface != ((void*)0))) || (_wassert(L"f != ((void*)0) && f->m_interface != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); m_serial_return_code_t ret; m_serial_local_t local; ret = f->m_interface->write_array_start(local, f, array->size); for (size_t i = 0; i < array->size; i++) { double const *item = array_double_cget(array, i); if (i != 0) { ret |= f->m_interface->write_array_next(local, f); } ret |= _Generic(((void)0,(*item)), _Bool: (f)->m_interface->write_boolean (f, _Generic(((void)0,((*item))), _Bool: ((*item)), default: (_Bool) 0)), char: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), char: ((*item)), default: (char) 0), sizeof (*item)), signed char: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), signed char: ((*item)), default: (signed char) 0), sizeof (*item)), unsigned char: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned char: ((*item)), default: (unsigned char) 0), sizeof (*item)), signed short: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), signed short: ((*item)), default: (signed short) 0), sizeof (*item)), unsigned short: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned short: ((*item)), default: (unsigned short) 0), sizeof (*item)), signed int: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), signed int: ((*item)), default: (signed int) 0), sizeof (*item)), unsigned int: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned int: ((*item)), default: (unsigned int) 0), sizeof (*item)), long int: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), long: ((*item)), default: (long) 0), sizeof (*item)), unsigned long int: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned long: ((*item)), default: (unsigned long) 0), sizeof (*item)), long long int: (f)->m_interface->write_integer (f, _Generic(((void)0,((*item))), long long: ((*item)), default: (long long) 0), sizeof (*item)), unsigned long long int: (f)->m_interface->write_integer (f, (long long) _Generic(((void)0,((*item))), unsigned long long: ((*item)), default: (unsigned long long) 0), sizeof (*item)), float: (f)->m_interface->write_float (f, _Generic(((void)0,((*item))), float: ((*item)), default: (float) 0), sizeof (*item)), double: (f)->m_interface->write_float (f, _Generic(((void)0,((*item))), double: ((*item)), default: (double) 0), sizeof (*item)), long double: (f)->m_interface->write_float (f, _Generic(((void)0,((*item))), long double: ((*item)), default: (long double) 0), sizeof (*item)), const char *: (f)->m_interface->write_string (f, _Generic(((void)0,((*item))), const char *: ((*item)), default: (const char *) 0), m_core_out_serial_strlen(_Generic(((void)0,((*item))), const char *: ((*item)), default: (const char *) 0)) ), char *: (f)->m_interface->write_string (f, _Generic(((void)0,((*item))), char *: ((*item)), default: (char *) 0), m_core_out_serial_strlen(_Generic(((void)0,((*item))), const char *: ((*item)), default: (const char *) 0)) ), const void *: M_SERIAL_FAIL , void *: M_SERIAL_FAIL ); } ret |= f->m_interface->write_array_end(local, f); return ret & M_SERIAL_FAIL; } static inline m_serial_return_code_t array_double_in_serial(ArrayDouble array, m_serial_read_t f) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); (void)( (!!(f != ((void*)0) && f->m_interface != ((void*)0))) || (_wassert(L"f != ((void*)0) && f->m_interface != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); m_serial_return_code_t ret; m_serial_local_t local; size_t estimated_size = 0; array_double_clean(array); ret = f->m_interface->read_array_start(local, f, &estimated_size); if ((ret != M_SERIAL_OK_CONTINUE)) { return ret; } if (estimated_size != 0) { array_double_reserve(array, estimated_size); } double item; ((item) = 0); do { ret = _Generic(((void)0,*(& item)), _Bool: (f)->m_interface->read_boolean (f, _Generic(((void)0,(& item)), _Bool *: (& item), default: (_Bool *) 0)), char: m_core_in_serial_char(f, _Generic(((void)0,(& item)), char*: (& item), default: (char*) 0)), signed char: m_core_in_serial_schar (f, _Generic(((void)0,(& item)), signed char*: (& item), default: (signed char*) 0)), unsigned char: m_core_in_serial_uchar (f, _Generic(((void)0,(& item)), unsigned char*: (& item), default: (unsigned char*) 0)), signed short: m_core_in_serial_sshort (f, _Generic(((void)0,(& item)), signed short*: (& item), default: (signed short*) 0)), unsigned short: m_core_in_serial_ushort (f, _Generic(((void)0,(& item)), unsigned short*: (& item), default: (unsigned short*) 0)), signed int: m_core_in_serial_sint (f, _Generic(((void)0,(& item)), signed int*: (& item), default: (signed int*) 0)), unsigned int: m_core_in_serial_uint (f, _Generic(((void)0,(& item)), unsigned int*: (& item), default: (unsigned int*) 0)), long int: m_core_in_serial_slong(f, _Generic(((void)0,(& item)), long*: (& item), default: (long*) 0)), unsigned long int: m_core_in_serial_ulong (f, _Generic(((void)0,(& item)), unsigned long*: (& item), default: (unsigned long*) 0)), long long int: m_core_in_serial_sllong (f, _Generic(((void)0,(& item)), long long*: (& item), default: (long long*) 0)), unsigned long long int: m_core_in_serial_ullong (f, _Generic(((void)0,(& item)), unsigned long long*: (& item), default: (unsigned long long*) 0)), float: m_core_in_serial_float(f, _Generic(((void)0,(& item)), float*: (& item), default: (float*) 0)), double: m_core_in_serial_double(f, _Generic(((void)0,(& item)), double*: (& item), default: (double*) 0)), long double: m_core_in_serial_ldouble (f, _Generic(((void)0,(& item)), long double*: (& item), default: (long double*) 0)), const char *: M_SERIAL_FAIL , char *: M_SERIAL_FAIL , const void *: M_SERIAL_FAIL , void *: M_SERIAL_FAIL ); if (ret != M_SERIAL_OK_DONE) { break; } array_double_push_back(array, item); ret = f->m_interface->read_array_next(local, f); } while (ret == M_SERIAL_OK_CONTINUE); ((void)(item)); do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); return ret; } static inline _Bool array_double_equal_p(const ArrayDouble array1, const ArrayDouble array2) { do { (void)( (!!(array1 != ((void*)0))) || (_wassert(L"array1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array1->size <= array1->alloc)) || (_wassert(L"array1->size <= array1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array1->size == 0 || array1->ptr != ((void*)0))) || (_wassert(L"array1->size == 0 || array1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!(array2 != ((void*)0))) || (_wassert(L"array2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array2->size <= array2->alloc)) || (_wassert(L"array2->size <= array2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array2->size == 0 || array2->ptr != ((void*)0))) || (_wassert(L"array2->size == 0 || array2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); if (array1->size != array2->size) return 0; size_t i; for(i = 0; i < array1->size; i++) { double const *item1 = array_double_cget(array1, i); double const *item2 = array_double_cget(array2, i); _Bool b = ((*item1) == (*item2)); if (!b) return 0; } return i == array1->size; } static inline size_t array_double_hash(const ArrayDouble array) { do { (void)( (!!(array != ((void*)0))) || (_wassert(L"array != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size <= array->alloc)) || (_wassert(L"array->size <= array->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(array->size == 0 || array->ptr != ((void*)0))) || (_wassert(L"array->size == 0 || array->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); size_t hash = 0UL ^ 0UL; for(size_t i = 0 ; i < array->size; i++) { size_t hi = (size_t) _Generic((array->ptr[i])+0, int32_t: ( ((uint32_t) _Generic(((void)0,(array->ptr[i])), int32_t: (array->ptr[i]), default: (int32_t) 0)) ^ (((uint32_t) _Generic(((void)0,(array->ptr[i])), int32_t: (array->ptr[i]), default: (int32_t) 0)) << 11) ^ 0UL ), uint32_t: ( (_Generic(((void)0,(array->ptr[i])), uint32_t: (array->ptr[i]), default: (uint32_t) 0)) ^ ((_Generic(((void)0,(array->ptr[i])), uint32_t: (array->ptr[i]), default: (uint32_t) 0)) << 11) ^ 0UL ), int64_t: ( ( ((uint64_t) _Generic(((void)0,(array->ptr[i])), int64_t: (array->ptr[i]), default: (int64_t) 0)) >> 33 ) ^ ((uint64_t) _Generic(((void)0,(array->ptr[i])), int64_t: (array->ptr[i]), default: (int64_t) 0)) ^ (((uint64_t) _Generic(((void)0,(array->ptr[i])), int64_t: (array->ptr[i]), default: (int64_t) 0)) << 11) ^ 0UL ), uint64_t: ( ( (_Generic(((void)0,(array->ptr[i])), uint64_t: (array->ptr[i]), default: (uint64_t) 0)) >> 33 ) ^ (_Generic(((void)0,(array->ptr[i])), uint64_t: (array->ptr[i]), default: (uint64_t) 0)) ^ ((_Generic(((void)0,(array->ptr[i])), uint64_t: (array->ptr[i]), default: (uint64_t) 0)) << 11) ^ 0UL ), default: m_core_hash((const void*) &(array->ptr[i]), sizeof (array->ptr[i])) ); do { hash = (size_t) (((hash) * 0x811C9DC5UL) ^ ((hi))); } while (0); } return ( (hash) >> (sizeof(size_t)*8/2) | (hash) ); } static inline void array_double_splice(ArrayDouble a1, ArrayDouble a2) { do { (void)( (!!(a1 != ((void*)0))) || (_wassert(L"a1 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(a1->size <= a1->alloc)) || (_wassert(L"a1->size <= a1->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(a1->size == 0 || a1->ptr != ((void*)0))) || (_wassert(L"a1->size == 0 || a1->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); do { (void)( (!!(a2 != ((void*)0))) || (_wassert(L"a2 != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(a2->size <= a2->alloc)) || (_wassert(L"a2->size <= a2->alloc", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); (void)( (!!(a2->size == 0 || a2->ptr != ((void*)0))) || (_wassert(L"a2->size == 0 || a2->ptr != ((void*)0)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(42)), 0) ); } while (0); if ((a2->size > 0)) { size_t newSize = a1->size + a2->size; if (newSize > a1->alloc) { double *ptr = (((newSize) > 0xffffffffffffffffui64 / sizeof(double)) ? ((void*)0) : realloc ((a1->ptr), (newSize)*sizeof (double))); if ((ptr == ((void*)0)) ) { do { fprintf((__acrt_iob_func(2)), "ERROR(M*LIB): Cannot allocate %zu bytes of memory at (%s:%s:%d).\n", (size_t) (sizeof (double) * newSize), "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", __func__, 42); abort(); } while (0); } a1->ptr = ptr; a1->alloc = newSize; } memcpy(&a1->ptr[a1->size], &a2->ptr[0], a2->size * sizeof (double)); a2->size = 0; a1->size = newSize; } }
# 42 "D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c"
#pragma clang diagnostic pop


static void test_uint(void)
{
  array_uint_t v;
  array_uint_init(v);

  (void)( (!!(array_uint_empty_p(v) == 1)) || (_wassert(L"array_uint_empty_p(v) == true", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(50)), 0) );

  array_uint_push_back(v, 2);
  (void)( (!!(array_uint_empty_p(v) == 0)) || (_wassert(L"array_uint_empty_p(v) == false", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(53)), 0) );
  unsigned int x;
  array_uint_pop_back(&x, v);
  (void)( (!!(x == 2)) || (_wassert(L"x == 2", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(56)), 0) );

  for(unsigned int i = 0; i < 100; i++)
    array_uint_push_back(v, i);

  unsigned int s = 0;
  for(size_t i = 0; i < array_uint_size(v) ; i++)
    s += *array_uint_cget(v, i);
  (void)( (!!(s == 100 * 99 /2)) || (_wassert(L"s == 100 * 99 /2", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(64)), 0) );

  s = 0;
  for (_Bool local_cont_67 = 1; local_cont_67; local_cont_67 = 0) for(array_uint_subtype_ct *item; local_cont_67 ; local_cont_67 = 0) for(array_uint_it_ct local_iterator_67; local_cont_67 ; local_cont_67 = 0) for(array_uint_it (local_iterator_67, v) ; !array_uint_end_p (local_iterator_67) && (item = array_uint_ref (local_iterator_67), 1) ; array_uint_next (local_iterator_67)) {
    s += *item;
  }
  (void)( (!!(s == 100 * 99 /2)) || (_wassert(L"s == 100 * 99 /2", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(70)), 0) );

  array_uint_pop_at(&s, v, 49);
  (void)( (!!(s == 49)) || (_wassert(L"s == 49", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(73)), 0) );
  array_uint_push_at(v, 49, 49);

  array_uint_pop_at (((void*)0), v, 0);
  (void)( (!!(array_uint_size(v) == 99)) || (_wassert(L"array_uint_size(v) == 99", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(77)), 0) );
  s= 0;
  for(size_t i = 0; i < array_uint_size(v) ; i++)
    s += *array_uint_cget(v, i);
  (void)( (!!(s == 100 * 99 /2)) || (_wassert(L"s == 100 * 99 /2", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(81)), 0) );

  unsigned int *p = array_uint_get(v, 1);
  *p += 999;
  s= 0;
  for(size_t i = 0; i < array_uint_size(v) ; i++)
    s += *array_uint_cget(v, i);
  (void)( (!!(s == 100 * 99 /2 + 999)) || (_wassert(L"s == 100 * 99 /2 + 999", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(88)), 0) );

  array_uint_swap_at(v, 2, 3);
  (void)( (!!(*array_uint_cget(v, 2) == 4)) || (_wassert(L"*array_uint_cget(v, 2) == 4", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(91)), 0) );
  (void)( (!!(*array_uint_cget(v, 3) == 3)) || (_wassert(L"*array_uint_cget(v, 3) == 3", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(92)), 0) );

  array_uint_reserve(v, 0);
  (void)( (!!(array_uint_capacity(v) == array_uint_size(v))) || (_wassert(L"array_uint_capacity(v) == array_uint_size(v)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(95)), 0) );

  const unsigned int *src = array_uint_cget(v, 4);
  (void)( (!!(*src == 5)) || (_wassert(L"*src == 5", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(98)), 0) );

  array_uint_remove_v(v, 1, array_uint_size(v) -1);
  (void)( (!!(array_uint_size(v) == 2)) || (_wassert(L"array_uint_size(v) == 2", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(101)), 0) );
  (void)( (!!(*array_uint_cget(v, 0) == 1)) || (_wassert(L"*array_uint_cget(v, 0) == 1", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(102)), 0) );
  (void)( (!!(*array_uint_cget(v, 1) == 99)) || (_wassert(L"*array_uint_cget(v, 1) == 99", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(103)), 0) );

  for(unsigned int i = 3; i < 100; i++)
    array_uint_push_back(v, i);

  array_uint_resize(v, 10);
  (void)( (!!(array_uint_size(v) == 10)) || (_wassert(L"array_uint_size(v) == 10", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(109)), 0) );
  (void)( (!!(*array_uint_cget(v, 9) == 10)) || (_wassert(L"*array_uint_cget(v, 9) == 10", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(110)), 0) );
  array_uint_resize(v, 1000);
  (void)( (!!(array_uint_size(v) == 1000)) || (_wassert(L"array_uint_size(v) == 1000", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(112)), 0) );
  (void)( (!!(*array_uint_cget(v, 999) == 0)) || (_wassert(L"*array_uint_cget(v, 999) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(113)), 0) );

  array_uint_t v2, v3;
  array_uint_init_set(v2,v);
  array_uint_init(v3);
  array_uint_push_back(v3, 459320);
  array_uint_set(v3, v);
  (void)( (!!(array_uint_equal_p(v3, v))) || (_wassert(L"array_uint_equal_p(v3, v)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(120)), 0) );
  array_uint_push_back(v3, 459320);
  array_uint_set(v3, v);
  (void)( (!!(array_uint_equal_p(v3, v))) || (_wassert(L"array_uint_equal_p(v3, v)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(123)), 0) );
  array_uint_clear(v);
  array_uint_clear(v3);
  (void)( (!!(array_uint_size(v2) == 1000)) || (_wassert(L"array_uint_size(v2) == 1000", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(126)), 0) );
  (void)( (!!(*array_uint_cget(v2, 999) == 0)) || (_wassert(L"*array_uint_cget(v2, 999) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(127)), 0) );
  array_uint_push_at (v2, 0, 1742);
  (void)( (!!(array_uint_size(v2) == 1001)) || (_wassert(L"array_uint_size(v2) == 1001", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(129)), 0) );
  (void)( (!!(*array_uint_cget(v2, 0) == 1742)) || (_wassert(L"*array_uint_cget(v2, 0) == 1742", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(130)), 0) );
  (void)( (!!(*array_uint_cget(v2, 1000) == 0)) || (_wassert(L"*array_uint_cget(v2, 1000) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(131)), 0) );

  array_uint_insert_v (v2, 500, 4);
  (void)( (!!(array_uint_size(v2) == 1005)) || (_wassert(L"array_uint_size(v2) == 1005", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(134)), 0) );
  (void)( (!!(*array_uint_cget(v2, 0) == 1742)) || (_wassert(L"*array_uint_cget(v2, 0) == 1742", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(135)), 0) );
  (void)( (!!(*array_uint_cget(v2, 500) == 0)) || (_wassert(L"*array_uint_cget(v2, 500) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(136)), 0) );
  (void)( (!!(array_uint_size(v2) == 1005)) || (_wassert(L"array_uint_size(v2) == 1005", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(137)), 0) );
  (void)( (!!(*array_uint_cget(v2, 1004) == 0)) || (_wassert(L"*array_uint_cget(v2, 1004) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(138)), 0) );
  array_uint_set_at(v2, 1004, 465487);
  array_uint_insert_v (v2, 500, 0);
  (void)( (!!(array_uint_size(v2) == 1005)) || (_wassert(L"array_uint_size(v2) == 1005", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(141)), 0) );
  (void)( (!!(*array_uint_cget(v2, 1004) == 465487)) || (_wassert(L"*array_uint_cget(v2, 1004) == 465487", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(142)), 0) );
  array_uint_insert_v (v2, 1004, 10000);
  (void)( (!!(array_uint_size(v2) == 11005)) || (_wassert(L"array_uint_size(v2) == 11005", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(144)), 0) );
  (void)( (!!(*array_uint_cget(v2, 11004) == 465487)) || (_wassert(L"*array_uint_cget(v2, 11004) == 465487", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(145)), 0) );
  array_uint_resize(v2, 1005);

  array_uint_init(v);
  array_uint_swap(v,v2);
  (void)( (!!(array_uint_size(v) == 1005)) || (_wassert(L"array_uint_size(v) == 1005", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(150)), 0) );
  (void)( (!!(array_uint_size(v2) == 0)) || (_wassert(L"array_uint_size(v2) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(151)), 0) );

  array_uint_reserve(v, 100);
  (void)( (!!(array_uint_size(v) == 1005)) || (_wassert(L"array_uint_size(v) == 1005", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(154)), 0) );
  (void)( (!!(array_uint_capacity(v) == 1005)) || (_wassert(L"array_uint_capacity(v) == 1005", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(155)), 0) );
  array_uint_reserve(v, 10000);
  (void)( (!!(array_uint_size(v) == 1005)) || (_wassert(L"array_uint_size(v) == 1005", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(157)), 0) );
  (void)( (!!(array_uint_capacity(v) == 10000)) || (_wassert(L"array_uint_capacity(v) == 10000", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(158)), 0) );

  array_uint_set (v, v);
  array_uint_set (v2, v);
  (void)( (!!(array_uint_size(v2) == 1005)) || (_wassert(L"array_uint_size(v2) == 1005", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(162)), 0) );

  array_uint_clean(v);
  (void)( (!!(array_uint_capacity(v) > 0)) || (_wassert(L"array_uint_capacity(v) > 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(165)), 0) );
  array_uint_reserve(v, 0);
  (void)( (!!(array_uint_capacity(v) == 0)) || (_wassert(L"array_uint_capacity(v) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(167)), 0) );

  array_uint_clean(v2);
  array_uint_splice(v, v2);
  (void)( (!!(array_uint_size(v) == 0)) || (_wassert(L"array_uint_size(v) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(171)), 0) );
  (void)( (!!(array_uint_size(v2) == 0)) || (_wassert(L"array_uint_size(v2) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(172)), 0) );

  for(unsigned i = 0; i < 100; i++) {
    array_uint_push_back(v, i);
    array_uint_push_back(v2, 100+i);
  }
  array_uint_splice(v, v2);
  (void)( (!!(array_uint_size(v) == 200)) || (_wassert(L"array_uint_size(v) == 200", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(179)), 0) );
  (void)( (!!(array_uint_size(v2) == 0)) || (_wassert(L"array_uint_size(v2) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(180)), 0) );
  for(unsigned i = 0; i < 200; i++) {
    (void)( (!!(i == *array_uint_get(v, i))) || (_wassert(L"i == *array_uint_get(v, i)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(182)), 0) );
  }

  x = 1478963;
  s = *array_uint_back(v);
  array_uint_push_move(v, &x);
  (void)( (!!(*array_uint_back(v) == 1478963)) || (_wassert(L"*array_uint_back(v) == 1478963", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(188)), 0) );
  x = 0;
  array_uint_pop_move(&x, v);
  (void)( (!!(x == 1478963)) || (_wassert(L"x == 1478963", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(191)), 0) );
  (void)( (!!(s == *array_uint_back(v))) || (_wassert(L"s == *array_uint_back(v)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(192)), 0) );

  s = (unsigned int) array_uint_size (v);
  _Bool b = array_uint_erase (v, 12459);
  (void)( (!!(b == 0)) || (_wassert(L"b == false", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(196)), 0) );
  (void)( (!!(s == array_uint_size (v))) || (_wassert(L"s == array_uint_size (v)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(197)), 0) );
  b = array_uint_erase (v, 0);
  (void)( (!!(b == 1)) || (_wassert(L"b == true", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(199)), 0) );
  (void)( (!!(s == array_uint_size (v)+1)) || (_wassert(L"s == array_uint_size (v)+1", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(200)), 0) );

  array_uint_clear(v);
  array_uint_clear(v2);
}

static void test_mpz(void)
{
  array_mpz_t array1, array2;
  testobj_t z;

  array_mpz_init (array1);
  array_mpz_init (array2);
  testobj_init (z);


  FILE *f = m_core_fopen ("a-marray.dat", "wt");
  if (!f) abort();
  array_mpz_out_str(f, array1);
  fclose (f);

  f = m_core_fopen ("a-marray.dat", "rt");
  if (!f) abort();
  _Bool b = array_mpz_in_str (array2, f);
  (void)( (!!(b == 1)) || (_wassert(L"b == true", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(224)), 0) );
  (void)( (!!(array_mpz_equal_p (array1, array2))) || (_wassert(L"array_mpz_equal_p (array1, array2)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(225)), 0) );
  fclose(f);


  for(int n = 0; n < 1000; n++) {
    testobj_set_ui (z, (unsigned int) n);
    array_mpz_push_back (array1, z);
  }

  f = m_core_fopen ("a-marray.dat", "wt");
  if (!f) abort();
  array_mpz_out_str(f, array1);
  fclose (f);

  f = m_core_fopen ("a-marray.dat", "rt");
  if (!f) abort();
  b = array_mpz_in_str (array2, f);
  (void)( (!!(b == 1)) || (_wassert(L"b == true", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(242)), 0) );
  (void)( (!!(array_mpz_equal_p (array1, array2))) || (_wassert(L"array_mpz_equal_p (array1, array2)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(243)), 0) );
  fclose(f);

  array_mpz_clean(array1);

  for(_Bool _local_cont_str248 = 1; _local_cont_str248 ; ) for(string_t str; _local_cont_str248 && (string_init (str), 1); (string_clear (str), _local_cont_str248 = 0)) for(;_local_cont_str248;_local_cont_str248 = 0) {
    array_mpz_get_str(str, array1, 0);
    (void)( (!!(string_cmp_cstr (str, "[]") == 0)) || (_wassert(L"string_cmp_cstr (str, \"[]\") == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(250)), 0) );
    const char *sp;
    b = array_mpz_parse_str(array2, string_get_cstr(str), &sp);
    (void)( (!!(b)) || (_wassert(L"b", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(253)), 0) );
    (void)( (!!(*sp == 0)) || (_wassert(L"*sp == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(254)), 0) );
    (void)( (!!(array_mpz_equal_p(array1, array2))) || (_wassert(L"array_mpz_equal_p(array1, array2)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(255)), 0) );

    testobj_set_ui (z, 17);
    array_mpz_push_back (array1, z);
    array_mpz_get_str(str, array1, 0);
    (void)( (!!(string_cmp_cstr (str, "[17]") == 0)) || (_wassert(L"string_cmp_cstr (str, \"[17]\") == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(260)), 0) );
    b = array_mpz_parse_str(array2, string_get_cstr(str), &sp);
    (void)( (!!(b)) || (_wassert(L"b", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(262)), 0) );
    (void)( (!!(*sp == 0)) || (_wassert(L"*sp == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(263)), 0) );
    (void)( (!!(array_mpz_equal_p(array1, array2))) || (_wassert(L"array_mpz_equal_p(array1, array2)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(264)), 0) );

    testobj_set_ui (z, 42);
    array_mpz_push_back (array1, z);
    array_mpz_get_str(str, array1, 1);
    (void)( (!!(string_cmp_cstr (str, "[17][17,42]") == 0)) || (_wassert(L"string_cmp_cstr (str, \"[17][17,42]\") == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(269)), 0) );
    b = array_mpz_parse_str(array2, string_get_cstr(str), &sp);
    (void)( (!!(b)) || (_wassert(L"b", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(271)), 0) );
    (void)( (!!(strcmp(sp, "[17,42]") == 0)) || (_wassert(L"strcmp(sp, \"[17,42]\") == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(272)), 0) );
    (void)( (!!(!array_mpz_equal_p(array1, array2))) || (_wassert(L"!array_mpz_equal_p(array1, array2)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(273)), 0) );
    b = array_mpz_parse_str(array2, sp, &sp);
    (void)( (!!(b)) || (_wassert(L"b", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(275)), 0) );
    (void)( (!!(strcmp(sp, "") == 0)) || (_wassert(L"strcmp(sp, \"\") == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(276)), 0) );
    (void)( (!!(array_mpz_equal_p(array1, array2))) || (_wassert(L"array_mpz_equal_p(array1, array2)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(277)), 0) );

    }

  testobj_clear (z);
  array_mpz_clear(array2);
  array_mpz_clear(array1);
}

static void test_d(void)
{
  array_uint_t a1, a2;

  array_uint_init(a1);
  array_uint_init_move(a2, a1);
  (void)( (!!(array_uint_empty_p (a2))) || (_wassert(L"array_uint_empty_p (a2)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(292)), 0) );
  array_uint_init(a1);
  array_uint_move(a1, a2);
  (void)( (!!(array_uint_empty_p (a1))) || (_wassert(L"array_uint_empty_p (a1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(295)), 0) );
  for(int i = 0; i < 10; i++)
    array_uint_push_back (a1, (unsigned int) i);
  array_uint_set_at (a1, 0, 17);
  (void)( (!!(*array_uint_get (a1, 0) == 17)) || (_wassert(L"*array_uint_get (a1, 0) == 17", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(299)), 0) );
  (void)( (!!(*array_uint_back(a1) == 9)) || (_wassert(L"*array_uint_back(a1) == 9", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(300)), 0) );
  unsigned int *p = array_uint_push_new(a1);
  (void)( (!!(*p == 0)) || (_wassert(L"*p == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(302)), 0) );
  *p = 10;
  (void)( (!!(*array_uint_back(a1) == 10)) || (_wassert(L"*array_uint_back(a1) == 10", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(304)), 0) );
  for(int i = 0; i < 10; i++)
    array_uint_push_at (a1, 9, (unsigned int) i);
  (void)( (!!(*array_uint_back(a1) == 10)) || (_wassert(L"*array_uint_back(a1) == 10", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(307)), 0) );
  for(int i = 9; i < 19; i++)
    (void)( (!!(*array_uint_get (a1, (size_t) i) == 18U -(unsigned int) i)) || (_wassert(L"*array_uint_get (a1, (size_t) i) == 18U -(unsigned int) i", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(309)), 0) );

  *array_uint_get_at(a1, 100) = 100;
  (void)( (!!(*array_uint_back(a1) == 100)) || (_wassert(L"*array_uint_back(a1) == 100", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(312)), 0) );
  (void)( (!!(array_uint_size(a1) == 101)) || (_wassert(L"array_uint_size(a1) == 101", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(313)), 0) );
  array_uint_pop_back (((void*)0), a1);
  (void)( (!!(*array_uint_back(a1) == 0)) || (_wassert(L"*array_uint_back(a1) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(315)), 0) );
  (void)( (!!(array_uint_size(a1) == 100)) || (_wassert(L"array_uint_size(a1) == 100", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(316)), 0) );

  array_uint_insert_v (a1, 10, 200);
  (void)( (!!(array_uint_size(a1) == 300)) || (_wassert(L"array_uint_size(a1) == 300", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(319)), 0) );
  for(int i = 10; i < 210; i++) {
    (void)( (!!(*array_uint_get (a1, (size_t)i) == 0)) || (_wassert(L"*array_uint_get (a1, (size_t)i) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(321)), 0) );
  }
  array_uint_it_t it;
  array_uint_it(it, a1);
  array_uint_remove (a1, it);
  (void)( (!!(array_uint_size(a1) == 299)) || (_wassert(L"array_uint_size(a1) == 299", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(326)), 0) );

  array_uint_it_last (it, a1);
  (void)( (!!(array_uint_last_p(it))) || (_wassert(L"array_uint_last_p(it)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(329)), 0) );
  array_uint_it_end (it, a1);
  (void)( (!!(array_uint_end_p(it))) || (_wassert(L"array_uint_end_p(it)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(331)), 0) );
  array_uint_previous (it);
  (void)( (!!(array_uint_last_p(it))) || (_wassert(L"array_uint_last_p(it)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(333)), 0) );
  array_uint_it_t it2;
  array_uint_it_set (it2, it);
  (void)( (!!(array_uint_it_equal_p(it2, it))) || (_wassert(L"array_uint_it_equal_p(it2, it)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(336)), 0) );
  (void)( (!!(*array_uint_ref(it2) == 0)) || (_wassert(L"*array_uint_ref(it2) == 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(337)), 0) );
  array_uint_insert(a1, it2, 17);
  (void)( (!!(array_uint_size(a1) == 300)) || (_wassert(L"array_uint_size(a1) == 300", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(339)), 0) );
  (void)( (!!(*array_uint_ref(it2) == 17)) || (_wassert(L"*array_uint_ref(it2) == 17", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(340)), 0) );

  array_uint_init_set (a2, a1);
  (void)( (!!(array_uint_equal_p (a2, a1))) || (_wassert(L"array_uint_equal_p (a2, a1)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(343)), 0) );

  size_t h = array_uint_hash(a2);
  (void)( (!!(h != 0)) || (_wassert(L"h != 0", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(346)), 0) );

  array_uint_clean(a1);
  array_uint_it(it, a1);
  (void)( (!!(array_uint_end_p (it))) || (_wassert(L"array_uint_end_p (it)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(350)), 0) );
  (void)( (!!(array_uint_last_p (it))) || (_wassert(L"array_uint_last_p (it)", L"D:\\\\gt-generator\\\\motor\\\\include\\\\gt\\\\mlib\\\\tests\\\\test-marray.c", (unsigned)(351)), 0) );

  array_uint_clear(a1);
  array_uint_clear(a2);
}

static void test_double(void)
{
  _Static_assert(0, "M_LIB_NOT_AN_OPLIST" ": " "(M_LET): the given argument is not a valid oplist: " "ArrayDouble"); {





  }
}

int main(void)
{
  test_uint();
  test_mpz();
  test_d();
  test_double();
  exit(0);
}
